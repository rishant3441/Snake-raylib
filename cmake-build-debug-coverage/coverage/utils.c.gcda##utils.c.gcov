        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/utils.c
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\utils.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\utils.c.gcda
        -:    0:Runs:1
        -:    1:/**********************************************************************************************
        -:    2:*
        -:    3:*   raylib.utils - Some common utility functions
        -:    4:*
        -:    5:*   CONFIGURATION:
        -:    6:*
        -:    7:*   #define SUPPORT_TRACELOG
        -:    8:*       Show TraceLog() output messages
        -:    9:*       NOTE: By default LOG_DEBUG traces not shown
        -:   10:*
        -:   11:*
        -:   12:*   LICENSE: zlib/libpng
        -:   13:*
        -:   14:*   Copyright (c) 2014-2021 Ramon Santamaria (@raysan5)
        -:   15:*
        -:   16:*   This software is provided "as-is", without any express or implied warranty. In no event
        -:   17:*   will the authors be held liable for any damages arising from the use of this software.
        -:   18:*
        -:   19:*   Permission is granted to anyone to use this software for any purpose, including commercial
        -:   20:*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
        -:   21:*
        -:   22:*     1. The origin of this software must not be misrepresented; you must not claim that you
        -:   23:*     wrote the original software. If you use this software in a product, an acknowledgment
        -:   24:*     in the product documentation would be appreciated but is not required.
        -:   25:*
        -:   26:*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
        -:   27:*     as being the original software.
        -:   28:*
        -:   29:*     3. This notice may not be removed or altered from any source distribution.
        -:   30:*
        -:   31:**********************************************************************************************/
        -:   32:
        -:   33:#include "raylib.h"                     // WARNING: Required for: LogType enum
        -:   34:
        -:   35:// Check if config flags have been externally provided on compilation line
        -:   36:#if !defined(EXTERNAL_CONFIG_FLAGS)
        -:   37:    #include "config.h"                 // Defines module configuration flags
        -:   38:#endif
        -:   39:
        -:   40:#include "utils.h"
        -:   41:
        -:   42:#if defined(PLATFORM_ANDROID)
        -:   43:    #include <errno.h>                  // Required for: Android error types
        -:   44:    #include <android/log.h>            // Required for: Android log system: __android_log_vprint()
        -:   45:    #include <android/asset_manager.h>  // Required for: Android assets manager: AAsset, AAssetManager_open(), ...
        -:   46:#endif
        -:   47:
        -:   48:#include <stdlib.h>                     // Required for: exit()
        -:   49:#include <stdio.h>                      // Required for: FILE, fopen(), fseek(), ftell(), fread(), fwrite(), fprintf(), vprintf(), fclose()
        -:   50:#include <stdarg.h>                     // Required for: va_list, va_start(), va_end()
        -:   51:#include <string.h>                     // Required for: strcpy(), strcat()
        -:   52:
        -:   53://----------------------------------------------------------------------------------
        -:   54:// Defines and Macros
        -:   55://----------------------------------------------------------------------------------
        -:   56:#ifndef MAX_TRACELOG_MSG_LENGTH
        -:   57:    #define MAX_TRACELOG_MSG_LENGTH     128     // Max length of one trace-log message
        -:   58:#endif
        -:   59:
        -:   60://----------------------------------------------------------------------------------
        -:   61:// Global Variables Definition
        -:   62://----------------------------------------------------------------------------------
        -:   63:static int logTypeLevel = LOG_INFO;                 // Minimum log type level
        -:   64:
        -:   65:static TraceLogCallback traceLog = NULL;            // TraceLog callback function pointer
        -:   66:static LoadFileDataCallback loadFileData = NULL;    // LoadFileData callback funtion pointer
        -:   67:static SaveFileDataCallback saveFileData = NULL;    // SaveFileText callback funtion pointer
        -:   68:static LoadFileTextCallback loadFileText = NULL;    // LoadFileText callback funtion pointer
        -:   69:static SaveFileTextCallback saveFileText = NULL;    // SaveFileText callback funtion pointer
        -:   70:
        -:   71://----------------------------------------------------------------------------------
        -:   72:// Functions to set internal callbacks
        -:   73://----------------------------------------------------------------------------------
function SetTraceLogCallback called 0 returned 0% blocks executed 0%
    #####:   74:void SetTraceLogCallback(TraceLogCallback callback) { traceLog = callback; }              // Set custom trace log
function SetLoadFileDataCallback called 0 returned 0% blocks executed 0%
    #####:   75:void SetLoadFileDataCallback(LoadFileDataCallback callback) { loadFileData = callback; }  // Set custom file data loader
function SetSaveFileDataCallback called 0 returned 0% blocks executed 0%
    #####:   76:void SetSaveFileDataCallback(SaveFileDataCallback callback) { saveFileData = callback; }  // Set custom file data saver
function SetLoadFileTextCallback called 0 returned 0% blocks executed 0%
    #####:   77:void SetLoadFileTextCallback(LoadFileTextCallback callback) { loadFileText = callback; }  // Set custom file text loader
function SetSaveFileTextCallback called 0 returned 0% blocks executed 0%
    #####:   78:void SetSaveFileTextCallback(SaveFileTextCallback callback) { saveFileText = callback; }  // Set custom file text saver
        -:   79:
        -:   80:
        -:   81:#if defined(PLATFORM_ANDROID)
        -:   82:static AAssetManager *assetManager = NULL;              // Android assets manager pointer
        -:   83:static const char *internalDataPath = NULL;             // Android internal data path
        -:   84:#endif
        -:   85:
        -:   86://----------------------------------------------------------------------------------
        -:   87:// Module specific Functions Declaration
        -:   88://----------------------------------------------------------------------------------
        -:   89:#if defined(PLATFORM_ANDROID)
        -:   90:FILE *funopen(const void *cookie, int (*readfn)(void *, char *, int), int (*writefn)(void *, const char *, int),
        -:   91:              fpos_t (*seekfn)(void *, fpos_t, int), int (*closefn)(void *));
        -:   92:
        -:   93:static int android_read(void *cookie, char *buf, int size);
        -:   94:static int android_write(void *cookie, const char *buf, int size);
        -:   95:static fpos_t android_seek(void *cookie, fpos_t offset, int whence);
        -:   96:static int android_close(void *cookie);
        -:   97:#endif
        -:   98:
        -:   99://----------------------------------------------------------------------------------
        -:  100:// Module Functions Definition - Utilities
        -:  101://----------------------------------------------------------------------------------
        -:  102:
        -:  103:// Set the current threshold (minimum) log level
function SetTraceLogLevel called 0 returned 0% blocks executed 0%
    #####:  104:void SetTraceLogLevel(int logType) { logTypeLevel = logType; }
        -:  105:
        -:  106:// Show trace log messages (LOG_INFO, LOG_WARNING, LOG_ERROR, LOG_DEBUG)
function TraceLog called 31 returned 100% blocks executed 42%
       31:  107:void TraceLog(int logType, const char *text, ...)
        -:  108:{
        -:  109:#if defined(SUPPORT_TRACELOG)
        -:  110:    // Message has level below current threshold, don't emit
      31*:  111:    if (logType < logTypeLevel) return;
       31:  111-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 31
    %%%%%:  111-block  1
    %%%%%:  111-block  2
        -:  112:
        -:  113:    va_list args;
       31:  114:    va_start(args, text);
        -:  115:
       31:  116:    if (traceLog)
       31:  116-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 31
        -:  117:    {
    #####:  118:        traceLog(logType, text, args);
    %%%%%:  118-block  0
call    0 never executed
    #####:  119:        va_end(args);
    #####:  120:        return;
        -:  121:    }
        -:  122:
        -:  123:#if defined(PLATFORM_ANDROID)
        -:  124:    switch (logType)
        -:  125:    {
        -:  126:        case LOG_TRACE: __android_log_vprint(ANDROID_LOG_VERBOSE, "raylib", text, args); break;
        -:  127:        case LOG_DEBUG: __android_log_vprint(ANDROID_LOG_DEBUG, "raylib", text, args); break;
        -:  128:        case LOG_INFO: __android_log_vprint(ANDROID_LOG_INFO, "raylib", text, args); break;
        -:  129:        case LOG_WARNING: __android_log_vprint(ANDROID_LOG_WARN, "raylib", text, args); break;
        -:  130:        case LOG_ERROR: __android_log_vprint(ANDROID_LOG_ERROR, "raylib", text, args); break;
        -:  131:        case LOG_FATAL: __android_log_vprint(ANDROID_LOG_FATAL, "raylib", text, args); break;
        -:  132:        default: break;
        -:  133:    }
        -:  134:#else
       31:  135:    char buffer[MAX_TRACELOG_MSG_LENGTH] = { 0 };
        -:  136:
       31:  137:    switch (logType)
       31:  137-block  0
branch  0 taken 0
branch  1 taken 0
branch  2 taken 31
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
        -:  138:    {
    #####:  139:        case LOG_TRACE: strcpy(buffer, "TRACE: "); break;
    %%%%%:  139-block  0
    #####:  140:        case LOG_DEBUG: strcpy(buffer, "DEBUG: "); break;
    %%%%%:  140-block  0
       31:  141:        case LOG_INFO: strcpy(buffer, "INFO: "); break;
       31:  141-block  0
    #####:  142:        case LOG_WARNING: strcpy(buffer, "WARNING: "); break;
    %%%%%:  142-block  0
    #####:  143:        case LOG_ERROR: strcpy(buffer, "ERROR: "); break;
    %%%%%:  143-block  0
    #####:  144:        case LOG_FATAL: strcpy(buffer, "FATAL: "); break;
    %%%%%:  144-block  0
    #####:  145:        default: break;
    %%%%%:  145-block  0
        -:  146:    }
        -:  147:
       31:  148:    strcat(buffer, text);
       31:  149:    strcat(buffer, "\n");
       31:  150:    vprintf(buffer, args);
       31:  150-block  0
call    0 returned 31
        -:  151:#endif
        -:  152:
       31:  153:    va_end(args);
        -:  154:
      31*:  155:    if (logType == LOG_FATAL) exit(EXIT_FAILURE);  // If fatal logging, exit program
branch  0 taken 0 (fallthrough)
branch  1 taken 31
    %%%%%:  155-block  0
call    2 never executed
        -:  156:
        -:  157:#endif  // SUPPORT_TRACELOG
        -:  158:}
        -:  159:
        -:  160:// Internal memory allocator
        -:  161:// NOTE: Initializes to zero by default
function MemAlloc called 0 returned 0% blocks executed 0%
    #####:  162:void *MemAlloc(int size)
        -:  163:{
    #####:  164:    void *ptr = RL_CALLOC(size, 1);
    #####:  165:    return ptr;
    %%%%%:  165-block  0
        -:  166:}
        -:  167:
        -:  168:// Internal memory reallocator
function MemRealloc called 0 returned 0% blocks executed 0%
    #####:  169:void *MemRealloc(void *ptr, int size)
        -:  170:{
    #####:  171:    void *ret = RL_REALLOC(ptr, size);
    #####:  172:    return ret;
    %%%%%:  172-block  0
        -:  173:}
        -:  174:
        -:  175:// Internal memory free
function MemFree called 0 returned 0% blocks executed 0%
    #####:  176:void MemFree(void *ptr)
        -:  177:{
    #####:  178:    RL_FREE(ptr);
    #####:  179:}
        -:  180:
        -:  181:// Load data from file into a buffer
function LoadFileData called 0 returned 0% blocks executed 0%
    #####:  182:unsigned char *LoadFileData(const char *fileName, unsigned int *bytesRead)
        -:  183:{
    #####:  184:    unsigned char *data = NULL;
    #####:  185:    *bytesRead = 0;
        -:  186:
    #####:  187:    if (fileName != NULL)
    %%%%%:  187-block  0
branch  0 never executed
branch  1 never executed
        -:  188:    {
    #####:  189:        if (loadFileData)
    %%%%%:  189-block  0
branch  0 never executed
branch  1 never executed
        -:  190:        {
    #####:  191:            data = loadFileData(fileName, bytesRead);
    %%%%%:  191-block  0
call    0 never executed
    #####:  192:            return data;
        -:  193:        }
        -:  194:#if defined(SUPPORT_STANDARD_FILEIO)
    #####:  195:        FILE *file = fopen(fileName, "rb");
    %%%%%:  195-block  0
call    0 never executed
        -:  196:
    #####:  197:        if (file != NULL)
branch  0 never executed
branch  1 never executed
        -:  198:        {
        -:  199:            // WARNING: On binary streams SEEK_END could not be found,
        -:  200:            // using fseek() and ftell() could not work in some (rare) cases
    #####:  201:            fseek(file, 0, SEEK_END);
    %%%%%:  201-block  0
call    0 never executed
    #####:  202:            int size = ftell(file);
call    0 never executed
    #####:  203:            fseek(file, 0, SEEK_SET);
call    0 never executed
        -:  204:
    #####:  205:            if (size > 0)
branch  0 never executed
branch  1 never executed
        -:  206:            {
    #####:  207:                data = (unsigned char *)RL_MALLOC(size*sizeof(unsigned char));
        -:  208:
        -:  209:                // NOTE: fread() returns number of read elements instead of bytes, so we read [1 byte, size elements]
    #####:  210:                unsigned int count = (unsigned int)fread(data, sizeof(unsigned char), size, file);
    %%%%%:  210-block  0
call    0 never executed
    #####:  211:                *bytesRead = count;
        -:  212:
    #####:  213:                if (count != size) TRACELOG(LOG_WARNING, "FILEIO: [%s] File partially loaded", fileName);
branch  0 never executed
branch  1 never executed
    %%%%%:  213-block  0
call    2 never executed
    #####:  214:                else TRACELOG(LOG_INFO, "FILEIO: [%s] File loaded successfully", fileName);
    %%%%%:  214-block  0
call    0 never executed
        -:  215:            }
    #####:  216:            else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to read file", fileName);
    %%%%%:  216-block  0
call    0 never executed
        -:  217:
    #####:  218:            fclose(file);
    %%%%%:  218-block  0
call    0 never executed
        -:  219:        }
    #####:  220:        else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to open file", fileName);
    %%%%%:  220-block  0
call    0 never executed
        -:  221:#else
        -:  222:    TRACELOG(LOG_WARNING, "FILEIO: Standard file io not supported, use custom file callback");
        -:  223:#endif
        -:  224:    }
    #####:  225:    else TRACELOG(LOG_WARNING, "FILEIO: File name provided is not valid");
    %%%%%:  225-block  0
call    0 never executed
        -:  226:
    #####:  227:    return data;
    %%%%%:  227-block  0
        -:  228:}
        -:  229:
        -:  230:// Unload file data allocated by LoadFileData()
function UnloadFileData called 0 returned 0% blocks executed 0%
    #####:  231:void UnloadFileData(unsigned char *data)
        -:  232:{
    #####:  233:    RL_FREE(data);
    #####:  234:}
        -:  235:
        -:  236:// Save data to file from buffer
function SaveFileData called 0 returned 0% blocks executed 0%
    #####:  237:bool SaveFileData(const char *fileName, void *data, unsigned int bytesToWrite)
        -:  238:{
    #####:  239:    bool success = false;
        -:  240:
    #####:  241:    if (fileName != NULL)
    %%%%%:  241-block  0
branch  0 never executed
branch  1 never executed
        -:  242:    {
    #####:  243:        if (saveFileData)
    %%%%%:  243-block  0
branch  0 never executed
branch  1 never executed
        -:  244:        {
    #####:  245:            return saveFileData(fileName, data, bytesToWrite);
    %%%%%:  245-block  0
call    0 never executed
        -:  246:        }
        -:  247:#if defined(SUPPORT_STANDARD_FILEIO)
    #####:  248:        FILE *file = fopen(fileName, "wb");
    %%%%%:  248-block  0
call    0 never executed
        -:  249:
    #####:  250:        if (file != NULL)
branch  0 never executed
branch  1 never executed
        -:  251:        {
    #####:  252:            unsigned int count = (unsigned int)fwrite(data, sizeof(unsigned char), bytesToWrite, file);
    %%%%%:  252-block  0
call    0 never executed
        -:  253:
    #####:  254:            if (count == 0) TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to write file", fileName);
branch  0 never executed
branch  1 never executed
    %%%%%:  254-block  0
call    2 never executed
    #####:  255:            else if (count != bytesToWrite) TRACELOG(LOG_WARNING, "FILEIO: [%s] File partially written", fileName);
    %%%%%:  255-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  255-block  1
call    2 never executed
    #####:  256:            else TRACELOG(LOG_INFO, "FILEIO: [%s] File saved successfully", fileName);
    %%%%%:  256-block  0
call    0 never executed
        -:  257:
    #####:  258:            int result = fclose(file);
    %%%%%:  258-block  0
call    0 never executed
    #####:  259:            if (result == 0) success = true;
branch  0 never executed
branch  1 never executed
    %%%%%:  259-block  0
        -:  260:        }
    #####:  261:        else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to open file", fileName);
    %%%%%:  261-block  0
call    0 never executed
        -:  262:#else
        -:  263:    TRACELOG(LOG_WARNING, "FILEIO: Standard file io not supported, use custom file callback");
        -:  264:#endif
        -:  265:    }
    #####:  266:    else TRACELOG(LOG_WARNING, "FILEIO: File name provided is not valid");
    %%%%%:  266-block  0
call    0 never executed
        -:  267:
    #####:  268:    return success;
    %%%%%:  268-block  0
        -:  269:}
        -:  270:
        -:  271:// Load text data from file, returns a '\0' terminated string
        -:  272:// NOTE: text chars array should be freed manually
function LoadFileText called 0 returned 0% blocks executed 0%
    #####:  273:char *LoadFileText(const char *fileName)
        -:  274:{
    #####:  275:    char *text = NULL;
        -:  276:
    #####:  277:    if (fileName != NULL)
    %%%%%:  277-block  0
branch  0 never executed
branch  1 never executed
        -:  278:    {
    #####:  279:        if (loadFileText)
    %%%%%:  279-block  0
branch  0 never executed
branch  1 never executed
        -:  280:        {
    #####:  281:            text = loadFileText(fileName);
    %%%%%:  281-block  0
call    0 never executed
    #####:  282:            return text;
        -:  283:        }
        -:  284:#if defined(SUPPORT_STANDARD_FILEIO)
    #####:  285:        FILE *file = fopen(fileName, "rt");
    %%%%%:  285-block  0
call    0 never executed
        -:  286:
    #####:  287:        if (file != NULL)
branch  0 never executed
branch  1 never executed
        -:  288:        {
        -:  289:            // WARNING: When reading a file as 'text' file,
        -:  290:            // text mode causes carriage return-linefeed translation...
        -:  291:            // ...but using fseek() should return correct byte-offset
    #####:  292:            fseek(file, 0, SEEK_END);
    %%%%%:  292-block  0
call    0 never executed
    #####:  293:            unsigned int size = (unsigned int)ftell(file);
call    0 never executed
    #####:  294:            fseek(file, 0, SEEK_SET);
call    0 never executed
        -:  295:
    #####:  296:            if (size > 0)
branch  0 never executed
branch  1 never executed
        -:  297:            {
    #####:  298:                text = (char *)RL_MALLOC((size + 1)*sizeof(char));
    #####:  299:                unsigned int count = (unsigned int)fread(text, sizeof(char), size, file);
    %%%%%:  299-block  0
call    0 never executed
        -:  300:
        -:  301:                // WARNING: \r\n is converted to \n on reading, so,
        -:  302:                // read bytes count gets reduced by the number of lines
    #####:  303:                if (count < size) text = RL_REALLOC(text, count + 1);
branch  0 never executed
branch  1 never executed
    %%%%%:  303-block  0
        -:  304:
        -:  305:                // Zero-terminate the string
    #####:  306:                text[count] = '\0';
        -:  307:
    #####:  308:                TRACELOG(LOG_INFO, "FILEIO: [%s] Text file loaded successfully", fileName);
    %%%%%:  308-block  0
call    0 never executed
        -:  309:            }
    #####:  310:            else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to read text file", fileName);
    %%%%%:  310-block  0
call    0 never executed
        -:  311:
    #####:  312:            fclose(file);
    %%%%%:  312-block  0
call    0 never executed
        -:  313:        }
    #####:  314:        else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to open text file", fileName);
    %%%%%:  314-block  0
call    0 never executed
        -:  315:#else
        -:  316:    TRACELOG(LOG_WARNING, "FILEIO: Standard file io not supported, use custom file callback");
        -:  317:#endif
        -:  318:    }
    #####:  319:    else TRACELOG(LOG_WARNING, "FILEIO: File name provided is not valid");
    %%%%%:  319-block  0
call    0 never executed
        -:  320:
    #####:  321:    return text;
    %%%%%:  321-block  0
        -:  322:}
        -:  323:
        -:  324:// Unload file text data allocated by LoadFileText()
function UnloadFileText called 0 returned 0% blocks executed 0%
    #####:  325:void UnloadFileText(char *text)
        -:  326:{
    #####:  327:    RL_FREE(text);
    #####:  328:}
        -:  329:
        -:  330:// Save text data to file (write), string must be '\0' terminated
function SaveFileText called 0 returned 0% blocks executed 0%
    #####:  331:bool SaveFileText(const char *fileName, char *text)
        -:  332:{
    #####:  333:    bool success = false;
        -:  334:
    #####:  335:    if (fileName != NULL)
    %%%%%:  335-block  0
branch  0 never executed
branch  1 never executed
        -:  336:    {
    #####:  337:        if (saveFileText)
    %%%%%:  337-block  0
branch  0 never executed
branch  1 never executed
        -:  338:        {
    #####:  339:            return saveFileText(fileName, text);
    %%%%%:  339-block  0
call    0 never executed
        -:  340:        }
        -:  341:#if defined(SUPPORT_STANDARD_FILEIO)
    #####:  342:        FILE *file = fopen(fileName, "wt");
    %%%%%:  342-block  0
call    0 never executed
        -:  343:
    #####:  344:        if (file != NULL)
branch  0 never executed
branch  1 never executed
        -:  345:        {
    #####:  346:            int count = fprintf(file, "%s", text);
    %%%%%:  346-block  0
call    0 never executed
        -:  347:
    #####:  348:            if (count < 0) TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to write text file", fileName);
branch  0 never executed
branch  1 never executed
    %%%%%:  348-block  0
call    2 never executed
    #####:  349:            else TRACELOG(LOG_INFO, "FILEIO: [%s] Text file saved successfully", fileName);
    %%%%%:  349-block  0
call    0 never executed
        -:  350:
    #####:  351:            int result = fclose(file);
    %%%%%:  351-block  0
call    0 never executed
    #####:  352:            if (result == 0) success = true;
branch  0 never executed
branch  1 never executed
    %%%%%:  352-block  0
        -:  353:        }
    #####:  354:        else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to open text file", fileName);
    %%%%%:  354-block  0
call    0 never executed
        -:  355:#else
        -:  356:    TRACELOG(LOG_WARNING, "FILEIO: Standard file io not supported, use custom file callback");
        -:  357:#endif
        -:  358:    }
    #####:  359:    else TRACELOG(LOG_WARNING, "FILEIO: File name provided is not valid");
    %%%%%:  359-block  0
call    0 never executed
        -:  360:
    #####:  361:    return success;
    %%%%%:  361-block  0
        -:  362:}
        -:  363:
        -:  364:#if defined(PLATFORM_ANDROID)
        -:  365:// Initialize asset manager from android app
        -:  366:void InitAssetManager(AAssetManager *manager, const char *dataPath)
        -:  367:{
        -:  368:    assetManager = manager;
        -:  369:    internalDataPath = dataPath;
        -:  370:}
        -:  371:
        -:  372:// Replacement for fopen()
        -:  373:// Ref: https://developer.android.com/ndk/reference/group/asset
        -:  374:FILE *android_fopen(const char *fileName, const char *mode)
        -:  375:{
        -:  376:    if (mode[0] == 'w')
        -:  377:    {
        -:  378:        // TODO: fopen() is mapped to android_fopen() that only grants read access
        -:  379:        // to assets directory through AAssetManager but we want to also be able to
        -:  380:        // write data when required using the standard stdio FILE access functions
        -:  381:        // Ref: https://stackoverflow.com/questions/11294487/android-writing-saving-files-from-native-code-only
        -:  382:        #undef fopen
        -:  383:        return fopen(TextFormat("%s/%s", internalDataPath, fileName), mode);
        -:  384:        #define fopen(name, mode) android_fopen(name, mode)
        -:  385:    }
        -:  386:    else
        -:  387:    {
        -:  388:        // NOTE: AAsset provides access to read-only asset
        -:  389:        AAsset *asset = AAssetManager_open(assetManager, fileName, AASSET_MODE_UNKNOWN);
        -:  390:
        -:  391:        if (asset != NULL)
        -:  392:        {
        -:  393:            // Get pointer to file in the assets
        -:  394:            return funopen(asset, android_read, android_write, android_seek, android_close);
        -:  395:        }
        -:  396:        else
        -:  397:        {
        -:  398:            #undef fopen
        -:  399:            // Just do a regular open if file is not found in the assets
        -:  400:            return fopen(TextFormat("%s/%s", internalDataPath, fileName), mode);
        -:  401:            #define fopen(name, mode) android_fopen(name, mode)
        -:  402:        }
        -:  403:    }
        -:  404:}
        -:  405:#endif  // PLATFORM_ANDROID
        -:  406:
        -:  407://----------------------------------------------------------------------------------
        -:  408:// Module specific Functions Definition
        -:  409://----------------------------------------------------------------------------------
        -:  410:#if defined(PLATFORM_ANDROID)
        -:  411:static int android_read(void *cookie, char *buf, int size)
        -:  412:{
        -:  413:    return AAsset_read((AAsset *)cookie, buf, size);
        -:  414:}
        -:  415:
        -:  416:static int android_write(void *cookie, const char *buf, int size)
        -:  417:{
        -:  418:    TRACELOG(LOG_WARNING, "ANDROID: Failed to provide write access to APK");
        -:  419:
        -:  420:    return EACCES;
        -:  421:}
        -:  422:
        -:  423:static fpos_t android_seek(void *cookie, fpos_t offset, int whence)
        -:  424:{
        -:  425:    return AAsset_seek((AAsset *)cookie, offset, whence);
        -:  426:}
        -:  427:
        -:  428:static int android_close(void *cookie)
        -:  429:{
        -:  430:    AAsset_close((AAsset *)cookie);
        -:  431:    return 0;
        -:  432:}
        -:  433:#endif  // PLATFORM_ANDROID
