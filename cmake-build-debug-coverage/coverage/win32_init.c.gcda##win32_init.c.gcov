        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/external/glfw/src/win32_init.c
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\external\glfw\src\CMakeFiles\glfw.dir\win32_init.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\external\glfw\src\CMakeFiles\glfw.dir\win32_init.c.gcda
        -:    0:Runs:1
        -:    1://========================================================================
        -:    2:// GLFW 3.4 Win32 - www.glfw.org
        -:    3://------------------------------------------------------------------------
        -:    4:// Copyright (c) 2002-2006 Marcus Geelnard
        -:    5:// Copyright (c) 2006-2019 Camilla LÃ¶wy <elmindreda@glfw.org>
        -:    6://
        -:    7:// This software is provided 'as-is', without any express or implied
        -:    8:// warranty. In no event will the authors be held liable for any damages
        -:    9:// arising from the use of this software.
        -:   10://
        -:   11:// Permission is granted to anyone to use this software for any purpose,
        -:   12:// including commercial applications, and to alter it and redistribute it
        -:   13:// freely, subject to the following restrictions:
        -:   14://
        -:   15:// 1. The origin of this software must not be misrepresented; you must not
        -:   16://    claim that you wrote the original software. If you use this software
        -:   17://    in a product, an acknowledgment in the product documentation would
        -:   18://    be appreciated but is not required.
        -:   19://
        -:   20:// 2. Altered source versions must be plainly marked as such, and must not
        -:   21://    be misrepresented as being the original software.
        -:   22://
        -:   23:// 3. This notice may not be removed or altered from any source
        -:   24://    distribution.
        -:   25://
        -:   26://========================================================================
        -:   27:// Please use C89 style variable declarations in this file because VS 2010
        -:   28://========================================================================
        -:   29:
        -:   30:#include "internal.h"
        -:   31:
        -:   32:#include <stdlib.h>
        -:   33:#include <malloc.h>
        -:   34:
        -:   35:static const GUID _glfw_GUID_DEVINTERFACE_HID =
        -:   36:    {0x4d1e55b2,0xf16f,0x11cf,{0x88,0xcb,0x00,0x11,0x11,0x00,0x00,0x30}};
        -:   37:
        -:   38:#define GUID_DEVINTERFACE_HID _glfw_GUID_DEVINTERFACE_HID
        -:   39:
        -:   40:#if defined(_GLFW_USE_HYBRID_HPG) || defined(_GLFW_USE_OPTIMUS_HPG)
        -:   41:
        -:   42:#if defined(_GLFW_BUILD_DLL)
        -:   43: #warning "These symbols must be exported by the executable and have no effect in a DLL"
        -:   44:#endif
        -:   45:
        -:   46:// Executables (but not DLLs) exporting this symbol with this value will be
        -:   47:// automatically directed to the high-performance GPU on Nvidia Optimus systems
        -:   48:// with up-to-date drivers
        -:   49://
        -:   50:__declspec(dllexport) DWORD NvOptimusEnablement = 1;
        -:   51:
        -:   52:// Executables (but not DLLs) exporting this symbol with this value will be
        -:   53:// automatically directed to the high-performance GPU on AMD PowerXpress systems
        -:   54:// with up-to-date drivers
        -:   55://
        -:   56:__declspec(dllexport) int AmdPowerXpressRequestHighPerformance = 1;
        -:   57:
        -:   58:#endif // _GLFW_USE_HYBRID_HPG
        -:   59:
        -:   60:#if defined(_GLFW_BUILD_DLL)
        -:   61:
        -:   62:// GLFW DLL entry point
        -:   63://
        -:   64:BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, LPVOID reserved)
        -:   65:{
        -:   66:    return TRUE;
        -:   67:}
        -:   68:
        -:   69:#endif // _GLFW_BUILD_DLL
        -:   70:
        -:   71:// Load necessary libraries (DLLs)
        -:   72://
function loadLibraries called 1 returned 100% blocks executed 89%
        1:   73:static GLFWbool loadLibraries(void)
        -:   74:{
        1:   75:    _glfw.win32.winmm.instance = LoadLibraryA("winmm.dll");
        1:   75-block  0
call    0 returned 1
        1:   76:    if (!_glfw.win32.winmm.instance)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:   77:    {
    #####:   78:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:   78-block  0
call    0 never executed
        -:   79:                             "Win32: Failed to load winmm.dll");
    #####:   80:        return GLFW_FALSE;
        -:   81:    }
        -:   82:
        1:   83:    _glfw.win32.winmm.GetTime = (PFN_timeGetTime)
        1:   84:        GetProcAddress(_glfw.win32.winmm.instance, "timeGetTime");
        1:   84-block  0
call    0 returned 1
        -:   85:
        1:   86:    _glfw.win32.user32.instance = LoadLibraryA("user32.dll");
call    0 returned 1
        1:   87:    if (!_glfw.win32.user32.instance)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:   88:    {
    #####:   89:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:   89-block  0
call    0 never executed
        -:   90:                             "Win32: Failed to load user32.dll");
    #####:   91:        return GLFW_FALSE;
        -:   92:    }
        -:   93:
        1:   94:    _glfw.win32.user32.SetProcessDPIAware_ = (PFN_SetProcessDPIAware)
        1:   95:        GetProcAddress(_glfw.win32.user32.instance, "SetProcessDPIAware");
        1:   95-block  0
call    0 returned 1
        1:   96:    _glfw.win32.user32.ChangeWindowMessageFilterEx_ = (PFN_ChangeWindowMessageFilterEx)
        1:   97:        GetProcAddress(_glfw.win32.user32.instance, "ChangeWindowMessageFilterEx");
call    0 returned 1
        1:   98:    _glfw.win32.user32.EnableNonClientDpiScaling_ = (PFN_EnableNonClientDpiScaling)
        1:   99:        GetProcAddress(_glfw.win32.user32.instance, "EnableNonClientDpiScaling");
call    0 returned 1
        1:  100:    _glfw.win32.user32.SetProcessDpiAwarenessContext_ = (PFN_SetProcessDpiAwarenessContext)
        1:  101:        GetProcAddress(_glfw.win32.user32.instance, "SetProcessDpiAwarenessContext");
call    0 returned 1
        1:  102:    _glfw.win32.user32.GetDpiForWindow_ = (PFN_GetDpiForWindow)
        1:  103:        GetProcAddress(_glfw.win32.user32.instance, "GetDpiForWindow");
call    0 returned 1
        1:  104:    _glfw.win32.user32.AdjustWindowRectExForDpi_ = (PFN_AdjustWindowRectExForDpi)
        1:  105:        GetProcAddress(_glfw.win32.user32.instance, "AdjustWindowRectExForDpi");
call    0 returned 1
        -:  106:
        1:  107:    _glfw.win32.dinput8.instance = LoadLibraryA("dinput8.dll");
call    0 returned 1
        1:  108:    if (_glfw.win32.dinput8.instance)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  109:    {
        1:  110:        _glfw.win32.dinput8.Create = (PFN_DirectInput8Create)
        1:  111:            GetProcAddress(_glfw.win32.dinput8.instance, "DirectInput8Create");
        1:  111-block  0
call    0 returned 1
        -:  112:    }
        -:  113:
        -:  114:    {
        -:  115:        int i;
        1:  116:        const char* names[] =
        -:  117:        {
        -:  118:            "xinput1_4.dll",
        -:  119:            "xinput1_3.dll",
        -:  120:            "xinput9_1_0.dll",
        -:  121:            "xinput1_2.dll",
        -:  122:            "xinput1_1.dll",
        -:  123:            NULL
        -:  124:        };
        -:  125:
       1*:  126:        for (i = 0;  names[i];  i++)
        1:  126-block  0
    %%%%%:  126-block  1
        1:  126-block  2
branch  0 taken 1
branch  1 taken 0 (fallthrough)
        -:  127:        {
        1:  128:            _glfw.win32.xinput.instance = LoadLibraryA(names[i]);
        1:  128-block  0
call    0 returned 1
        1:  129:            if (_glfw.win32.xinput.instance)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  130:            {
        1:  131:                _glfw.win32.xinput.GetCapabilities = (PFN_XInputGetCapabilities)
        1:  132:                    GetProcAddress(_glfw.win32.xinput.instance, "XInputGetCapabilities");
        1:  132-block  0
call    0 returned 1
        1:  133:                _glfw.win32.xinput.GetState = (PFN_XInputGetState)
        1:  134:                    GetProcAddress(_glfw.win32.xinput.instance, "XInputGetState");
call    0 returned 1
        -:  135:
        1:  136:                break;
        -:  137:            }
        -:  138:        }
        -:  139:    }
        -:  140:
        1:  141:    _glfw.win32.dwmapi.instance = LoadLibraryA("dwmapi.dll");
        1:  141-block  0
call    0 returned 1
        1:  142:    if (_glfw.win32.dwmapi.instance)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  143:    {
        1:  144:        _glfw.win32.dwmapi.IsCompositionEnabled = (PFN_DwmIsCompositionEnabled)
        1:  145:            GetProcAddress(_glfw.win32.dwmapi.instance, "DwmIsCompositionEnabled");
        1:  145-block  0
call    0 returned 1
        1:  146:        _glfw.win32.dwmapi.Flush = (PFN_DwmFlush)
        1:  147:            GetProcAddress(_glfw.win32.dwmapi.instance, "DwmFlush");
call    0 returned 1
        1:  148:        _glfw.win32.dwmapi.EnableBlurBehindWindow = (PFN_DwmEnableBlurBehindWindow)
        1:  149:            GetProcAddress(_glfw.win32.dwmapi.instance, "DwmEnableBlurBehindWindow");
call    0 returned 1
        1:  150:        _glfw.win32.dwmapi.GetColorizationColor = (PFN_DwmGetColorizationColor)
        1:  151:            GetProcAddress(_glfw.win32.dwmapi.instance, "DwmGetColorizationColor");
call    0 returned 1
        -:  152:    }
        -:  153:
        1:  154:    _glfw.win32.shcore.instance = LoadLibraryA("shcore.dll");
        1:  154-block  0
call    0 returned 1
        1:  155:    if (_glfw.win32.shcore.instance)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  156:    {
        1:  157:        _glfw.win32.shcore.SetProcessDpiAwareness_ = (PFN_SetProcessDpiAwareness)
        1:  158:            GetProcAddress(_glfw.win32.shcore.instance, "SetProcessDpiAwareness");
        1:  158-block  0
call    0 returned 1
        1:  159:        _glfw.win32.shcore.GetDpiForMonitor_ = (PFN_GetDpiForMonitor)
        1:  160:            GetProcAddress(_glfw.win32.shcore.instance, "GetDpiForMonitor");
call    0 returned 1
        -:  161:    }
        -:  162:
        1:  163:    _glfw.win32.ntdll.instance = LoadLibraryA("ntdll.dll");
        1:  163-block  0
call    0 returned 1
        1:  164:    if (_glfw.win32.ntdll.instance)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  165:    {
        1:  166:        _glfw.win32.ntdll.RtlVerifyVersionInfo_ = (PFN_RtlVerifyVersionInfo)
        1:  167:            GetProcAddress(_glfw.win32.ntdll.instance, "RtlVerifyVersionInfo");
        1:  167-block  0
call    0 returned 1
        -:  168:    }
        -:  169:
        1:  170:    return GLFW_TRUE;
        1:  170-block  0
        -:  171:}
        -:  172:
        -:  173:// Unload used libraries (DLLs)
        -:  174://
function freeLibraries called 1 returned 100% blocks executed 100%
        1:  175:static void freeLibraries(void)
        -:  176:{
        1:  177:    if (_glfw.win32.xinput.instance)
        1:  177-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  178:        FreeLibrary(_glfw.win32.xinput.instance);
        1:  178-block  0
call    0 returned 1
        -:  179:
        1:  180:    if (_glfw.win32.dinput8.instance)
        1:  180-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  181:        FreeLibrary(_glfw.win32.dinput8.instance);
        1:  181-block  0
call    0 returned 1
        -:  182:
        1:  183:    if (_glfw.win32.winmm.instance)
        1:  183-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  184:        FreeLibrary(_glfw.win32.winmm.instance);
        1:  184-block  0
call    0 returned 1
        -:  185:
        1:  186:    if (_glfw.win32.user32.instance)
        1:  186-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  187:        FreeLibrary(_glfw.win32.user32.instance);
        1:  187-block  0
call    0 returned 1
        -:  188:
        1:  189:    if (_glfw.win32.dwmapi.instance)
        1:  189-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  190:        FreeLibrary(_glfw.win32.dwmapi.instance);
        1:  190-block  0
call    0 returned 1
        -:  191:
        1:  192:    if (_glfw.win32.shcore.instance)
        1:  192-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  193:        FreeLibrary(_glfw.win32.shcore.instance);
        1:  193-block  0
call    0 returned 1
        -:  194:
        1:  195:    if (_glfw.win32.ntdll.instance)
        1:  195-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  196:        FreeLibrary(_glfw.win32.ntdll.instance);
        1:  196-block  0
call    0 returned 1
        1:  197:}
        -:  198:
        -:  199:// Create key code translation tables
        -:  200://
function createKeyTables called 1 returned 100% blocks executed 100%
        1:  201:static void createKeyTables(void)
        -:  202:{
        -:  203:    int scancode;
        -:  204:
        1:  205:    memset(_glfw.win32.keycodes, -1, sizeof(_glfw.win32.keycodes));
        1:  206:    memset(_glfw.win32.scancodes, -1, sizeof(_glfw.win32.scancodes));
        -:  207:
        1:  208:    _glfw.win32.keycodes[0x00B] = GLFW_KEY_0;
        1:  209:    _glfw.win32.keycodes[0x002] = GLFW_KEY_1;
        1:  210:    _glfw.win32.keycodes[0x003] = GLFW_KEY_2;
        1:  211:    _glfw.win32.keycodes[0x004] = GLFW_KEY_3;
        1:  212:    _glfw.win32.keycodes[0x005] = GLFW_KEY_4;
        1:  213:    _glfw.win32.keycodes[0x006] = GLFW_KEY_5;
        1:  214:    _glfw.win32.keycodes[0x007] = GLFW_KEY_6;
        1:  215:    _glfw.win32.keycodes[0x008] = GLFW_KEY_7;
        1:  216:    _glfw.win32.keycodes[0x009] = GLFW_KEY_8;
        1:  217:    _glfw.win32.keycodes[0x00A] = GLFW_KEY_9;
        1:  218:    _glfw.win32.keycodes[0x01E] = GLFW_KEY_A;
        1:  219:    _glfw.win32.keycodes[0x030] = GLFW_KEY_B;
        1:  220:    _glfw.win32.keycodes[0x02E] = GLFW_KEY_C;
        1:  221:    _glfw.win32.keycodes[0x020] = GLFW_KEY_D;
        1:  222:    _glfw.win32.keycodes[0x012] = GLFW_KEY_E;
        1:  223:    _glfw.win32.keycodes[0x021] = GLFW_KEY_F;
        1:  224:    _glfw.win32.keycodes[0x022] = GLFW_KEY_G;
        1:  225:    _glfw.win32.keycodes[0x023] = GLFW_KEY_H;
        1:  226:    _glfw.win32.keycodes[0x017] = GLFW_KEY_I;
        1:  227:    _glfw.win32.keycodes[0x024] = GLFW_KEY_J;
        1:  228:    _glfw.win32.keycodes[0x025] = GLFW_KEY_K;
        1:  229:    _glfw.win32.keycodes[0x026] = GLFW_KEY_L;
        1:  230:    _glfw.win32.keycodes[0x032] = GLFW_KEY_M;
        1:  231:    _glfw.win32.keycodes[0x031] = GLFW_KEY_N;
        1:  232:    _glfw.win32.keycodes[0x018] = GLFW_KEY_O;
        1:  233:    _glfw.win32.keycodes[0x019] = GLFW_KEY_P;
        1:  234:    _glfw.win32.keycodes[0x010] = GLFW_KEY_Q;
        1:  235:    _glfw.win32.keycodes[0x013] = GLFW_KEY_R;
        1:  236:    _glfw.win32.keycodes[0x01F] = GLFW_KEY_S;
        1:  237:    _glfw.win32.keycodes[0x014] = GLFW_KEY_T;
        1:  238:    _glfw.win32.keycodes[0x016] = GLFW_KEY_U;
        1:  239:    _glfw.win32.keycodes[0x02F] = GLFW_KEY_V;
        1:  240:    _glfw.win32.keycodes[0x011] = GLFW_KEY_W;
        1:  241:    _glfw.win32.keycodes[0x02D] = GLFW_KEY_X;
        1:  242:    _glfw.win32.keycodes[0x015] = GLFW_KEY_Y;
        1:  243:    _glfw.win32.keycodes[0x02C] = GLFW_KEY_Z;
        -:  244:
        1:  245:    _glfw.win32.keycodes[0x028] = GLFW_KEY_APOSTROPHE;
        1:  246:    _glfw.win32.keycodes[0x02B] = GLFW_KEY_BACKSLASH;
        1:  247:    _glfw.win32.keycodes[0x033] = GLFW_KEY_COMMA;
        1:  248:    _glfw.win32.keycodes[0x00D] = GLFW_KEY_EQUAL;
        1:  249:    _glfw.win32.keycodes[0x029] = GLFW_KEY_GRAVE_ACCENT;
        1:  250:    _glfw.win32.keycodes[0x01A] = GLFW_KEY_LEFT_BRACKET;
        1:  251:    _glfw.win32.keycodes[0x00C] = GLFW_KEY_MINUS;
        1:  252:    _glfw.win32.keycodes[0x034] = GLFW_KEY_PERIOD;
        1:  253:    _glfw.win32.keycodes[0x01B] = GLFW_KEY_RIGHT_BRACKET;
        1:  254:    _glfw.win32.keycodes[0x027] = GLFW_KEY_SEMICOLON;
        1:  255:    _glfw.win32.keycodes[0x035] = GLFW_KEY_SLASH;
        1:  256:    _glfw.win32.keycodes[0x056] = GLFW_KEY_WORLD_2;
        -:  257:
        1:  258:    _glfw.win32.keycodes[0x00E] = GLFW_KEY_BACKSPACE;
        1:  259:    _glfw.win32.keycodes[0x153] = GLFW_KEY_DELETE;
        1:  260:    _glfw.win32.keycodes[0x14F] = GLFW_KEY_END;
        1:  261:    _glfw.win32.keycodes[0x01C] = GLFW_KEY_ENTER;
        1:  262:    _glfw.win32.keycodes[0x001] = GLFW_KEY_ESCAPE;
        1:  263:    _glfw.win32.keycodes[0x147] = GLFW_KEY_HOME;
        1:  264:    _glfw.win32.keycodes[0x152] = GLFW_KEY_INSERT;
        1:  265:    _glfw.win32.keycodes[0x15D] = GLFW_KEY_MENU;
        1:  266:    _glfw.win32.keycodes[0x151] = GLFW_KEY_PAGE_DOWN;
        1:  267:    _glfw.win32.keycodes[0x149] = GLFW_KEY_PAGE_UP;
        1:  268:    _glfw.win32.keycodes[0x045] = GLFW_KEY_PAUSE;
        1:  269:    _glfw.win32.keycodes[0x146] = GLFW_KEY_PAUSE;
        1:  270:    _glfw.win32.keycodes[0x039] = GLFW_KEY_SPACE;
        1:  271:    _glfw.win32.keycodes[0x00F] = GLFW_KEY_TAB;
        1:  272:    _glfw.win32.keycodes[0x03A] = GLFW_KEY_CAPS_LOCK;
        1:  273:    _glfw.win32.keycodes[0x145] = GLFW_KEY_NUM_LOCK;
        1:  274:    _glfw.win32.keycodes[0x046] = GLFW_KEY_SCROLL_LOCK;
        1:  275:    _glfw.win32.keycodes[0x03B] = GLFW_KEY_F1;
        1:  276:    _glfw.win32.keycodes[0x03C] = GLFW_KEY_F2;
        1:  277:    _glfw.win32.keycodes[0x03D] = GLFW_KEY_F3;
        1:  278:    _glfw.win32.keycodes[0x03E] = GLFW_KEY_F4;
        1:  279:    _glfw.win32.keycodes[0x03F] = GLFW_KEY_F5;
        1:  280:    _glfw.win32.keycodes[0x040] = GLFW_KEY_F6;
        1:  281:    _glfw.win32.keycodes[0x041] = GLFW_KEY_F7;
        1:  282:    _glfw.win32.keycodes[0x042] = GLFW_KEY_F8;
        1:  283:    _glfw.win32.keycodes[0x043] = GLFW_KEY_F9;
        1:  284:    _glfw.win32.keycodes[0x044] = GLFW_KEY_F10;
        1:  285:    _glfw.win32.keycodes[0x057] = GLFW_KEY_F11;
        1:  286:    _glfw.win32.keycodes[0x058] = GLFW_KEY_F12;
        1:  287:    _glfw.win32.keycodes[0x064] = GLFW_KEY_F13;
        1:  288:    _glfw.win32.keycodes[0x065] = GLFW_KEY_F14;
        1:  289:    _glfw.win32.keycodes[0x066] = GLFW_KEY_F15;
        1:  290:    _glfw.win32.keycodes[0x067] = GLFW_KEY_F16;
        1:  291:    _glfw.win32.keycodes[0x068] = GLFW_KEY_F17;
        1:  292:    _glfw.win32.keycodes[0x069] = GLFW_KEY_F18;
        1:  293:    _glfw.win32.keycodes[0x06A] = GLFW_KEY_F19;
        1:  294:    _glfw.win32.keycodes[0x06B] = GLFW_KEY_F20;
        1:  295:    _glfw.win32.keycodes[0x06C] = GLFW_KEY_F21;
        1:  296:    _glfw.win32.keycodes[0x06D] = GLFW_KEY_F22;
        1:  297:    _glfw.win32.keycodes[0x06E] = GLFW_KEY_F23;
        1:  298:    _glfw.win32.keycodes[0x076] = GLFW_KEY_F24;
        1:  299:    _glfw.win32.keycodes[0x038] = GLFW_KEY_LEFT_ALT;
        1:  300:    _glfw.win32.keycodes[0x01D] = GLFW_KEY_LEFT_CONTROL;
        1:  301:    _glfw.win32.keycodes[0x02A] = GLFW_KEY_LEFT_SHIFT;
        1:  302:    _glfw.win32.keycodes[0x15B] = GLFW_KEY_LEFT_SUPER;
        1:  303:    _glfw.win32.keycodes[0x137] = GLFW_KEY_PRINT_SCREEN;
        1:  304:    _glfw.win32.keycodes[0x138] = GLFW_KEY_RIGHT_ALT;
        1:  305:    _glfw.win32.keycodes[0x11D] = GLFW_KEY_RIGHT_CONTROL;
        1:  306:    _glfw.win32.keycodes[0x036] = GLFW_KEY_RIGHT_SHIFT;
        1:  307:    _glfw.win32.keycodes[0x15C] = GLFW_KEY_RIGHT_SUPER;
        1:  308:    _glfw.win32.keycodes[0x150] = GLFW_KEY_DOWN;
        1:  309:    _glfw.win32.keycodes[0x14B] = GLFW_KEY_LEFT;
        1:  310:    _glfw.win32.keycodes[0x14D] = GLFW_KEY_RIGHT;
        1:  311:    _glfw.win32.keycodes[0x148] = GLFW_KEY_UP;
        -:  312:
        1:  313:    _glfw.win32.keycodes[0x052] = GLFW_KEY_KP_0;
        1:  314:    _glfw.win32.keycodes[0x04F] = GLFW_KEY_KP_1;
        1:  315:    _glfw.win32.keycodes[0x050] = GLFW_KEY_KP_2;
        1:  316:    _glfw.win32.keycodes[0x051] = GLFW_KEY_KP_3;
        1:  317:    _glfw.win32.keycodes[0x04B] = GLFW_KEY_KP_4;
        1:  318:    _glfw.win32.keycodes[0x04C] = GLFW_KEY_KP_5;
        1:  319:    _glfw.win32.keycodes[0x04D] = GLFW_KEY_KP_6;
        1:  320:    _glfw.win32.keycodes[0x047] = GLFW_KEY_KP_7;
        1:  321:    _glfw.win32.keycodes[0x048] = GLFW_KEY_KP_8;
        1:  322:    _glfw.win32.keycodes[0x049] = GLFW_KEY_KP_9;
        1:  323:    _glfw.win32.keycodes[0x04E] = GLFW_KEY_KP_ADD;
        1:  324:    _glfw.win32.keycodes[0x053] = GLFW_KEY_KP_DECIMAL;
        1:  325:    _glfw.win32.keycodes[0x135] = GLFW_KEY_KP_DIVIDE;
        1:  326:    _glfw.win32.keycodes[0x11C] = GLFW_KEY_KP_ENTER;
        1:  327:    _glfw.win32.keycodes[0x059] = GLFW_KEY_KP_EQUAL;
        1:  328:    _glfw.win32.keycodes[0x037] = GLFW_KEY_KP_MULTIPLY;
        1:  329:    _glfw.win32.keycodes[0x04A] = GLFW_KEY_KP_SUBTRACT;
        -:  330:
      513:  331:    for (scancode = 0;  scancode < 512;  scancode++)
        1:  331-block  0
      512:  331-block  1
      513:  331-block  2
branch  0 taken 512
branch  1 taken 1 (fallthrough)
        -:  332:    {
      512:  333:        if (_glfw.win32.keycodes[scancode] > 0)
      512:  333-block  0
branch  0 taken 119 (fallthrough)
branch  1 taken 393
      119:  334:            _glfw.win32.scancodes[_glfw.win32.keycodes[scancode]] = scancode;
      119:  334-block  0
        -:  335:    }
        1:  336:}
        -:  337:
        -:  338:// Creates a dummy window for behind-the-scenes work
        -:  339://
function createHelperWindow called 1 returned 100% blocks executed 87%
        1:  340:static GLFWbool createHelperWindow(void)
        -:  341:{
        -:  342:    MSG msg;
        -:  343:
        1:  344:    _glfw.win32.helperWindowHandle =
        1:  345:        CreateWindowExW(WS_EX_OVERLAPPEDWINDOW,
        1:  345-block  0
call    0 returned 1
call    1 returned 1
        -:  346:                        _GLFW_WNDCLASSNAME,
        -:  347:                        L"GLFW message window",
        -:  348:                        WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
        -:  349:                        0, 0, 1, 1,
        -:  350:                        NULL, NULL,
        -:  351:                        GetModuleHandleW(NULL),
        -:  352:                        NULL);
        -:  353:
        1:  354:    if (!_glfw.win32.helperWindowHandle)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  355:    {
    #####:  356:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  356-block  0
call    0 never executed
        -:  357:                             "Win32: Failed to create helper window");
    #####:  358:        return GLFW_FALSE;
        -:  359:    }
        -:  360:
        -:  361:    // HACK: The command to the first ShowWindow call is ignored if the parent
        -:  362:    //       process passed along a STARTUPINFO, so clear that with a no-op call
        1:  363:    ShowWindow(_glfw.win32.helperWindowHandle, SW_HIDE);
        1:  363-block  0
call    0 returned 1
        -:  364:
        -:  365:    // Register for HID device notifications
        -:  366:    {
        -:  367:        DEV_BROADCAST_DEVICEINTERFACE_W dbi;
        1:  368:        ZeroMemory(&dbi, sizeof(dbi));
        1:  369:        dbi.dbcc_size = sizeof(dbi);
        1:  370:        dbi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        1:  371:        dbi.dbcc_classguid = GUID_DEVINTERFACE_HID;
        -:  372:
        1:  373:        _glfw.win32.deviceNotificationHandle =
        1:  374:            RegisterDeviceNotificationW(_glfw.win32.helperWindowHandle,
call    0 returned 1
        -:  375:                                        (DEV_BROADCAST_HDR*) &dbi,
        -:  376:                                        DEVICE_NOTIFY_WINDOW_HANDLE);
        -:  377:    }
        -:  378:
        2:  379:    while (PeekMessageW(&msg, _glfw.win32.helperWindowHandle, 0, 0, PM_REMOVE))
        2:  379-block  0
call    0 returned 2
branch  1 taken 1
branch  2 taken 1 (fallthrough)
        -:  380:    {
        1:  381:        TranslateMessage(&msg);
        1:  381-block  0
call    0 returned 1
        1:  382:        DispatchMessageW(&msg);
call    0 returned 1
        -:  383:    }
        -:  384:
        1:  385:   return GLFW_TRUE;
        1:  385-block  0
        -:  386:}
        -:  387:
        -:  388:
        -:  389://////////////////////////////////////////////////////////////////////////
        -:  390://////                       GLFW internal API                      //////
        -:  391://////////////////////////////////////////////////////////////////////////
        -:  392:
        -:  393:// Returns a wide string version of the specified UTF-8 string
        -:  394://
function _glfwCreateWideStringFromUTF8Win32 called 1 returned 100% blocks executed 60%
        1:  395:WCHAR* _glfwCreateWideStringFromUTF8Win32(const char* source)
        -:  396:{
        -:  397:    WCHAR* target;
        -:  398:    int count;
        -:  399:
        1:  400:    count = MultiByteToWideChar(CP_UTF8, 0, source, -1, NULL, 0);
        1:  400-block  0
call    0 returned 1
        1:  401:    if (!count)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  402:    {
    #####:  403:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  403-block  0
call    0 never executed
        -:  404:                             "Win32: Failed to convert string from UTF-8");
    #####:  405:        return NULL;
        -:  406:    }
        -:  407:
        1:  408:    target = calloc(count, sizeof(WCHAR));
        -:  409:
        1:  410:    if (!MultiByteToWideChar(CP_UTF8, 0, source, -1, target, count))
        1:  410-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:  411:    {
    #####:  412:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  412-block  0
call    0 never executed
        -:  413:                             "Win32: Failed to convert string from UTF-8");
    #####:  414:        free(target);
    #####:  415:        return NULL;
        -:  416:    }
        -:  417:
        1:  418:    return target;
        1:  418-block  0
        -:  419:}
        -:  420:
        -:  421:// Returns a UTF-8 string version of the specified wide string
        -:  422://
function _glfwCreateUTF8FromWideStringWin32 called 2 returned 100% blocks executed 60%
        2:  423:char* _glfwCreateUTF8FromWideStringWin32(const WCHAR* source)
        -:  424:{
        -:  425:    char* target;
        -:  426:    int size;
        -:  427:
        2:  428:    size = WideCharToMultiByte(CP_UTF8, 0, source, -1, NULL, 0, NULL, NULL);
        2:  428-block  0
call    0 returned 2
        2:  429:    if (!size)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  430:    {
    #####:  431:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  431-block  0
call    0 never executed
        -:  432:                             "Win32: Failed to convert string to UTF-8");
    #####:  433:        return NULL;
        -:  434:    }
        -:  435:
        2:  436:    target = calloc(size, 1);
        -:  437:
        2:  438:    if (!WideCharToMultiByte(CP_UTF8, 0, source, -1, target, size, NULL, NULL))
        2:  438-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -:  439:    {
    #####:  440:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  440-block  0
call    0 never executed
        -:  441:                             "Win32: Failed to convert string to UTF-8");
    #####:  442:        free(target);
    #####:  443:        return NULL;
        -:  444:    }
        -:  445:
        2:  446:    return target;
        2:  446-block  0
        -:  447:}
        -:  448:
        -:  449:// Reports the specified error, appending information about the last Win32 error
        -:  450://
function _glfwInputErrorWin32 called 0 returned 0% blocks executed 0%
    #####:  451:void _glfwInputErrorWin32(int error, const char* description)
        -:  452:{
    #####:  453:    WCHAR buffer[_GLFW_MESSAGE_SIZE] = L"";
    #####:  454:    char message[_GLFW_MESSAGE_SIZE] = "";
        -:  455:
    #####:  456:    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
call    0 never executed
        -:  457:                       FORMAT_MESSAGE_IGNORE_INSERTS |
        -:  458:                       FORMAT_MESSAGE_MAX_WIDTH_MASK,
        -:  459:                   NULL,
    #####:  460:                   GetLastError() & 0xffff,
    %%%%%:  460-block  0
call    0 never executed
        -:  461:                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        -:  462:                   buffer,
        -:  463:                   sizeof(buffer) / sizeof(WCHAR),
        -:  464:                   NULL);
    #####:  465:    WideCharToMultiByte(CP_UTF8, 0, buffer, -1, message, sizeof(message), NULL, NULL);
call    0 never executed
        -:  466:
    #####:  467:    _glfwInputError(error, "%s: %s", description, message);
call    0 never executed
    #####:  468:}
        -:  469:
        -:  470:// Updates key names according to the current keyboard layout
        -:  471://
function _glfwUpdateKeyNamesWin32 called 1 returned 100% blocks executed 94%
        1:  472:void _glfwUpdateKeyNamesWin32(void)
        -:  473:{
        -:  474:    int key;
        1:  475:    BYTE state[256] = {0};
        -:  476:
        1:  477:    memset(_glfw.win32.keynames, 0, sizeof(_glfw.win32.keynames));
        -:  478:
      318:  479:    for (key = GLFW_KEY_SPACE;  key <= GLFW_KEY_LAST;  key++)
        1:  479-block  0
      317:  479-block  1
      318:  479-block  2
branch  0 taken 317
branch  1 taken 1 (fallthrough)
        -:  480:    {
        -:  481:        UINT vk;
        -:  482:        int scancode, length;
        -:  483:        WCHAR chars[16];
        -:  484:
      317:  485:        scancode = _glfw.win32.scancodes[key];
      317:  486:        if (scancode == -1)
      317:  486-block  0
branch  0 taken 199 (fallthrough)
branch  1 taken 118
      249:  487:            continue;
      199:  487-block  0
      249:  487-block  1
        -:  488:
      118:  489:        if (key >= GLFW_KEY_KP_0 && key <= GLFW_KEY_KP_ADD)
      118:  489-block  0
branch  0 taken 26 (fallthrough)
branch  1 taken 92
       26:  489-block  1
branch  2 taken 15 (fallthrough)
branch  3 taken 11
       15:  490:        {
       15:  491:            const UINT vks[] = {
        -:  492:                VK_NUMPAD0,  VK_NUMPAD1,  VK_NUMPAD2, VK_NUMPAD3,
        -:  493:                VK_NUMPAD4,  VK_NUMPAD5,  VK_NUMPAD6, VK_NUMPAD7,
        -:  494:                VK_NUMPAD8,  VK_NUMPAD9,  VK_DECIMAL, VK_DIVIDE,
        -:  495:                VK_MULTIPLY, VK_SUBTRACT, VK_ADD
        -:  496:            };
        -:  497:
       15:  498:            vk = vks[key - GLFW_KEY_KP_0];
       15:  498-block  0
        -:  499:        }
        -:  500:        else
      103:  501:            vk = MapVirtualKey(scancode, MAPVK_VSC_TO_VK);
      103:  501-block  0
call    0 returned 103
        -:  502:
      118:  503:        length = ToUnicode(vk, scancode, state,
      118:  503-block  0
call    0 returned 118
        -:  504:                           chars, sizeof(chars) / sizeof(WCHAR),
        -:  505:                           0);
        -:  506:
      118:  507:        if (length == -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 118
        -:  508:        {
    #####:  509:            length = ToUnicode(vk, scancode, state,
    %%%%%:  509-block  0
call    0 never executed
        -:  510:                               chars, sizeof(chars) / sizeof(WCHAR),
        -:  511:                               0);
        -:  512:        }
        -:  513:
      118:  514:        if (length < 1)
      118:  514-block  0
branch  0 taken 50 (fallthrough)
branch  1 taken 68
       50:  515:            continue;
       50:  515-block  0
        -:  516:
       68:  517:        WideCharToMultiByte(CP_UTF8, 0, chars, 1,
       68:  518:                            _glfw.win32.keynames[key],
       68:  518-block  0
call    0 returned 68
        -:  519:                            sizeof(_glfw.win32.keynames[key]),
        -:  520:                            NULL, NULL);
        -:  521:    }
        1:  522:}
        -:  523:
        -:  524:// Replacement for IsWindowsVersionOrGreater as MinGW lacks versionhelpers.h
        -:  525://
function _glfwIsWindowsVersionOrGreaterWin32 called 215 returned 100% blocks executed 100%
      215:  526:BOOL _glfwIsWindowsVersionOrGreaterWin32(WORD major, WORD minor, WORD sp)
        -:  527:{
      215:  528:    OSVERSIONINFOEXW osvi = { sizeof(osvi), major, minor, 0, 0, {0}, sp };
      215:  529:    DWORD mask = VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR;
      215:  530:    ULONGLONG cond = VerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL);
      215:  530-block  0
call    0 returned 215
      215:  531:    cond = VerSetConditionMask(cond, VER_MINORVERSION, VER_GREATER_EQUAL);
call    0 returned 215
      215:  532:    cond = VerSetConditionMask(cond, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);
call    0 returned 215
        -:  533:    // HACK: Use RtlVerifyVersionInfo instead of VerifyVersionInfoW as the
        -:  534:    //       latter lies unless the user knew to embed a non-default manifest
        -:  535:    //       announcing support for Windows 10 via supportedOS GUID
      215:  536:    return RtlVerifyVersionInfo(&osvi, mask, cond) == 0;
call    0 returned 215
        -:  537:}
        -:  538:
        -:  539:// Checks whether we are on at least the specified build of Windows 10
        -:  540://
function _glfwIsWindows10BuildOrGreaterWin32 called 8 returned 100% blocks executed 100%
        8:  541:BOOL _glfwIsWindows10BuildOrGreaterWin32(WORD build)
        -:  542:{
        8:  543:    OSVERSIONINFOEXW osvi = { sizeof(osvi), 10, 0, build };
        8:  544:    DWORD mask = VER_MAJORVERSION | VER_MINORVERSION | VER_BUILDNUMBER;
        8:  545:    ULONGLONG cond = VerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL);
        8:  545-block  0
call    0 returned 8
        8:  546:    cond = VerSetConditionMask(cond, VER_MINORVERSION, VER_GREATER_EQUAL);
call    0 returned 8
        8:  547:    cond = VerSetConditionMask(cond, VER_BUILDNUMBER, VER_GREATER_EQUAL);
call    0 returned 8
        -:  548:    // HACK: Use RtlVerifyVersionInfo instead of VerifyVersionInfoW as the
        -:  549:    //       latter lies unless the user knew to embed a non-default manifest
        -:  550:    //       announcing support for Windows 10 via supportedOS GUID
        8:  551:    return RtlVerifyVersionInfo(&osvi, mask, cond) == 0;
call    0 returned 8
        -:  552:}
        -:  553:
        -:  554:
        -:  555://////////////////////////////////////////////////////////////////////////
        -:  556://////                       GLFW platform API                      //////
        -:  557://////////////////////////////////////////////////////////////////////////
        -:  558:
function _glfwPlatformInit called 1 returned 100% blocks executed 67%
        1:  559:int _glfwPlatformInit(void)
        -:  560:{
        -:  561:    // To make SetForegroundWindow work as we want, we need to fiddle
        -:  562:    // with the FOREGROUNDLOCKTIMEOUT system setting (we do this as early
        -:  563:    // as possible in the hope of still being the foreground process)
        1:  564:    SystemParametersInfoW(SPI_GETFOREGROUNDLOCKTIMEOUT, 0,
        1:  564-block  0
call    0 returned 1
        -:  565:                          &_glfw.win32.foregroundLockTimeout, 0);
        1:  566:    SystemParametersInfoW(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, UIntToPtr(0),
call    0 returned 1
call    1 returned 1
        -:  567:                          SPIF_SENDCHANGE);
        -:  568:
        1:  569:    if (!loadLibraries())
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  570:        return GLFW_FALSE;
    %%%%%:  570-block  0
        -:  571:
        1:  572:    createKeyTables();
        1:  572-block  0
call    0 returned 1
        1:  573:    _glfwUpdateKeyNamesWin32();
call    0 returned 1
        -:  574:
        1:  575:    if (_glfwIsWindows10CreatorsUpdateOrGreaterWin32())
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1:  576:        SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
        1:  576-block  0
call    0 returned 1
    #####:  577:    else if (IsWindows8Point1OrGreater())
    %%%%%:  577-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  578:        SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE);
    %%%%%:  578-block  0
call    0 never executed
    #####:  579:    else if (IsWindowsVistaOrGreater())
    %%%%%:  579-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  580:        SetProcessDPIAware();
    %%%%%:  580-block  0
call    0 never executed
        -:  581:
        1:  582:    if (!_glfwRegisterWindowClassWin32())
        1:  582-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  583:        return GLFW_FALSE;
    %%%%%:  583-block  0
        -:  584:
        1:  585:    if (!createHelperWindow())
        1:  585-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  586:        return GLFW_FALSE;
    %%%%%:  586-block  0
        -:  587:
        1:  588:    _glfwInitTimerWin32();
        1:  588-block  0
call    0 returned 1
        -:  589:
        1:  590:    _glfwPollMonitorsWin32();
call    0 returned 1
        1:  591:    return GLFW_TRUE;
        -:  592:}
        -:  593:
function _glfwPlatformTerminate called 1 returned 100% blocks executed 100%
        1:  594:void _glfwPlatformTerminate(void)
        -:  595:{
        1:  596:    if (_glfw.win32.deviceNotificationHandle)
        1:  596-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  597:        UnregisterDeviceNotification(_glfw.win32.deviceNotificationHandle);
        1:  597-block  0
call    0 returned 1
        -:  598:
        1:  599:    if (_glfw.win32.helperWindowHandle)
        1:  599-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  600:        DestroyWindow(_glfw.win32.helperWindowHandle);
        1:  600-block  0
call    0 returned 1
        -:  601:
        1:  602:    _glfwUnregisterWindowClassWin32();
        1:  602-block  0
call    0 returned 1
        -:  603:
        -:  604:    // Restore previous foreground lock timeout system setting
        1:  605:    SystemParametersInfoW(SPI_SETFOREGROUNDLOCKTIMEOUT, 0,
call    0 returned 1
        1:  606:                          UIntToPtr(_glfw.win32.foregroundLockTimeout),
call    0 returned 1
        -:  607:                          SPIF_SENDCHANGE);
        -:  608:
        1:  609:    free(_glfw.win32.clipboardString);
        1:  610:    free(_glfw.win32.rawInput);
        -:  611:
        1:  612:    _glfwTerminateWGL();
call    0 returned 1
        1:  613:    _glfwTerminateEGL();
call    0 returned 1
        -:  614:
        1:  615:    freeLibraries();
call    0 returned 1
        1:  616:}
        -:  617:
function _glfwPlatformGetVersionString called 0 returned 0% blocks executed 0%
    #####:  618:const char* _glfwPlatformGetVersionString(void)
        -:  619:{
    #####:  620:    return _GLFW_VERSION_NUMBER " Win32 WGL EGL OSMesa"
    %%%%%:  620-block  0
        -:  621:#if defined(__MINGW64_VERSION_MAJOR)
        -:  622:        " MinGW-w64"
        -:  623:#elif defined(__MINGW32__)
        -:  624:        " MinGW"
        -:  625:#elif defined(_MSC_VER)
        -:  626:        " VisualC"
        -:  627:#endif
        -:  628:#if defined(_GLFW_USE_HYBRID_HPG) || defined(_GLFW_USE_OPTIMUS_HPG)
        -:  629:        " hybrid-GPU"
        -:  630:#endif
        -:  631:#if defined(_GLFW_BUILD_DLL)
        -:  632:        " DLL"
        -:  633:#endif
        -:  634:        ;
        -:  635:}
        -:  636:
