        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/rlgl.h
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\core.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\core.c.gcda
        -:    0:Runs:1
        -:    1:/**********************************************************************************************
        -:    2:*
        -:    3:*   rlgl v4.0
        -:    4:*
        -:    5:*   An abstraction layer for multiple OpenGL versions (1.1, 2.1, 3.3 Core, ES 2.0)
        -:    6:*   that provides a pseudo-OpenGL 1.1 immediate-mode style API (rlVertex, rlTranslate, rlRotate...)
        -:    7:*
        -:    8:*   When chosing an OpenGL backend different than OpenGL 1.1, some internal buffer are
        -:    9:*   initialized on rlglInit() to accumulate vertex data.
        -:   10:*
        -:   11:*   When an internal state change is required all the stored vertex data is renderer in batch,
        -:   12:*   additioanlly, rlDrawRenderBatchActive() could be called to force flushing of the batch.
        -:   13:*
        -:   14:*   Some additional resources are also loaded for convenience, here the complete list:
        -:   15:*      - Default batch (RLGL.defaultBatch): RenderBatch system to accumulate vertex data
        -:   16:*      - Default texture (RLGL.defaultTextureId): 1x1 white pixel R8G8B8A8
        -:   17:*      - Default shader (RLGL.State.defaultShaderId, RLGL.State.defaultShaderLocs)
        -:   18:*
        -:   19:*   Internal buffer (and additional resources) must be manually unloaded calling rlglClose().
        -:   20:*
        -:   21:*
        -:   22:*   CONFIGURATION:
        -:   23:*
        -:   24:*   #define GRAPHICS_API_OPENGL_11
        -:   25:*   #define GRAPHICS_API_OPENGL_21
        -:   26:*   #define GRAPHICS_API_OPENGL_33
        -:   27:*   #define GRAPHICS_API_OPENGL_ES2
        -:   28:*       Use selected OpenGL graphics backend, should be supported by platform
        -:   29:*       Those preprocessor defines are only used on rlgl module, if OpenGL version is
        -:   30:*       required by any other module, use rlGetVersion() to check it
        -:   31:*
        -:   32:*   #define RLGL_IMPLEMENTATION
        -:   33:*       Generates the implementation of the library into the included file.
        -:   34:*       If not defined, the library is in header only mode and can be included in other headers
        -:   35:*       or source files without problems. But only ONE file should hold the implementation.
        -:   36:*
        -:   37:*   #define SUPPORT_RENDER_TEXTURES_HINT
        -:   38:*       Enable framebuffer objects (fbo) support (enabled by default)
        -:   39:*       Some GPUs could not support them despite the OpenGL version
        -:   40:*
        -:   41:*   #define SUPPORT_GL_DETAILS_INFO
        -:   42:*       Show OpenGL extensions and capabilities detailed logs on init
        -:   43:*
        -:   44:*   rlgl capabilities could be customized just defining some internal
        -:   45:*   values before library inclusion (default values listed):
        -:   46:*
        -:   47:*   #define RL_DEFAULT_BATCH_BUFFER_ELEMENTS   8192    // Default internal render batch elements limits
        -:   48:*   #define RL_DEFAULT_BATCH_BUFFERS              1    // Default number of batch buffers (multi-buffering)
        -:   49:*   #define RL_DEFAULT_BATCH_DRAWCALLS          256    // Default number of batch draw calls (by state changes: mode, texture)
        -:   50:*   #define RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS    4    // Maximum number of textures units that can be activated on batch drawing (SetShaderValueTexture())
        -:   51:*
        -:   52:*   #define RL_MAX_MATRIX_STACK_SIZE             32    // Maximum size of internal Matrix stack
        -:   53:*   #define RL_MAX_SHADER_LOCATIONS              32    // Maximum number of shader locations supported
        -:   54:*   #define RL_CULL_DISTANCE_NEAR              0.01    // Default projection matrix near cull distance
        -:   55:*   #define RL_CULL_DISTANCE_FAR             1000.0    // Default projection matrix far cull distance
        -:   56:*
        -:   57:*   When loading a shader, the following vertex attribute and uniform
        -:   58:*   location names are tried to be set automatically:
        -:   59:*
        -:   60:*   #define RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION     "vertexPosition"    // Binded by default to shader location: 0
        -:   61:*   #define RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD     "vertexTexCoord"    // Binded by default to shader location: 1
        -:   62:*   #define RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL       "vertexNormal"      // Binded by default to shader location: 2
        -:   63:*   #define RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR        "vertexColor"       // Binded by default to shader location: 3
        -:   64:*   #define RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT      "vertexTangent"     // Binded by default to shader location: 4
        -:   65:*   #define RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2    "vertexTexCoord2"   // Binded by default to shader location: 5
        -:   66:*   #define RL_DEFAULT_SHADER_UNIFORM_NAME_MVP         "mvp"               // model-view-projection matrix
        -:   67:*   #define RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW        "matView"           // view matrix
        -:   68:*   #define RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION  "matProjection"     // projection matrix
        -:   69:*   #define RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL       "matModel"          // model matrix
        -:   70:*   #define RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL      "matNormal"         // normal matrix (transpose(inverse(matModelView))
        -:   71:*   #define RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR       "colDiffuse"        // color diffuse (base tint color, multiplied by texture color)
        -:   72:*   #define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0  "texture0"          // texture0 (texture slot active 0)
        -:   73:*   #define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1  "texture1"          // texture1 (texture slot active 1)
        -:   74:*   #define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2  "texture2"          // texture2 (texture slot active 2)
        -:   75:*
        -:   76:*   DEPENDENCIES:
        -:   77:*
        -:   78:*      - OpenGL libraries (depending on platform and OpenGL version selected)
        -:   79:*      - GLAD OpenGL extensions loading library (only for OpenGL 3.3 Core)
        -:   80:*
        -:   81:*
        -:   82:*   LICENSE: zlib/libpng
        -:   83:*
        -:   84:*   Copyright (c) 2014-2021 Ramon Santamaria (@raysan5)
        -:   85:*
        -:   86:*   This software is provided "as-is", without any express or implied warranty. In no event
        -:   87:*   will the authors be held liable for any damages arising from the use of this software.
        -:   88:*
        -:   89:*   Permission is granted to anyone to use this software for any purpose, including commercial
        -:   90:*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
        -:   91:*
        -:   92:*     1. The origin of this software must not be misrepresented; you must not claim that you
        -:   93:*     wrote the original software. If you use this software in a product, an acknowledgment
        -:   94:*     in the product documentation would be appreciated but is not required.
        -:   95:*
        -:   96:*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
        -:   97:*     as being the original software.
        -:   98:*
        -:   99:*     3. This notice may not be removed or altered from any source distribution.
        -:  100:*
        -:  101:**********************************************************************************************/
        -:  102:
        -:  103:#ifndef RLGL_H
        -:  104:#define RLGL_H
        -:  105:
        -:  106:#define SUPPORT_RENDER_TEXTURES_HINT
        -:  107:
        -:  108:#ifndef RLAPI
        -:  109:    #define RLAPI   // We are building or using rlgl as a static library (or Linux shared library)
        -:  110:#endif
        -:  111:
        -:  112:#if defined(_WIN32)
        -:  113:    #if defined(BUILD_LIBTYPE_SHARED)
        -:  114:        #define RLAPI __declspec(dllexport)         // We are building raylib as a Win32 shared library (.dll)
        -:  115:    #elif defined(USE_LIBTYPE_SHARED)
        -:  116:        #define RLAPI __declspec(dllimport)         // We are using raylib as a Win32 shared library (.dll)
        -:  117:    #endif
        -:  118:#endif
        -:  119:
        -:  120:// Support TRACELOG macros
        -:  121:#ifndef TRACELOG
        -:  122:    #define TRACELOG(level, ...) (void)0
        -:  123:    #define TRACELOGD(...) (void)0
        -:  124:#endif
        -:  125:
        -:  126:// Allow custom memory allocators
        -:  127:#ifndef RL_MALLOC
        -:  128:    #define RL_MALLOC(sz)     malloc(sz)
        -:  129:#endif
        -:  130:#ifndef RL_CALLOC
        -:  131:    #define RL_CALLOC(n,sz)   calloc(n,sz)
        -:  132:#endif
        -:  133:#ifndef RL_REALLOC
        -:  134:    #define RL_REALLOC(n,sz)  realloc(n,sz)
        -:  135:#endif
        -:  136:#ifndef RL_FREE
        -:  137:    #define RL_FREE(p)        free(p)
        -:  138:#endif
        -:  139:
        -:  140:// Security check in case no GRAPHICS_API_OPENGL_* defined
        -:  141:#if !defined(GRAPHICS_API_OPENGL_11) && \
        -:  142:    !defined(GRAPHICS_API_OPENGL_21) && \
        -:  143:    !defined(GRAPHICS_API_OPENGL_33) && \
        -:  144:    !defined(GRAPHICS_API_OPENGL_ES2)
        -:  145:        #define GRAPHICS_API_OPENGL_33
        -:  146:#endif
        -:  147:
        -:  148:// Security check in case multiple GRAPHICS_API_OPENGL_* defined
        -:  149:#if defined(GRAPHICS_API_OPENGL_11)
        -:  150:    #if defined(GRAPHICS_API_OPENGL_21)
        -:  151:        #undef GRAPHICS_API_OPENGL_21
        -:  152:    #endif
        -:  153:    #if defined(GRAPHICS_API_OPENGL_33)
        -:  154:        #undef GRAPHICS_API_OPENGL_33
        -:  155:    #endif
        -:  156:    #if defined(GRAPHICS_API_OPENGL_ES2)
        -:  157:        #undef GRAPHICS_API_OPENGL_ES2
        -:  158:    #endif
        -:  159:#endif
        -:  160:
        -:  161:// OpenGL 2.1 uses most of OpenGL 3.3 Core functionality
        -:  162:// WARNING: Specific parts are checked with #if defines
        -:  163:#if defined(GRAPHICS_API_OPENGL_21)
        -:  164:    #define GRAPHICS_API_OPENGL_33
        -:  165:#endif
        -:  166:
        -:  167://----------------------------------------------------------------------------------
        -:  168:// Defines and Macros
        -:  169://----------------------------------------------------------------------------------
        -:  170:
        -:  171:// Default internal render batch elements limits
        -:  172:#ifndef RL_DEFAULT_BATCH_BUFFER_ELEMENTS
        -:  173:    #if defined(GRAPHICS_API_OPENGL_11) || defined(GRAPHICS_API_OPENGL_33)
        -:  174:        // This is the maximum amount of elements (quads) per batch
        -:  175:        // NOTE: Be careful with text, every letter maps to a quad
        -:  176:        #define RL_DEFAULT_BATCH_BUFFER_ELEMENTS   8192
        -:  177:    #endif
        -:  178:    #if defined(GRAPHICS_API_OPENGL_ES2)
        -:  179:        // We reduce memory sizes for embedded systems (RPI and HTML5)
        -:  180:        // NOTE: On HTML5 (emscripten) this is allocated on heap,
        -:  181:        // by default it's only 16MB!...just take care...
        -:  182:        #define RL_DEFAULT_BATCH_BUFFER_ELEMENTS   2048
        -:  183:    #endif
        -:  184:#endif
        -:  185:#ifndef RL_DEFAULT_BATCH_BUFFERS
        -:  186:    #define RL_DEFAULT_BATCH_BUFFERS            1      // Default number of batch buffers (multi-buffering)
        -:  187:#endif
        -:  188:#ifndef RL_DEFAULT_BATCH_DRAWCALLS
        -:  189:    #define RL_DEFAULT_BATCH_DRAWCALLS        256      // Default number of batch draw calls (by state changes: mode, texture)
        -:  190:#endif
        -:  191:#ifndef RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS
        -:  192:    #define RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS  4      // Maximum number of textures units that can be activated on batch drawing (SetShaderValueTexture())
        -:  193:#endif
        -:  194:
        -:  195:// Internal Matrix stack
        -:  196:#ifndef RL_MAX_MATRIX_STACK_SIZE
        -:  197:    #define RL_MAX_MATRIX_STACK_SIZE           32      // Maximum size of Matrix stack
        -:  198:#endif
        -:  199:
        -:  200:// Shader limits
        -:  201:#ifndef RL_MAX_SHADER_LOCATIONS
        -:  202:    #define RL_MAX_SHADER_LOCATIONS            32      // Maximum number of shader locations supported
        -:  203:#endif
        -:  204:
        -:  205:// Projection matrix culling
        -:  206:#ifndef RL_CULL_DISTANCE_NEAR
        -:  207:    #define RL_CULL_DISTANCE_NEAR            0.01      // Default near cull distance
        -:  208:#endif
        -:  209:#ifndef RL_CULL_DISTANCE_FAR
        -:  210:    #define RL_CULL_DISTANCE_FAR           1000.0      // Default far cull distance
        -:  211:#endif
        -:  212:
        -:  213:// Texture parameters (equivalent to OpenGL defines)
        -:  214:#define RL_TEXTURE_WRAP_S                       0x2802      // GL_TEXTURE_WRAP_S
        -:  215:#define RL_TEXTURE_WRAP_T                       0x2803      // GL_TEXTURE_WRAP_T
        -:  216:#define RL_TEXTURE_MAG_FILTER                   0x2800      // GL_TEXTURE_MAG_FILTER
        -:  217:#define RL_TEXTURE_MIN_FILTER                   0x2801      // GL_TEXTURE_MIN_FILTER
        -:  218:
        -:  219:#define RL_TEXTURE_FILTER_NEAREST               0x2600      // GL_NEAREST
        -:  220:#define RL_TEXTURE_FILTER_LINEAR                0x2601      // GL_LINEAR
        -:  221:#define RL_TEXTURE_FILTER_MIP_NEAREST           0x2700      // GL_NEAREST_MIPMAP_NEAREST
        -:  222:#define RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR    0x2702      // GL_NEAREST_MIPMAP_LINEAR
        -:  223:#define RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST    0x2701      // GL_LINEAR_MIPMAP_NEAREST
        -:  224:#define RL_TEXTURE_FILTER_MIP_LINEAR            0x2703      // GL_LINEAR_MIPMAP_LINEAR
        -:  225:#define RL_TEXTURE_FILTER_ANISOTROPIC           0x3000      // Anisotropic filter (custom identifier)
        -:  226:
        -:  227:#define RL_TEXTURE_WRAP_REPEAT                  0x2901      // GL_REPEAT
        -:  228:#define RL_TEXTURE_WRAP_CLAMP                   0x812F      // GL_CLAMP_TO_EDGE
        -:  229:#define RL_TEXTURE_WRAP_MIRROR_REPEAT           0x8370      // GL_MIRRORED_REPEAT
        -:  230:#define RL_TEXTURE_WRAP_MIRROR_CLAMP            0x8742      // GL_MIRROR_CLAMP_EXT
        -:  231:
        -:  232:// Matrix modes (equivalent to OpenGL)
        -:  233:#define RL_MODELVIEW                            0x1700      // GL_MODELVIEW
        -:  234:#define RL_PROJECTION                           0x1701      // GL_PROJECTION
        -:  235:#define RL_TEXTURE                              0x1702      // GL_TEXTURE
        -:  236:
        -:  237:// Primitive assembly draw modes
        -:  238:#define RL_LINES                                0x0001      // GL_LINES
        -:  239:#define RL_TRIANGLES                            0x0004      // GL_TRIANGLES
        -:  240:#define RL_QUADS                                0x0007      // GL_QUADS
        -:  241:
        -:  242:// GL equivalent data types
        -:  243:#define RL_UNSIGNED_BYTE                        0x1401      // GL_UNSIGNED_BYTE
        -:  244:#define RL_FLOAT                                0x1406      // GL_FLOAT
        -:  245:
        -:  246://----------------------------------------------------------------------------------
        -:  247:// Types and Structures Definition
        -:  248://----------------------------------------------------------------------------------
        -:  249:typedef enum {
        -:  250:    OPENGL_11 = 1,
        -:  251:    OPENGL_21,
        -:  252:    OPENGL_33,
        -:  253:    OPENGL_ES_20
        -:  254:} rlGlVersion;
        -:  255:
        -:  256:typedef enum {
        -:  257:    RL_ATTACHMENT_COLOR_CHANNEL0 = 0,
        -:  258:    RL_ATTACHMENT_COLOR_CHANNEL1,
        -:  259:    RL_ATTACHMENT_COLOR_CHANNEL2,
        -:  260:    RL_ATTACHMENT_COLOR_CHANNEL3,
        -:  261:    RL_ATTACHMENT_COLOR_CHANNEL4,
        -:  262:    RL_ATTACHMENT_COLOR_CHANNEL5,
        -:  263:    RL_ATTACHMENT_COLOR_CHANNEL6,
        -:  264:    RL_ATTACHMENT_COLOR_CHANNEL7,
        -:  265:    RL_ATTACHMENT_DEPTH = 100,
        -:  266:    RL_ATTACHMENT_STENCIL = 200,
        -:  267:} rlFramebufferAttachType;
        -:  268:
        -:  269:typedef enum {
        -:  270:    RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0,
        -:  271:    RL_ATTACHMENT_CUBEMAP_NEGATIVE_X,
        -:  272:    RL_ATTACHMENT_CUBEMAP_POSITIVE_Y,
        -:  273:    RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y,
        -:  274:    RL_ATTACHMENT_CUBEMAP_POSITIVE_Z,
        -:  275:    RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z,
        -:  276:    RL_ATTACHMENT_TEXTURE2D = 100,
        -:  277:    RL_ATTACHMENT_RENDERBUFFER = 200,
        -:  278:} rlFramebufferAttachTextureType;
        -:  279:
        -:  280:// Dynamic vertex buffers (position + texcoords + colors + indices arrays)
        -:  281:typedef struct rlVertexBuffer {
        -:  282:    int elementCount;           // Number of elements in the buffer (QUADS)
        -:  283:
        -:  284:    int vCounter;               // Vertex position counter to process (and draw) from full buffer
        -:  285:    int tcCounter;              // Vertex texcoord counter to process (and draw) from full buffer
        -:  286:    int cCounter;               // Vertex color counter to process (and draw) from full buffer
        -:  287:
        -:  288:    float *vertices;            // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
        -:  289:    float *texcoords;           // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
        -:  290:    unsigned char *colors;      // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
        -:  291:#if defined(GRAPHICS_API_OPENGL_11) || defined(GRAPHICS_API_OPENGL_33)
        -:  292:    unsigned int *indices;      // Vertex indices (in case vertex data comes indexed) (6 indices per quad)
        -:  293:#endif
        -:  294:#if defined(GRAPHICS_API_OPENGL_ES2)
        -:  295:    unsigned short *indices;    // Vertex indices (in case vertex data comes indexed) (6 indices per quad)
        -:  296:#endif
        -:  297:    unsigned int vaoId;         // OpenGL Vertex Array Object id
        -:  298:    unsigned int vboId[4];      // OpenGL Vertex Buffer Objects id (4 types of vertex data)
        -:  299:} rlVertexBuffer;
        -:  300:
        -:  301:// Draw call type
        -:  302:// NOTE: Only texture changes register a new draw, other state-change-related elements are not
        -:  303:// used at this moment (vaoId, shaderId, matrices), raylib just forces a batch draw call if any
        -:  304:// of those state-change happens (this is done in core module)
        -:  305:typedef struct rlDrawCall {
        -:  306:    int mode;                   // Drawing mode: LINES, TRIANGLES, QUADS
        -:  307:    int vertexCount;            // Number of vertex of the draw
        -:  308:    int vertexAlignment;        // Number of vertex required for index alignment (LINES, TRIANGLES)
        -:  309:    //unsigned int vaoId;       // Vertex array id to be used on the draw -> Using RLGL.currentBatch->vertexBuffer.vaoId
        -:  310:    //unsigned int shaderId;    // Shader id to be used on the draw -> Using RLGL.currentShaderId
        -:  311:    unsigned int textureId;     // Texture id to be used on the draw -> Use to create new draw call if changes
        -:  312:
        -:  313:    //Matrix projection;      // Projection matrix for this draw -> Using RLGL.projection by default
        -:  314:    //Matrix modelview;       // Modelview matrix for this draw -> Using RLGL.modelview by default
        -:  315:} rlDrawCall;
        -:  316:
        -:  317:// rlRenderBatch type
        -:  318:typedef struct rlRenderBatch {
        -:  319:    int bufferCount;           // Number of vertex buffers (multi-buffering support)
        -:  320:    int currentBuffer;          // Current buffer tracking in case of multi-buffering
        -:  321:    rlVertexBuffer *vertexBuffer; // Dynamic buffer(s) for vertex data
        -:  322:
        -:  323:    rlDrawCall *draws;          // Draw calls array, depends on textureId
        -:  324:    int drawCounter;            // Draw calls counter
        -:  325:    float currentDepth;         // Current depth value for next draw
        -:  326:} rlRenderBatch;
        -:  327:
        -:  328:#if defined(__STDC__) && __STDC_VERSION__ >= 199901L
        -:  329:    #include <stdbool.h>
        -:  330:#elif !defined(__cplusplus) && !defined(bool) && !defined(RL_BOOL_TYPE)
        -:  331:    // Boolean type
        -:  332:    typedef enum bool { false, true } bool;
        -:  333:#endif
        -:  334:
        -:  335:#if !defined(RL_MATRIX_TYPE)
        -:  336:// Matrix, 4x4 components, column major, OpenGL style, right handed
        -:  337:typedef struct Matrix {
        -:  338:    float m0, m4, m8, m12;  // Matrix first row (4 components)
        -:  339:    float m1, m5, m9, m13;  // Matrix second row (4 components)
        -:  340:    float m2, m6, m10, m14; // Matrix third row (4 components)
        -:  341:    float m3, m7, m11, m15; // Matrix fourth row (4 components)
        -:  342:} Matrix;
        -:  343:#define RL_MATRIX_TYPE
        -:  344:#endif
        -:  345:
        -:  346:// Trace log level
        -:  347:// NOTE: Organized by priority level
        -:  348:typedef enum {
        -:  349:    RL_LOG_ALL = 0,            // Display all logs
        -:  350:    RL_LOG_TRACE,              // Trace logging, intended for internal use only
        -:  351:    RL_LOG_DEBUG,              // Debug logging, used for internal debugging, it should be disabled on release builds
        -:  352:    RL_LOG_INFO,               // Info logging, used for program execution info
        -:  353:    RL_LOG_WARNING,            // Warning logging, used on recoverable failures
        -:  354:    RL_LOG_ERROR,              // Error logging, used on unrecoverable failures
        -:  355:    RL_LOG_FATAL,              // Fatal logging, used to abort program: exit(EXIT_FAILURE)
        -:  356:    RL_LOG_NONE                // Disable logging
        -:  357:} rlTraceLogLevel;
        -:  358:
        -:  359:// Texture formats (support depends on OpenGL version)
        -:  360:typedef enum {
        -:  361:    RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,     // 8 bit per pixel (no alpha)
        -:  362:    RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,        // 8*2 bpp (2 channels)
        -:  363:    RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5,            // 16 bpp
        -:  364:    RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8,            // 24 bpp
        -:  365:    RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,          // 16 bpp (1 bit alpha)
        -:  366:    RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,          // 16 bpp (4 bit alpha)
        -:  367:    RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,          // 32 bpp
        -:  368:    RL_PIXELFORMAT_UNCOMPRESSED_R32,               // 32 bpp (1 channel - float)
        -:  369:    RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32,         // 32*3 bpp (3 channels - float)
        -:  370:    RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,      // 32*4 bpp (4 channels - float)
        -:  371:    RL_PIXELFORMAT_COMPRESSED_DXT1_RGB,            // 4 bpp (no alpha)
        -:  372:    RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA,           // 4 bpp (1 bit alpha)
        -:  373:    RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA,           // 8 bpp
        -:  374:    RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA,           // 8 bpp
        -:  375:    RL_PIXELFORMAT_COMPRESSED_ETC1_RGB,            // 4 bpp
        -:  376:    RL_PIXELFORMAT_COMPRESSED_ETC2_RGB,            // 4 bpp
        -:  377:    RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,       // 8 bpp
        -:  378:    RL_PIXELFORMAT_COMPRESSED_PVRT_RGB,            // 4 bpp
        -:  379:    RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA,           // 4 bpp
        -:  380:    RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,       // 8 bpp
        -:  381:    RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA        // 2 bpp
        -:  382:} rlPixelFormat;
        -:  383:
        -:  384:// Texture parameters: filter mode
        -:  385:// NOTE 1: Filtering considers mipmaps if available in the texture
        -:  386:// NOTE 2: Filter is accordingly set for minification and magnification
        -:  387:typedef enum {
        -:  388:    RL_TEXTURE_FILTER_POINT = 0,               // No filter, just pixel aproximation
        -:  389:    RL_TEXTURE_FILTER_BILINEAR,                // Linear filtering
        -:  390:    RL_TEXTURE_FILTER_TRILINEAR,               // Trilinear filtering (linear with mipmaps)
        -:  391:    RL_TEXTURE_FILTER_ANISOTROPIC_4X,          // Anisotropic filtering 4x
        -:  392:    RL_TEXTURE_FILTER_ANISOTROPIC_8X,          // Anisotropic filtering 8x
        -:  393:    RL_TEXTURE_FILTER_ANISOTROPIC_16X,         // Anisotropic filtering 16x
        -:  394:} rlTextureFilter;
        -:  395:
        -:  396:// Color blending modes (pre-defined)
        -:  397:typedef enum {
        -:  398:    RL_BLEND_ALPHA = 0,                // Blend textures considering alpha (default)
        -:  399:    RL_BLEND_ADDITIVE,                 // Blend textures adding colors
        -:  400:    RL_BLEND_MULTIPLIED,               // Blend textures multiplying colors
        -:  401:    RL_BLEND_ADD_COLORS,               // Blend textures adding colors (alternative)
        -:  402:    RL_BLEND_SUBTRACT_COLORS,          // Blend textures subtracting colors (alternative)
        -:  403:    RL_BLEND_CUSTOM                    // Belnd textures using custom src/dst factors (use SetBlendModeCustom())
        -:  404:} rlBlendMode;
        -:  405:
        -:  406:// Shader location point type
        -:  407:typedef enum {
        -:  408:    RL_SHADER_LOC_VERTEX_POSITION = 0, // Shader location: vertex attribute: position
        -:  409:    RL_SHADER_LOC_VERTEX_TEXCOORD01,   // Shader location: vertex attribute: texcoord01
        -:  410:    RL_SHADER_LOC_VERTEX_TEXCOORD02,   // Shader location: vertex attribute: texcoord02
        -:  411:    RL_SHADER_LOC_VERTEX_NORMAL,       // Shader location: vertex attribute: normal
        -:  412:    RL_SHADER_LOC_VERTEX_TANGENT,      // Shader location: vertex attribute: tangent
        -:  413:    RL_SHADER_LOC_VERTEX_COLOR,        // Shader location: vertex attribute: color
        -:  414:    RL_SHADER_LOC_MATRIX_MVP,          // Shader location: matrix uniform: model-view-projection
        -:  415:    RL_SHADER_LOC_MATRIX_VIEW,         // Shader location: matrix uniform: view (camera transform)
        -:  416:    RL_SHADER_LOC_MATRIX_PROJECTION,   // Shader location: matrix uniform: projection
        -:  417:    RL_SHADER_LOC_MATRIX_MODEL,        // Shader location: matrix uniform: model (transform)
        -:  418:    RL_SHADER_LOC_MATRIX_NORMAL,       // Shader location: matrix uniform: normal
        -:  419:    RL_SHADER_LOC_VECTOR_VIEW,         // Shader location: vector uniform: view
        -:  420:    RL_SHADER_LOC_COLOR_DIFFUSE,       // Shader location: vector uniform: diffuse color
        -:  421:    RL_SHADER_LOC_COLOR_SPECULAR,      // Shader location: vector uniform: specular color
        -:  422:    RL_SHADER_LOC_COLOR_AMBIENT,       // Shader location: vector uniform: ambient color
        -:  423:    RL_SHADER_LOC_MAP_ALBEDO,          // Shader location: sampler2d texture: albedo (same as: RL_SHADER_LOC_MAP_DIFFUSE)
        -:  424:    RL_SHADER_LOC_MAP_METALNESS,       // Shader location: sampler2d texture: metalness (same as: RL_SHADER_LOC_MAP_SPECULAR)
        -:  425:    RL_SHADER_LOC_MAP_NORMAL,          // Shader location: sampler2d texture: normal
        -:  426:    RL_SHADER_LOC_MAP_ROUGHNESS,       // Shader location: sampler2d texture: roughness
        -:  427:    RL_SHADER_LOC_MAP_OCCLUSION,       // Shader location: sampler2d texture: occlusion
        -:  428:    RL_SHADER_LOC_MAP_EMISSION,        // Shader location: sampler2d texture: emission
        -:  429:    RL_SHADER_LOC_MAP_HEIGHT,          // Shader location: sampler2d texture: height
        -:  430:    RL_SHADER_LOC_MAP_CUBEMAP,         // Shader location: samplerCube texture: cubemap
        -:  431:    RL_SHADER_LOC_MAP_IRRADIANCE,      // Shader location: samplerCube texture: irradiance
        -:  432:    RL_SHADER_LOC_MAP_PREFILTER,       // Shader location: samplerCube texture: prefilter
        -:  433:    RL_SHADER_LOC_MAP_BRDF             // Shader location: sampler2d texture: brdf
        -:  434:} rlShaderLocationIndex;
        -:  435:
        -:  436:#define RL_SHADER_LOC_MAP_DIFFUSE      RL_SHADER_LOC_MAP_ALBEDO
        -:  437:#define RL_SHADER_LOC_MAP_SPECULAR     RL_SHADER_LOC_MAP_METALNESS
        -:  438:
        -:  439:// Shader uniform data type
        -:  440:typedef enum {
        -:  441:    RL_SHADER_UNIFORM_FLOAT = 0,       // Shader uniform type: float
        -:  442:    RL_SHADER_UNIFORM_VEC2,            // Shader uniform type: vec2 (2 float)
        -:  443:    RL_SHADER_UNIFORM_VEC3,            // Shader uniform type: vec3 (3 float)
        -:  444:    RL_SHADER_UNIFORM_VEC4,            // Shader uniform type: vec4 (4 float)
        -:  445:    RL_SHADER_UNIFORM_INT,             // Shader uniform type: int
        -:  446:    RL_SHADER_UNIFORM_IVEC2,           // Shader uniform type: ivec2 (2 int)
        -:  447:    RL_SHADER_UNIFORM_IVEC3,           // Shader uniform type: ivec3 (3 int)
        -:  448:    RL_SHADER_UNIFORM_IVEC4,           // Shader uniform type: ivec4 (4 int)
        -:  449:    RL_SHADER_UNIFORM_SAMPLER2D        // Shader uniform type: sampler2d
        -:  450:} rlShaderUniformDataType;
        -:  451:
        -:  452:// Shader attribute data types
        -:  453:typedef enum {
        -:  454:    RL_SHADER_ATTRIB_FLOAT = 0,        // Shader attribute type: float
        -:  455:    RL_SHADER_ATTRIB_VEC2,             // Shader attribute type: vec2 (2 float)
        -:  456:    RL_SHADER_ATTRIB_VEC3,             // Shader attribute type: vec3 (3 float)
        -:  457:    RL_SHADER_ATTRIB_VEC4              // Shader attribute type: vec4 (4 float)
        -:  458:} rlShaderAttributeDataType;
        -:  459:
        -:  460://------------------------------------------------------------------------------------
        -:  461:// Functions Declaration - Matrix operations
        -:  462://------------------------------------------------------------------------------------
        -:  463:
        -:  464:#if defined(__cplusplus)
        -:  465:extern "C" {            // Prevents name mangling of functions
        -:  466:#endif
        -:  467:
        -:  468:RLAPI void rlMatrixMode(int mode);                    // Choose the current matrix to be transformed
        -:  469:RLAPI void rlPushMatrix(void);                        // Push the current matrix to stack
        -:  470:RLAPI void rlPopMatrix(void);                         // Pop lattest inserted matrix from stack
        -:  471:RLAPI void rlLoadIdentity(void);                      // Reset current matrix to identity matrix
        -:  472:RLAPI void rlTranslatef(float x, float y, float z);   // Multiply the current matrix by a translation matrix
        -:  473:RLAPI void rlRotatef(float angle, float x, float y, float z);  // Multiply the current matrix by a rotation matrix
        -:  474:RLAPI void rlScalef(float x, float y, float z);       // Multiply the current matrix by a scaling matrix
        -:  475:RLAPI void rlMultMatrixf(float *matf);                // Multiply the current matrix by another matrix
        -:  476:RLAPI void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar);
        -:  477:RLAPI void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar);
        -:  478:RLAPI void rlViewport(int x, int y, int width, int height); // Set the viewport area
        -:  479:
        -:  480://------------------------------------------------------------------------------------
        -:  481:// Functions Declaration - Vertex level operations
        -:  482://------------------------------------------------------------------------------------
        -:  483:RLAPI void rlBegin(int mode);                         // Initialize drawing mode (how to organize vertex)
        -:  484:RLAPI void rlEnd(void);                               // Finish vertex providing
        -:  485:RLAPI void rlVertex2i(int x, int y);                  // Define one vertex (position) - 2 int
        -:  486:RLAPI void rlVertex2f(float x, float y);              // Define one vertex (position) - 2 float
        -:  487:RLAPI void rlVertex3f(float x, float y, float z);     // Define one vertex (position) - 3 float
        -:  488:RLAPI void rlTexCoord2f(float x, float y);            // Define one vertex (texture coordinate) - 2 float
        -:  489:RLAPI void rlNormal3f(float x, float y, float z);     // Define one vertex (normal) - 3 float
        -:  490:RLAPI void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a);  // Define one vertex (color) - 4 byte
        -:  491:RLAPI void rlColor3f(float x, float y, float z);          // Define one vertex (color) - 3 float
        -:  492:RLAPI void rlColor4f(float x, float y, float z, float w); // Define one vertex (color) - 4 float
        -:  493:
        -:  494://------------------------------------------------------------------------------------
        -:  495:// Functions Declaration - OpenGL style functions (common to 1.1, 3.3+, ES2)
        -:  496:// NOTE: This functions are used to completely abstract raylib code from OpenGL layer,
        -:  497:// some of them are direct wrappers over OpenGL calls, some others are custom
        -:  498://------------------------------------------------------------------------------------
        -:  499:
        -:  500:// Vertex buffers state
        -:  501:RLAPI bool rlEnableVertexArray(unsigned int vaoId);     // Enable vertex array (VAO, if supported)
        -:  502:RLAPI void rlDisableVertexArray(void);                  // Disable vertex array (VAO, if supported)
        -:  503:RLAPI void rlEnableVertexBuffer(unsigned int id);       // Enable vertex buffer (VBO)
        -:  504:RLAPI void rlDisableVertexBuffer(void);                 // Disable vertex buffer (VBO)
        -:  505:RLAPI void rlEnableVertexBufferElement(unsigned int id);// Enable vertex buffer element (VBO element)
        -:  506:RLAPI void rlDisableVertexBufferElement(void);          // Disable vertex buffer element (VBO element)
        -:  507:RLAPI void rlEnableVertexAttribute(unsigned int index); // Enable vertex attribute index
        -:  508:RLAPI void rlDisableVertexAttribute(unsigned int index);// Disable vertex attribute index
        -:  509:#if defined(GRAPHICS_API_OPENGL_11)
        -:  510:RLAPI void rlEnableStatePointer(int vertexAttribType, void *buffer);    // Enable attribute state pointer
        -:  511:RLAPI void rlDisableStatePointer(int vertexAttribType);                 // Disable attribute state pointer
        -:  512:#endif
        -:  513:
        -:  514:// Textures state
        -:  515:RLAPI void rlActiveTextureSlot(int slot);               // Select and active a texture slot
        -:  516:RLAPI void rlEnableTexture(unsigned int id);            // Enable texture
        -:  517:RLAPI void rlDisableTexture(void);                      // Disable texture
        -:  518:RLAPI void rlEnableTextureCubemap(unsigned int id);     // Enable texture cubemap
        -:  519:RLAPI void rlDisableTextureCubemap(void);               // Disable texture cubemap
        -:  520:RLAPI void rlTextureParameters(unsigned int id, int param, int value); // Set texture parameters (filter, wrap)
        -:  521:
        -:  522:// Shader state
        -:  523:RLAPI void rlEnableShader(unsigned int id);             // Enable shader program
        -:  524:RLAPI void rlDisableShader(void);                       // Disable shader program
        -:  525:
        -:  526:// Framebuffer state
        -:  527:RLAPI void rlEnableFramebuffer(unsigned int id);        // Enable render texture (fbo)
        -:  528:RLAPI void rlDisableFramebuffer(void);                  // Disable render texture (fbo), return to default framebuffer
        -:  529:RLAPI void rlActiveDrawBuffers(int count);              // Activate multiple draw color buffers
        -:  530:
        -:  531:// General render state
        -:  532:RLAPI void rlEnableColorBlend(void);                     // Enable color blending
        -:  533:RLAPI void rlDisableColorBlend(void);                   // Disable color blending
        -:  534:RLAPI void rlEnableDepthTest(void);                     // Enable depth test
        -:  535:RLAPI void rlDisableDepthTest(void);                    // Disable depth test
        -:  536:RLAPI void rlEnableDepthMask(void);                     // Enable depth write
        -:  537:RLAPI void rlDisableDepthMask(void);                    // Disable depth write
        -:  538:RLAPI void rlEnableBackfaceCulling(void);               // Enable backface culling
        -:  539:RLAPI void rlDisableBackfaceCulling(void);              // Disable backface culling
        -:  540:RLAPI void rlEnableScissorTest(void);                   // Enable scissor test
        -:  541:RLAPI void rlDisableScissorTest(void);                  // Disable scissor test
        -:  542:RLAPI void rlScissor(int x, int y, int width, int height); // Scissor test
        -:  543:RLAPI void rlEnableWireMode(void);                      // Enable wire mode
        -:  544:RLAPI void rlDisableWireMode(void);                     // Disable wire mode
        -:  545:RLAPI void rlSetLineWidth(float width);                 // Set the line drawing width
        -:  546:RLAPI float rlGetLineWidth(void);                       // Get the line drawing width
        -:  547:RLAPI void rlEnableSmoothLines(void);                   // Enable line aliasing
        -:  548:RLAPI void rlDisableSmoothLines(void);                  // Disable line aliasing
        -:  549:RLAPI void rlEnableStereoRender(void);                  // Enable stereo rendering
        -:  550:RLAPI void rlDisableStereoRender(void);                 // Disable stereo rendering
        -:  551:RLAPI bool rlIsStereoRenderEnabled(void);               // Check if stereo render is enabled
        -:  552:
        -:  553:RLAPI void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a); // Clear color buffer with color
        -:  554:RLAPI void rlClearScreenBuffers(void);                  // Clear used screen buffers (color and depth)
        -:  555:RLAPI void rlCheckErrors(void);                         // Check and log OpenGL error codes
        -:  556:RLAPI void rlSetBlendMode(int mode);                    // Set blending mode
        -:  557:RLAPI void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation); // Set blending mode factor and equation (using OpenGL factors)
        -:  558:
        -:  559://------------------------------------------------------------------------------------
        -:  560:// Functions Declaration - rlgl functionality
        -:  561://------------------------------------------------------------------------------------
        -:  562:// rlgl initialization functions
        -:  563:RLAPI void rlglInit(int width, int height);           // Initialize rlgl (buffers, shaders, textures, states)
        -:  564:RLAPI void rlglClose(void);                           // De-inititialize rlgl (buffers, shaders, textures)
        -:  565:RLAPI void rlLoadExtensions(void *loader);            // Load OpenGL extensions (loader function required)
        -:  566:RLAPI int rlGetVersion(void);                         // Get current OpenGL version
        -:  567:RLAPI int rlGetFramebufferWidth(void);                // Get default framebuffer width
        -:  568:RLAPI int rlGetFramebufferHeight(void);               // Get default framebuffer height
        -:  569:
        -:  570:RLAPI unsigned int rlGetTextureIdDefault(void);       // Get default texture id
        -:  571:RLAPI unsigned int rlGetShaderIdDefault(void);        // Get default shader id
        -:  572:RLAPI int *rlGetShaderLocsDefault(void);              // Get default shader locations
        -:  573:
        -:  574:// Render batch management
        -:  575:// NOTE: rlgl provides a default render batch to behave like OpenGL 1.1 immediate mode
        -:  576:// but this render batch API is exposed in case of custom batches are required
        -:  577:RLAPI rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements);  // Load a render batch system
        -:  578:RLAPI void rlUnloadRenderBatch(rlRenderBatch batch);                        // Unload render batch system
        -:  579:RLAPI void rlDrawRenderBatch(rlRenderBatch *batch);                         // Draw render batch data (Update->Draw->Reset)
        -:  580:RLAPI void rlSetRenderBatchActive(rlRenderBatch *batch);                    // Set the active render batch for rlgl (NULL for default internal)
        -:  581:RLAPI void rlDrawRenderBatchActive(void);                                   // Update and draw internal render batch
        -:  582:RLAPI bool rlCheckRenderBatchLimit(int vCount);                             // Check internal buffer overflow for a given number of vertex
        -:  583:RLAPI void rlSetTexture(unsigned int id);           // Set current texture for render batch and check buffers limits
        -:  584:
        -:  585://------------------------------------------------------------------------------------------------------------------------
        -:  586:
        -:  587:// Vertex buffers management
        -:  588:RLAPI unsigned int rlLoadVertexArray(void);                               // Load vertex array (vao) if supported
        -:  589:RLAPI unsigned int rlLoadVertexBuffer(void *buffer, int size, bool dynamic);            // Load a vertex buffer attribute
        -:  590:RLAPI unsigned int rlLoadVertexBufferElement(void *buffer, int size, bool dynamic);     // Load a new attributes element buffer
        -:  591:RLAPI void rlUpdateVertexBuffer(unsigned int bufferId, void *data, int dataSize, int offset);    // Update GPU buffer with new data
        -:  592:RLAPI void rlUnloadVertexArray(unsigned int vaoId);
        -:  593:RLAPI void rlUnloadVertexBuffer(unsigned int vboId);
        -:  594:RLAPI void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, void *pointer);
        -:  595:RLAPI void rlSetVertexAttributeDivisor(unsigned int index, int divisor);
        -:  596:RLAPI void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count); // Set vertex attribute default value
        -:  597:RLAPI void rlDrawVertexArray(int offset, int count);
        -:  598:RLAPI void rlDrawVertexArrayElements(int offset, int count, void *buffer);
        -:  599:RLAPI void rlDrawVertexArrayInstanced(int offset, int count, int instances);
        -:  600:RLAPI void rlDrawVertexArrayElementsInstanced(int offset, int count, void *buffer, int instances);
        -:  601:
        -:  602:// Textures management
        -:  603:RLAPI unsigned int rlLoadTexture(void *data, int width, int height, int format, int mipmapCount); // Load texture in GPU
        -:  604:RLAPI unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer);               // Load depth texture/renderbuffer (to be attached to fbo)
        -:  605:RLAPI unsigned int rlLoadTextureCubemap(void *data, int size, int format);                        // Load texture cubemap
        -:  606:RLAPI void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data);  // Update GPU texture with new data
        -:  607:RLAPI void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType);  // Get OpenGL internal formats
        -:  608:RLAPI const char *rlGetPixelFormatName(unsigned int format);              // Get name string for pixel format
        -:  609:RLAPI void rlUnloadTexture(unsigned int id);                              // Unload texture from GPU memory
        -:  610:RLAPI void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps); // Generate mipmap data for selected texture
        -:  611:RLAPI void *rlReadTexturePixels(unsigned int id, int width, int height, int format);              // Read texture pixel data
        -:  612:RLAPI unsigned char *rlReadScreenPixels(int width, int height);           // Read screen pixel data (color buffer)
        -:  613:
        -:  614:// Framebuffer management (fbo)
        -:  615:RLAPI unsigned int rlLoadFramebuffer(int width, int height);              // Load an empty framebuffer
        -:  616:RLAPI void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel);  // Attach texture/renderbuffer to a framebuffer
        -:  617:RLAPI bool rlFramebufferComplete(unsigned int id);                        // Verify framebuffer is complete
        -:  618:RLAPI void rlUnloadFramebuffer(unsigned int id);                          // Delete framebuffer from GPU
        -:  619:
        -:  620:// Shaders management
        -:  621:RLAPI unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode);    // Load shader from code strings
        -:  622:RLAPI unsigned int rlCompileShader(const char *shaderCode, int type);           // Compile custom shader and return shader id (type: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER)
        -:  623:RLAPI unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId); // Load custom shader program
        -:  624:RLAPI void rlUnloadShaderProgram(unsigned int id);                              // Unload shader program
        -:  625:RLAPI int rlGetLocationUniform(unsigned int shaderId, const char *uniformName); // Get shader location uniform
        -:  626:RLAPI int rlGetLocationAttrib(unsigned int shaderId, const char *attribName);   // Get shader location attribute
        -:  627:RLAPI void rlSetUniform(int locIndex, const void *value, int uniformType, int count); // Set shader value uniform
        -:  628:RLAPI void rlSetUniformMatrix(int locIndex, Matrix mat);                      // Set shader value matrix
        -:  629:RLAPI void rlSetUniformSampler(int locIndex, unsigned int textureId);           // Set shader value sampler
        -:  630:RLAPI void rlSetShader(unsigned int id, int *locs);                             // Set shader currently active (id and locations)
        -:  631:
        -:  632:// Matrix state management
        -:  633:RLAPI Matrix rlGetMatrixModelview(void);                                  // Get internal modelview matrix
        -:  634:RLAPI Matrix rlGetMatrixProjection(void);                                 // Get internal projection matrix
        -:  635:RLAPI Matrix rlGetMatrixTransform(void);                                  // Get internal accumulated transform matrix
        -:  636:RLAPI Matrix rlGetMatrixProjectionStereo(int eye);                        // Get internal projection matrix for stereo render (selected eye)
        -:  637:RLAPI Matrix rlGetMatrixViewOffsetStereo(int eye);                        // Get internal view offset matrix for stereo render (selected eye)
        -:  638:RLAPI void rlSetMatrixProjection(Matrix proj);                            // Set a custom projection matrix (replaces internal projection matrix)
        -:  639:RLAPI void rlSetMatrixModelview(Matrix view);                             // Set a custom modelview matrix (replaces internal modelview matrix)
        -:  640:RLAPI void rlSetMatrixProjectionStereo(Matrix right, Matrix left);      // Set eyes projection matrices for stereo rendering
        -:  641:RLAPI void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left);      // Set eyes view offsets matrices for stereo rendering
        -:  642:
        -:  643:// Quick and dirty cube/quad buffers load->draw->unload
        -:  644:RLAPI void rlLoadDrawCube(void);     // Load and draw a cube
        -:  645:RLAPI void rlLoadDrawQuad(void);     // Load and draw a quad
        -:  646:
        -:  647:#if defined(__cplusplus)
        -:  648:}
        -:  649:#endif
        -:  650:
        -:  651:#endif // RLGL_H
        -:  652:
        -:  653:/***********************************************************************************
        -:  654:*
        -:  655:*   RLGL IMPLEMENTATION
        -:  656:*
        -:  657:************************************************************************************/
        -:  658:
        -:  659:#if defined(RLGL_IMPLEMENTATION)
        -:  660:
        -:  661:#if defined(GRAPHICS_API_OPENGL_11)
        -:  662:    #if defined(__APPLE__)
        -:  663:        #include <OpenGL/gl.h>          // OpenGL 1.1 library for OSX
        -:  664:        #include <OpenGL/glext.h>       // OpenGL extensions library
        -:  665:    #else
        -:  666:        // APIENTRY for OpenGL function pointer declarations is required
        -:  667:        #ifndef APIENTRY
        -:  668:            #if defined(_WIN32)
        -:  669:                #define APIENTRY __stdcall
        -:  670:            #else
        -:  671:                #define APIENTRY
        -:  672:            #endif
        -:  673:        #endif
        -:  674:        // WINGDIAPI definition. Some Windows OpenGL headers need it
        -:  675:        #if !defined(WINGDIAPI) && defined(_WIN32)
        -:  676:            #define WINGDIAPI __declspec(dllimport)
        -:  677:        #endif
        -:  678:
        -:  679:        #include <GL/gl.h>              // OpenGL 1.1 library
        -:  680:    #endif
        -:  681:#endif
        -:  682:
        -:  683:#if defined(GRAPHICS_API_OPENGL_33)
        -:  684:    #if defined(__APPLE__)
        -:  685:        #include <OpenGL/gl3.h>         // OpenGL 3 library for OSX
        -:  686:        #include <OpenGL/gl3ext.h>      // OpenGL 3 extensions library for OSX
        -:  687:    #else
        -:  688:        #define GLAD_REALLOC RL_REALLOC
        -:  689:        #define GLAD_FREE RL_FREE
        -:  690:
        -:  691:        #define GLAD_IMPLEMENTATION
        -:  692:        #include "external/glad.h"      // GLAD extensions loading library, includes OpenGL headers
        -:  693:    #endif
        -:  694:#endif
        -:  695:
        -:  696:#if defined(GRAPHICS_API_OPENGL_ES2)
        -:  697:    #define GL_GLEXT_PROTOTYPES
        -:  698:    //#include <EGL/egl.h>              // EGL library -> not required, platform layer
        -:  699:    #include <GLES2/gl2.h>              // OpenGL ES 2.0 library
        -:  700:    #include <GLES2/gl2ext.h>           // OpenGL ES 2.0 extensions library
        -:  701:
        -:  702:    // It seems OpenGL ES 2.0 instancing entry points are not defined on Raspberry Pi
        -:  703:    // provided headers (despite being defined in official Khronos GLES2 headers)
        -:  704:    #if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)
        -:  705:    typedef void (GL_APIENTRYP PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
        -:  706:    typedef void (GL_APIENTRYP PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
        -:  707:    typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBDIVISOREXTPROC) (GLuint index, GLuint divisor);
        -:  708:    #endif
        -:  709:#endif
        -:  710:
        -:  711:#include <stdlib.h>                     // Required for: malloc(), free()
        -:  712:#include <string.h>                     // Required for: strcmp(), strlen() [Used in rlglInit(), on extensions loading]
        -:  713:#include <math.h>                       // Required for: sqrtf(), sinf(), cosf(), floor(), log()
        -:  714:
        -:  715://----------------------------------------------------------------------------------
        -:  716:// Defines and Macros
        -:  717://----------------------------------------------------------------------------------
        -:  718:#ifndef PI
        -:  719:    #define PI 3.14159265358979323846f
        -:  720:#endif
        -:  721:#ifndef DEG2RAD
        -:  722:    #define DEG2RAD (PI/180.0f)
        -:  723:#endif
        -:  724:#ifndef RAD2DEG
        -:  725:    #define RAD2DEG (180.0f/PI)
        -:  726:#endif
        -:  727:
        -:  728:#ifndef GL_SHADING_LANGUAGE_VERSION
        -:  729:    #define GL_SHADING_LANGUAGE_VERSION         0x8B8C
        -:  730:#endif
        -:  731:
        -:  732:#ifndef GL_COMPRESSED_RGB_S3TC_DXT1_EXT
        -:  733:    #define GL_COMPRESSED_RGB_S3TC_DXT1_EXT     0x83F0
        -:  734:#endif
        -:  735:#ifndef GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
        -:  736:    #define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT    0x83F1
        -:  737:#endif
        -:  738:#ifndef GL_COMPRESSED_RGBA_S3TC_DXT3_EXT
        -:  739:    #define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT    0x83F2
        -:  740:#endif
        -:  741:#ifndef GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
        -:  742:    #define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT    0x83F3
        -:  743:#endif
        -:  744:#ifndef GL_ETC1_RGB8_OES
        -:  745:    #define GL_ETC1_RGB8_OES                    0x8D64
        -:  746:#endif
        -:  747:#ifndef GL_COMPRESSED_RGB8_ETC2
        -:  748:    #define GL_COMPRESSED_RGB8_ETC2             0x9274
        -:  749:#endif
        -:  750:#ifndef GL_COMPRESSED_RGBA8_ETC2_EAC
        -:  751:    #define GL_COMPRESSED_RGBA8_ETC2_EAC        0x9278
        -:  752:#endif
        -:  753:#ifndef GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        -:  754:    #define GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG  0x8C00
        -:  755:#endif
        -:  756:#ifndef GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        -:  757:    #define GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG 0x8C02
        -:  758:#endif
        -:  759:#ifndef GL_COMPRESSED_RGBA_ASTC_4x4_KHR
        -:  760:    #define GL_COMPRESSED_RGBA_ASTC_4x4_KHR     0x93b0
        -:  761:#endif
        -:  762:#ifndef GL_COMPRESSED_RGBA_ASTC_8x8_KHR
        -:  763:    #define GL_COMPRESSED_RGBA_ASTC_8x8_KHR     0x93b7
        -:  764:#endif
        -:  765:
        -:  766:#ifndef GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
        -:  767:    #define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT   0x84FF
        -:  768:#endif
        -:  769:#ifndef GL_TEXTURE_MAX_ANISOTROPY_EXT
        -:  770:    #define GL_TEXTURE_MAX_ANISOTROPY_EXT       0x84FE
        -:  771:#endif
        -:  772:
        -:  773:#if defined(GRAPHICS_API_OPENGL_11)
        -:  774:    #define GL_UNSIGNED_SHORT_5_6_5             0x8363
        -:  775:    #define GL_UNSIGNED_SHORT_5_5_5_1           0x8034
        -:  776:    #define GL_UNSIGNED_SHORT_4_4_4_4           0x8033
        -:  777:#endif
        -:  778:
        -:  779:#if defined(GRAPHICS_API_OPENGL_21)
        -:  780:    #define GL_LUMINANCE                        0x1909
        -:  781:    #define GL_LUMINANCE_ALPHA                  0x190A
        -:  782:#endif
        -:  783:
        -:  784:#if defined(GRAPHICS_API_OPENGL_ES2)
        -:  785:    #define glClearDepth                 glClearDepthf
        -:  786:    #define GL_READ_FRAMEBUFFER         GL_FRAMEBUFFER
        -:  787:    #define GL_DRAW_FRAMEBUFFER         GL_FRAMEBUFFER
        -:  788:#endif
        -:  789:
        -:  790:// Default shader vertex attribute names to set location points
        -:  791:#ifndef RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION
        -:  792:    #define RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION     "vertexPosition"    // Binded by default to shader location: 0
        -:  793:#endif
        -:  794:#ifndef RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD
        -:  795:    #define RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD     "vertexTexCoord"    // Binded by default to shader location: 1
        -:  796:#endif
        -:  797:#ifndef RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL
        -:  798:    #define RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL       "vertexNormal"      // Binded by default to shader location: 2
        -:  799:#endif
        -:  800:#ifndef RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR
        -:  801:    #define RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR        "vertexColor"       // Binded by default to shader location: 3
        -:  802:#endif
        -:  803:#ifndef RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT
        -:  804:    #define RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT      "vertexTangent"     // Binded by default to shader location: 4
        -:  805:#endif
        -:  806:#ifndef RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2
        -:  807:    #define RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2    "vertexTexCoord2"   // Binded by default to shader location: 5
        -:  808:#endif
        -:  809:
        -:  810:#ifndef RL_DEFAULT_SHADER_UNIFORM_NAME_MVP
        -:  811:    #define RL_DEFAULT_SHADER_UNIFORM_NAME_MVP         "mvp"               // model-view-projection matrix
        -:  812:#endif
        -:  813:#ifndef RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW
        -:  814:    #define RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW        "matView"           // view matrix
        -:  815:#endif
        -:  816:#ifndef RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION
        -:  817:    #define RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION  "matProjection"     // projection matrix
        -:  818:#endif
        -:  819:#ifndef RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL
        -:  820:    #define RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL       "matModel"          // model matrix
        -:  821:#endif
        -:  822:#ifndef RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL
        -:  823:    #define RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL      "matNormal"         // normal matrix (transpose(inverse(matModelView))
        -:  824:#endif
        -:  825:#ifndef RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR
        -:  826:    #define RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR       "colDiffuse"        // color diffuse (base tint color, multiplied by texture color)
        -:  827:#endif
        -:  828:#ifndef RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0
        -:  829:    #define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0  "texture0"          // texture0 (texture slot active 0)
        -:  830:#endif
        -:  831:#ifndef RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1
        -:  832:    #define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1  "texture1"          // texture1 (texture slot active 1)
        -:  833:#endif
        -:  834:#ifndef RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2
        -:  835:    #define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2  "texture2"          // texture2 (texture slot active 2)
        -:  836:#endif
        -:  837:
        -:  838://----------------------------------------------------------------------------------
        -:  839:// Types and Structures Definition
        -:  840://----------------------------------------------------------------------------------
        -:  841:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -:  842:typedef struct rlglData {
        -:  843:    rlRenderBatch *currentBatch;            // Current render batch
        -:  844:    rlRenderBatch defaultBatch;             // Default internal render batch
        -:  845:
        -:  846:    struct {
        -:  847:        int currentMatrixMode;              // Current matrix mode
        -:  848:        Matrix *currentMatrix;            // Current matrix pointer
        -:  849:        Matrix modelview;                 // Default modelview matrix
        -:  850:        Matrix projection;                // Default projection matrix
        -:  851:        Matrix transform;                 // Transform matrix to be used with rlTranslate, rlRotate, rlScale
        -:  852:        bool transformRequired;             // Require transform matrix application to current draw-call vertex (if required)
        -:  853:        Matrix stack[RL_MAX_MATRIX_STACK_SIZE];// Matrix stack for push/pop
        -:  854:        int stackCounter;                   // Matrix stack counter
        -:  855:
        -:  856:        unsigned int defaultTextureId;      // Default texture used on shapes/poly drawing (required by shader)
        -:  857:        unsigned int activeTextureId[RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS];    // Active texture ids to be enabled on batch drawing (0 active by default)
        -:  858:        unsigned int defaultVShaderId;      // Default vertex shader id (used by default shader program)
        -:  859:        unsigned int defaultFShaderId;      // Default fragment shader id (used by default shader program)
        -:  860:        unsigned int defaultShaderId;       // Default shader program id, supports vertex color and diffuse texture
        -:  861:        int *defaultShaderLocs;             // Default shader locations pointer to be used on rendering
        -:  862:        unsigned int currentShaderId;       // Current shader id to be used on rendering (by default, defaultShaderId)
        -:  863:        int *currentShaderLocs;             // Current shader locations pointer to be used on rendering (by default, defaultShaderLocs)
        -:  864:
        -:  865:        bool stereoRender;                  // Stereo rendering flag
        -:  866:        Matrix projectionStereo[2];       // VR stereo rendering eyes projection matrices
        -:  867:        Matrix viewOffsetStereo[2];       // VR stereo rendering eyes view offset matrices
        -:  868:
        -:  869:        int currentBlendMode;               // Blending mode active
        -:  870:        int glBlendSrcFactor;               // Blending source factor
        -:  871:        int glBlendDstFactor;               // Blending destination factor
        -:  872:        int glBlendEquation;                // Blending equation
        -:  873:
        -:  874:        int framebufferWidth;               // Default framebuffer width
        -:  875:        int framebufferHeight;              // Default framebuffer height
        -:  876:
        -:  877:    } State;            // Renderer state
        -:  878:    struct {
        -:  879:        bool vao;                           // VAO support (OpenGL ES2 could not support VAO extension) (GL_ARB_vertex_array_object)
        -:  880:        bool instancing;                    // Instancing supported (GL_ANGLE_instanced_arrays, GL_EXT_draw_instanced + GL_EXT_instanced_arrays)
        -:  881:        bool texNPOT;                       // NPOT textures full support (GL_ARB_texture_non_power_of_two, GL_OES_texture_npot)
        -:  882:        bool texDepth;                      // Depth textures supported (GL_ARB_depth_texture, GL_WEBGL_depth_texture, GL_OES_depth_texture)
        -:  883:        bool texFloat32;                    // float textures support (32 bit per channel) (GL_OES_texture_float)
        -:  884:        bool texCompDXT;                    // DDS texture compression support (GL_EXT_texture_compression_s3tc, GL_WEBGL_compressed_texture_s3tc, GL_WEBKIT_WEBGL_compressed_texture_s3tc)
        -:  885:        bool texCompETC1;                   // ETC1 texture compression support (GL_OES_compressed_ETC1_RGB8_texture, GL_WEBGL_compressed_texture_etc1)
        -:  886:        bool texCompETC2;                   // ETC2/EAC texture compression support (GL_ARB_ES3_compatibility)
        -:  887:        bool texCompPVRT;                   // PVR texture compression support (GL_IMG_texture_compression_pvrtc)
        -:  888:        bool texCompASTC;                   // ASTC texture compression support (GL_KHR_texture_compression_astc_hdr, GL_KHR_texture_compression_astc_ldr)
        -:  889:        bool texMirrorClamp;                // Clamp mirror wrap mode supported (GL_EXT_texture_mirror_clamp)
        -:  890:        bool texAnisoFilter;                // Anisotropic texture filtering support (GL_EXT_texture_filter_anisotropic)
        -:  891:
        -:  892:        float maxAnisotropyLevel;           // Maximum anisotropy level supported (minimum is 2.0f)
        -:  893:        int maxDepthBits;                   // Maximum bits for depth component
        -:  894:
        -:  895:    } ExtSupported;     // Extensions supported flags
        -:  896:} rlglData;
        -:  897:
        -:  898:typedef void *(*rlglLoadProc)(const char *name);   // OpenGL extension functions loader signature (same as GLADloadproc)
        -:  899:
        -:  900:#endif  // GRAPHICS_API_OPENGL_33 || GRAPHICS_API_OPENGL_ES2
        -:  901:
        -:  902://----------------------------------------------------------------------------------
        -:  903:// Global Variables Definition
        -:  904://----------------------------------------------------------------------------------
        -:  905:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -:  906:static rlglData RLGL = { 0 };
        -:  907:#endif  // GRAPHICS_API_OPENGL_33 || GRAPHICS_API_OPENGL_ES2
        -:  908:
        -:  909:#if defined(GRAPHICS_API_OPENGL_ES2)
        -:  910:// NOTE: VAO functionality is exposed through extensions (OES)
        -:  911:static PFNGLGENVERTEXARRAYSOESPROC glGenVertexArrays = NULL;
        -:  912:static PFNGLBINDVERTEXARRAYOESPROC glBindVertexArray = NULL;
        -:  913:static PFNGLDELETEVERTEXARRAYSOESPROC glDeleteVertexArrays = NULL;
        -:  914:
        -:  915:// NOTE: Instancing functionality could also be available through extension
        -:  916:static PFNGLDRAWARRAYSINSTANCEDEXTPROC glDrawArraysInstanced = NULL;
        -:  917:static PFNGLDRAWELEMENTSINSTANCEDEXTPROC glDrawElementsInstanced = NULL;
        -:  918:static PFNGLVERTEXATTRIBDIVISOREXTPROC glVertexAttribDivisor = NULL;
        -:  919:#endif
        -:  920:
        -:  921://----------------------------------------------------------------------------------
        -:  922:// Module specific Functions Declaration
        -:  923://----------------------------------------------------------------------------------
        -:  924:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -:  925:static void rlLoadShaderDefault(void);      // Load default shader
        -:  926:static void rlUnloadShaderDefault(void);    // Unload default shader
        -:  927:#if defined(SUPPORT_GL_DETAILS_INFO)
        -:  928:static char *rlGetCompressedFormatName(int format); // Get compressed format official GL identifier name
        -:  929:#endif  // SUPPORT_GL_DETAILS_INFO
        -:  930:#endif  // GRAPHICS_API_OPENGL_33 || GRAPHICS_API_OPENGL_ES2
        -:  931:#if defined(GRAPHICS_API_OPENGL_11)
        -:  932:static int rlGenTextureMipmapsData(unsigned char *data, int baseWidth, int baseHeight);         // Generate mipmaps data on CPU side
        -:  933:static unsigned char *rlGenNextMipmapData(unsigned char *srcData, int srcWidth, int srcHeight); // Generate next mipmap level on CPU side
        -:  934:#endif
        -:  935:static int rlGetPixelDataSize(int width, int height, int format);   // Get pixel data size in bytes (image or texture)
        -:  936:// Auxiliar matrix math functions
        -:  937:static Matrix rlMatrixIdentity(void);                             // Get identity matrix
        -:  938:static Matrix rlMatrixMultiply(Matrix left, Matrix right);    // Multiply two matrices
        -:  939:
        -:  940://----------------------------------------------------------------------------------
        -:  941:// Module Functions Definition - Matrix operations
        -:  942://----------------------------------------------------------------------------------
        -:  943:
        -:  944:#if defined(GRAPHICS_API_OPENGL_11)
        -:  945:// Fallback to OpenGL 1.1 function calls
        -:  946://---------------------------------------
        -:  947:void rlMatrixMode(int mode)
        -:  948:{
        -:  949:    switch (mode)
        -:  950:    {
        -:  951:        case RL_PROJECTION: glMatrixMode(GL_PROJECTION); break;
        -:  952:        case RL_MODELVIEW: glMatrixMode(GL_MODELVIEW); break;
        -:  953:        case RL_TEXTURE: glMatrixMode(GL_TEXTURE); break;
        -:  954:        default: break;
        -:  955:    }
        -:  956:}
        -:  957:
        -:  958:void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
        -:  959:{
        -:  960:    glFrustum(left, right, bottom, top, znear, zfar);
        -:  961:}
        -:  962:
        -:  963:void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
        -:  964:{
        -:  965:    glOrtho(left, right, bottom, top, znear, zfar);
        -:  966:}
        -:  967:
        -:  968:void rlPushMatrix(void) { glPushMatrix(); }
        -:  969:void rlPopMatrix(void) { glPopMatrix(); }
        -:  970:void rlLoadIdentity(void) { glLoadIdentity(); }
        -:  971:void rlTranslatef(float x, float y, float z) { glTranslatef(x, y, z); }
        -:  972:void rlRotatef(float angle, float x, float y, float z) { glRotatef(angle, x, y, z); }
        -:  973:void rlScalef(float x, float y, float z) { glScalef(x, y, z); }
        -:  974:void rlMultMatrixf(float *matf) { glMultMatrixf(matf); }
        -:  975:#endif
        -:  976:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -:  977:// Choose the current matrix to be transformed
function rlMatrixMode called 2 returned 100% blocks executed 100%
        2:  978:void rlMatrixMode(int mode)
        -:  979:{
        2:  980:    if (mode == RL_PROJECTION) RLGL.State.currentMatrix = &RLGL.State.projection;
        2:  980-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  980-block  1
        1:  981:    else if (mode == RL_MODELVIEW) RLGL.State.currentMatrix = &RLGL.State.modelview;
        1:  981-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  981-block  1
        -:  982:    //else if (mode == RL_TEXTURE) // Not supported
        -:  983:
        2:  984:    RLGL.State.currentMatrixMode = mode;
        2:  985:}
        -:  986:
        -:  987:// Push the current matrix into RLGL.State.stack
function rlPushMatrix called 0 returned 0% blocks executed 0%
    #####:  988:void rlPushMatrix(void)
        -:  989:{
    #####:  990:    if (RLGL.State.stackCounter >= RL_MAX_MATRIX_STACK_SIZE) TRACELOG(RL_LOG_ERROR, "RLGL: Matrix stack overflow (RL_MAX_MATRIX_STACK_SIZE)");
    %%%%%:  990-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  990-block  1
call    2 never executed
        -:  991:
    #####:  992:    if (RLGL.State.currentMatrixMode == RL_MODELVIEW)
    %%%%%:  992-block  0
branch  0 never executed
branch  1 never executed
        -:  993:    {
    #####:  994:        RLGL.State.transformRequired = true;
    #####:  995:        RLGL.State.currentMatrix = &RLGL.State.transform;
    %%%%%:  995-block  0
        -:  996:    }
        -:  997:
    #####:  998:    RLGL.State.stack[RLGL.State.stackCounter] = *RLGL.State.currentMatrix;
    #####:  999:    RLGL.State.stackCounter++;
    #####: 1000:}
        -: 1001:
        -: 1002:// Pop lattest inserted matrix from RLGL.State.stack
function rlPopMatrix called 0 returned 0% blocks executed 0%
    #####: 1003:void rlPopMatrix(void)
        -: 1004:{
    #####: 1005:    if (RLGL.State.stackCounter > 0)
    %%%%%: 1005-block  0
branch  0 never executed
branch  1 never executed
        -: 1006:    {
    #####: 1007:        Matrix mat = RLGL.State.stack[RLGL.State.stackCounter - 1];
    #####: 1008:        *RLGL.State.currentMatrix = mat;
    #####: 1009:        RLGL.State.stackCounter--;
    %%%%%: 1009-block  0
        -: 1010:    }
        -: 1011:
    #####: 1012:    if ((RLGL.State.stackCounter == 0) && (RLGL.State.currentMatrixMode == RL_MODELVIEW))
    %%%%%: 1012-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1012-block  1
branch  2 never executed
branch  3 never executed
        -: 1013:    {
    #####: 1014:        RLGL.State.currentMatrix = &RLGL.State.modelview;
    #####: 1015:        RLGL.State.transformRequired = false;
    %%%%%: 1015-block  0
        -: 1016:    }
    #####: 1017:}
        -: 1018:
        -: 1019:// Reset current matrix to identity matrix
function rlLoadIdentity called 106 returned 100% blocks executed 100%
      106: 1020:void rlLoadIdentity(void)
        -: 1021:{
      106: 1022:    *RLGL.State.currentMatrix = rlMatrixIdentity();
      106: 1022-block  0
call    0 returned 106
      106: 1023:}
        -: 1024:
        -: 1025:// Multiply the current matrix by a translation matrix
function rlTranslatef called 0 returned 0% blocks executed 0%
    #####: 1026:void rlTranslatef(float x, float y, float z)
        -: 1027:{
    #####: 1028:    Matrix matTranslation = {
        -: 1029:        1.0f, 0.0f, 0.0f, x,
        -: 1030:        0.0f, 1.0f, 0.0f, y,
        -: 1031:        0.0f, 0.0f, 1.0f, z,
        -: 1032:        0.0f, 0.0f, 0.0f, 1.0f
        -: 1033:    };
        -: 1034:
        -: 1035:    // NOTE: We transpose matrix with multiplication order
    #####: 1036:    *RLGL.State.currentMatrix = rlMatrixMultiply(matTranslation, *RLGL.State.currentMatrix);
    %%%%%: 1036-block  0
call    0 never executed
    #####: 1037:}
        -: 1038:
        -: 1039:// Multiply the current matrix by a rotation matrix
        -: 1040:// NOTE: The provided angle must be in degrees
function rlRotatef called 0 returned 0% blocks executed 0%
    #####: 1041:void rlRotatef(float angle, float x, float y, float z)
        -: 1042:{
    #####: 1043:    Matrix matRotation = rlMatrixIdentity();
    %%%%%: 1043-block  0
call    0 never executed
        -: 1044:
        -: 1045:    // Axis vector (x, y, z) normalization
    #####: 1046:    float lengthSquared = x*x + y*y + z*z;
    #####: 1047:    if ((lengthSquared != 1.0f) && (lengthSquared != 0.0f))
branch  0 never executed
branch  1 never executed
    %%%%%: 1047-block  0
branch  2 never executed
branch  3 never executed
        -: 1048:    {
    #####: 1049:        float inverseLength = 1.0f/sqrtf(lengthSquared);
    #####: 1050:        x *= inverseLength;
    #####: 1051:        y *= inverseLength;
    #####: 1052:        z *= inverseLength;
    %%%%%: 1052-block  0
        -: 1053:    }
        -: 1054:
        -: 1055:    // Rotation matrix generation
    #####: 1056:    float sinres = sinf(DEG2RAD*angle);
    #####: 1057:    float cosres = cosf(DEG2RAD*angle);
    #####: 1058:    float t = 1.0f - cosres;
        -: 1059:
    #####: 1060:    matRotation.m0 = x*x*t + cosres;
    #####: 1061:    matRotation.m1 = y*x*t + z*sinres;
    #####: 1062:    matRotation.m2 = z*x*t - y*sinres;
    #####: 1063:    matRotation.m3 = 0.0f;
        -: 1064:
    #####: 1065:    matRotation.m4 = x*y*t - z*sinres;
    #####: 1066:    matRotation.m5 = y*y*t + cosres;
    #####: 1067:    matRotation.m6 = z*y*t + x*sinres;
    #####: 1068:    matRotation.m7 = 0.0f;
        -: 1069:
    #####: 1070:    matRotation.m8 = x*z*t + y*sinres;
    #####: 1071:    matRotation.m9 = y*z*t - x*sinres;
    #####: 1072:    matRotation.m10 = z*z*t + cosres;
    #####: 1073:    matRotation.m11 = 0.0f;
        -: 1074:
    #####: 1075:    matRotation.m12 = 0.0f;
    #####: 1076:    matRotation.m13 = 0.0f;
    #####: 1077:    matRotation.m14 = 0.0f;
    #####: 1078:    matRotation.m15 = 1.0f;
        -: 1079:
        -: 1080:    // NOTE: We transpose matrix with multiplication order
    #####: 1081:    *RLGL.State.currentMatrix = rlMatrixMultiply(matRotation, *RLGL.State.currentMatrix);
    %%%%%: 1081-block  0
call    0 never executed
    #####: 1082:}
        -: 1083:
        -: 1084:// Multiply the current matrix by a scaling matrix
function rlScalef called 0 returned 0% blocks executed 0%
    #####: 1085:void rlScalef(float x, float y, float z)
        -: 1086:{
    #####: 1087:    Matrix matScale = {
        -: 1088:        x, 0.0f, 0.0f, 0.0f,
        -: 1089:        0.0f, y, 0.0f, 0.0f,
        -: 1090:        0.0f, 0.0f, z, 0.0f,
        -: 1091:        0.0f, 0.0f, 0.0f, 1.0f
        -: 1092:    };
        -: 1093:
        -: 1094:    // NOTE: We transpose matrix with multiplication order
    #####: 1095:    *RLGL.State.currentMatrix = rlMatrixMultiply(matScale, *RLGL.State.currentMatrix);
    %%%%%: 1095-block  0
call    0 never executed
    #####: 1096:}
        -: 1097:
        -: 1098:// Multiply the current matrix by another matrix
function rlMultMatrixf called 104 returned 100% blocks executed 100%
      104: 1099:void rlMultMatrixf(float *matf)
        -: 1100:{
        -: 1101:    // Matrix creation from array
      104: 1102:    Matrix mat = { matf[0], matf[4], matf[8], matf[12],
        -: 1103:                   matf[1], matf[5], matf[9], matf[13],
        -: 1104:                   matf[2], matf[6], matf[10], matf[14],
        -: 1105:                   matf[3], matf[7], matf[11], matf[15] };
        -: 1106:
      104: 1107:    *RLGL.State.currentMatrix = rlMatrixMultiply(*RLGL.State.currentMatrix, mat);
      104: 1107-block  0
call    0 returned 104
      104: 1108:}
        -: 1109:
        -: 1110:// Multiply the current matrix by a perspective matrix generated by parameters
function rlFrustum called 0 returned 0% blocks executed 0%
    #####: 1111:void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
        -: 1112:{
    #####: 1113:    Matrix matFrustum = { 0 };
        -: 1114:
    #####: 1115:    float rl = (float)(right - left);
    #####: 1116:    float tb = (float)(top - bottom);
    #####: 1117:    float fn = (float)(zfar - znear);
        -: 1118:
    #####: 1119:    matFrustum.m0 = ((float) znear*2.0f)/rl;
    #####: 1120:    matFrustum.m1 = 0.0f;
    #####: 1121:    matFrustum.m2 = 0.0f;
    #####: 1122:    matFrustum.m3 = 0.0f;
        -: 1123:
    #####: 1124:    matFrustum.m4 = 0.0f;
    #####: 1125:    matFrustum.m5 = ((float) znear*2.0f)/tb;
    #####: 1126:    matFrustum.m6 = 0.0f;
    #####: 1127:    matFrustum.m7 = 0.0f;
        -: 1128:
    #####: 1129:    matFrustum.m8 = ((float)right + (float)left)/rl;
    #####: 1130:    matFrustum.m9 = ((float)top + (float)bottom)/tb;
    #####: 1131:    matFrustum.m10 = -((float)zfar + (float)znear)/fn;
    #####: 1132:    matFrustum.m11 = -1.0f;
        -: 1133:
    #####: 1134:    matFrustum.m12 = 0.0f;
    #####: 1135:    matFrustum.m13 = 0.0f;
    #####: 1136:    matFrustum.m14 = -((float)zfar*(float)znear*2.0f)/fn;
    #####: 1137:    matFrustum.m15 = 0.0f;
        -: 1138:
    #####: 1139:    *RLGL.State.currentMatrix = rlMatrixMultiply(*RLGL.State.currentMatrix, matFrustum);
    %%%%%: 1139-block  0
call    0 never executed
    #####: 1140:}
        -: 1141:
        -: 1142:// Multiply the current matrix by an orthographic matrix generated by parameters
function rlOrtho called 1 returned 100% blocks executed 100%
        1: 1143:void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
        -: 1144:{
        -: 1145:    // NOTE: If left-right and top-botton values are equal it could create a division by zero,
        -: 1146:    // response to it is platform/compiler dependant
        1: 1147:    Matrix matOrtho = { 0 };
        -: 1148:
        1: 1149:    float rl = (float)(right - left);
        1: 1150:    float tb = (float)(top - bottom);
        1: 1151:    float fn = (float)(zfar - znear);
        -: 1152:
        1: 1153:    matOrtho.m0 = 2.0f/rl;
        1: 1154:    matOrtho.m1 = 0.0f;
        1: 1155:    matOrtho.m2 = 0.0f;
        1: 1156:    matOrtho.m3 = 0.0f;
        1: 1157:    matOrtho.m4 = 0.0f;
        1: 1158:    matOrtho.m5 = 2.0f/tb;
        1: 1159:    matOrtho.m6 = 0.0f;
        1: 1160:    matOrtho.m7 = 0.0f;
        1: 1161:    matOrtho.m8 = 0.0f;
        1: 1162:    matOrtho.m9 = 0.0f;
        1: 1163:    matOrtho.m10 = -2.0f/fn;
        1: 1164:    matOrtho.m11 = 0.0f;
        1: 1165:    matOrtho.m12 = -((float)left + (float)right)/rl;
        1: 1166:    matOrtho.m13 = -((float)top + (float)bottom)/tb;
        1: 1167:    matOrtho.m14 = -((float)zfar + (float)znear)/fn;
        1: 1168:    matOrtho.m15 = 1.0f;
        -: 1169:
        1: 1170:    *RLGL.State.currentMatrix = rlMatrixMultiply(*RLGL.State.currentMatrix, matOrtho);
        1: 1170-block  0
call    0 returned 1
        1: 1171:}
        -: 1172:#endif
        -: 1173:
        -: 1174:// Set the viewport area (transformation from normalized device coordinates to window coordinates)
function rlViewport called 1 returned 100% blocks executed 100%
        1: 1175:void rlViewport(int x, int y, int width, int height)
        -: 1176:{
        1: 1177:    glViewport(x, y, width, height);
        1: 1177-block  0
call    0 returned 1
        1: 1178:}
        -: 1179:
        -: 1180://----------------------------------------------------------------------------------
        -: 1181:// Module Functions Definition - Vertex level operations
        -: 1182://----------------------------------------------------------------------------------
        -: 1183:#if defined(GRAPHICS_API_OPENGL_11)
        -: 1184:// Fallback to OpenGL 1.1 function calls
        -: 1185://---------------------------------------
        -: 1186:void rlBegin(int mode)
        -: 1187:{
        -: 1188:    switch (mode)
        -: 1189:    {
        -: 1190:        case RL_LINES: glBegin(GL_LINES); break;
        -: 1191:        case RL_TRIANGLES: glBegin(GL_TRIANGLES); break;
        -: 1192:        case RL_QUADS: glBegin(GL_QUADS); break;
        -: 1193:        default: break;
        -: 1194:    }
        -: 1195:}
        -: 1196:
        -: 1197:void rlEnd() { glEnd(); }
        -: 1198:void rlVertex2i(int x, int y) { glVertex2i(x, y); }
        -: 1199:void rlVertex2f(float x, float y) { glVertex2f(x, y); }
        -: 1200:void rlVertex3f(float x, float y, float z) { glVertex3f(x, y, z); }
        -: 1201:void rlTexCoord2f(float x, float y) { glTexCoord2f(x, y); }
        -: 1202:void rlNormal3f(float x, float y, float z) { glNormal3f(x, y, z); }
        -: 1203:void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a) { glColor4ub(r, g, b, a); }
        -: 1204:void rlColor3f(float x, float y, float z) { glColor3f(x, y, z); }
        -: 1205:void rlColor4f(float x, float y, float z, float w) { glColor4f(x, y, z, w); }
        -: 1206:#endif
        -: 1207:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 1208:// Initialize drawing mode (how to organize vertex)
function rlBegin called 728 returned 100% blocks executed 10%
      728: 1209:void rlBegin(int mode)
        -: 1210:{
        -: 1211:    // Draw mode can be RL_LINES, RL_TRIANGLES and RL_QUADS
        -: 1212:    // NOTE: In all three cases, vertex are accumulated over default internal vertex buffer
      728: 1213:    if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].mode != mode)
      728: 1213-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 728
        -: 1214:    {
    #####: 1215:        if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount > 0)
    %%%%%: 1215-block  0
branch  0 never executed
branch  1 never executed
        -: 1216:        {
        -: 1217:            // Make sure current RLGL.currentBatch->draws[i].vertexCount is aligned a multiple of 4,
        -: 1218:            // that way, following QUADS drawing will keep aligned with index processing
        -: 1219:            // It implies adding some extra alignment vertex at the end of the draw,
        -: 1220:            // those vertex are not processed but they are considered as an additional offset
        -: 1221:            // for the next set of vertex to be drawn
    #####: 1222:            if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].mode == RL_LINES) RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment = ((RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount < 4)? RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount : RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount%4);
    %%%%%: 1222-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1222-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1222-block  2
    %%%%%: 1222-block  3
    %%%%%: 1222-block  4
    #####: 1223:            else if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].mode == RL_TRIANGLES) RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment = ((RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount < 4)? 1 : (4 - (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount%4)));
    %%%%%: 1223-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1223-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1223-block  2
    %%%%%: 1223-block  3
    %%%%%: 1223-block  4
    #####: 1224:            else RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment = 0;
    %%%%%: 1224-block  0
        -: 1225:
    #####: 1226:            if (!rlCheckRenderBatchLimit(RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment))
    %%%%%: 1226-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1227:            {
    #####: 1228:                RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter += RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment;
    #####: 1229:                RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter += RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment;
    #####: 1230:                RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter += RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment;
        -: 1231:
    #####: 1232:                RLGL.currentBatch->drawCounter++;
    %%%%%: 1232-block  0
        -: 1233:            }
        -: 1234:        }
        -: 1235:
    #####: 1236:        if (RLGL.currentBatch->drawCounter >= RL_DEFAULT_BATCH_DRAWCALLS) rlDrawRenderBatch(RLGL.currentBatch);
    %%%%%: 1236-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1236-block  1
call    2 never executed
        -: 1237:
    #####: 1238:        RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].mode = mode;
    #####: 1239:        RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount = 0;
    #####: 1240:        RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].textureId = RLGL.State.defaultTextureId;
    %%%%%: 1240-block  0
        -: 1241:    }
      728: 1242:}
        -: 1243:
        -: 1244:// Finish vertex providing
function rlEnd called 728 returned 100% blocks executed 47%
      728: 1245:void rlEnd(void)
        -: 1246:{
        -: 1247:    // Make sure vertexCount is the same for vertices, texcoords, colors and normals
        -: 1248:    // NOTE: In OpenGL 1.1, one glColor call can be made for all the subsequent glVertex calls
        -: 1249:
        -: 1250:    // Make sure colors count match vertex count
      728: 1251:    if (RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter != RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter)
      728: 1251-block  0
branch  0 taken 728 (fallthrough)
branch  1 taken 0
        -: 1252:    {
      728: 1253:        int addColors = RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter - RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter;
        -: 1254:
     2912: 1255:        for (int i = 0; i < addColors; i++)
      728: 1255-block  0
     2912: 1255-block  1
branch  0 taken 2184
branch  1 taken 728 (fallthrough)
        -: 1256:        {
     2184: 1257:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter] = RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter - 4];
     2184: 1258:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter + 1] = RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter - 3];
     2184: 1259:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter + 2] = RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter - 2];
     2184: 1260:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter + 3] = RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter - 1];
     2184: 1261:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter++;
     2184: 1261-block  0
        -: 1262:        }
        -: 1263:    }
        -: 1264:
        -: 1265:    // Make sure texcoords count match vertex count
      728: 1266:    if (RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter != RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter)
      728: 1266-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 728
        -: 1267:    {
    #####: 1268:        int addTexCoords = RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter - RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter;
        -: 1269:
    #####: 1270:        for (int i = 0; i < addTexCoords; i++)
    %%%%%: 1270-block  0
    %%%%%: 1270-block  1
branch  0 never executed
branch  1 never executed
        -: 1271:        {
    #####: 1272:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].texcoords[2*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter] = 0.0f;
    #####: 1273:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].texcoords[2*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter + 1] = 0.0f;
    #####: 1274:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter++;
    %%%%%: 1274-block  0
        -: 1275:        }
        -: 1276:    }
        -: 1277:
        -: 1278:    // TODO: Make sure normals count match vertex count... if normals support is added in a future... :P
        -: 1279:
        -: 1280:    // NOTE: Depth increment is dependant on rlOrtho(): z-near and z-far values,
        -: 1281:    // as well as depth buffer bit-depth (16bit or 24bit or 32bit)
        -: 1282:    // Correct increment formula would be: depthInc = (zfar - znear)/pow(2, bits)
      728: 1283:    RLGL.currentBatch->currentDepth += (1.0f/20000.0f);
        -: 1284:
        -: 1285:    // Verify internal buffers limits
        -: 1286:    // NOTE: This check is combined with usage of rlCheckRenderBatchLimit()
      728: 1287:    if ((RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter) >=
      728: 1288:        (RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].elementCount*4 - 4))
      728: 1288-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 728
        -: 1289:    {
        -: 1290:        // WARNING: If we are between rlPushMatrix() and rlPopMatrix() and we need to force a rlDrawRenderBatch(),
        -: 1291:        // we need to call rlPopMatrix() before to recover *RLGL.State.currentMatrix (RLGL.State.modelview) for the next forced draw call!
        -: 1292:        // If we have multiple matrix pushed, it will require "RLGL.State.stackCounter" pops before launching the draw
    #####: 1293:        for (int i = RLGL.State.stackCounter; i >= 0; i--) rlPopMatrix();
    %%%%%: 1293-block  0
    %%%%%: 1293-block  1
call    0 never executed
    %%%%%: 1293-block  2
branch  1 never executed
branch  2 never executed
    #####: 1294:        rlDrawRenderBatch(RLGL.currentBatch);
    %%%%%: 1294-block  0
call    0 never executed
        -: 1295:    }
      728: 1296:}
        -: 1297:
        -: 1298:// Define one vertex (position)
        -: 1299:// NOTE: Vertex position data is the basic information required for drawing
function rlVertex3f called 2912 returned 100% blocks executed 67%
     2912: 1300:void rlVertex3f(float x, float y, float z)
        -: 1301:{
     2912: 1302:    float tx = x;
     2912: 1303:    float ty = y;
     2912: 1304:    float tz = z;
        -: 1305:
        -: 1306:    // Transform provided vector if required
     2912: 1307:    if (RLGL.State.transformRequired)
     2912: 1307-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2912
        -: 1308:    {
    #####: 1309:        tx = RLGL.State.transform.m0*x + RLGL.State.transform.m4*y + RLGL.State.transform.m8*z + RLGL.State.transform.m12;
    #####: 1310:        ty = RLGL.State.transform.m1*x + RLGL.State.transform.m5*y + RLGL.State.transform.m9*z + RLGL.State.transform.m13;
    #####: 1311:        tz = RLGL.State.transform.m2*x + RLGL.State.transform.m6*y + RLGL.State.transform.m10*z + RLGL.State.transform.m14;
    %%%%%: 1311-block  0
        -: 1312:    }
        -: 1313:
        -: 1314:    // Verify that current vertex buffer elements limit has not been reached
     2912: 1315:    if (RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter < (RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].elementCount*4))
     2912: 1315-block  0
branch  0 taken 2912 (fallthrough)
branch  1 taken 0
        -: 1316:    {
     2912: 1317:        RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vertices[3*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter] = tx;
     2912: 1318:        RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vertices[3*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter + 1] = ty;
     2912: 1319:        RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vertices[3*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter + 2] = tz;
     2912: 1320:        RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter++;
        -: 1321:
     2912: 1322:        RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount++;
     2912: 1322-block  0
        -: 1323:    }
    #####: 1324:    else TRACELOG(RL_LOG_ERROR, "RLGL: Batch elements overflow");
    %%%%%: 1324-block  0
call    0 never executed
     2912: 1325:}
        -: 1326:
        -: 1327:// Define one vertex (position)
function rlVertex2f called 2912 returned 100% blocks executed 100%
     2912: 1328:void rlVertex2f(float x, float y)
        -: 1329:{
     2912: 1330:    rlVertex3f(x, y, RLGL.currentBatch->currentDepth);
     2912: 1330-block  0
call    0 returned 2912
     2912: 1331:}
        -: 1332:
        -: 1333:// Define one vertex (position)
function rlVertex2i called 0 returned 0% blocks executed 0%
    #####: 1334:void rlVertex2i(int x, int y)
        -: 1335:{
    #####: 1336:    rlVertex3f((float)x, (float)y, RLGL.currentBatch->currentDepth);
    %%%%%: 1336-block  0
call    0 never executed
    #####: 1337:}
        -: 1338:
        -: 1339:// Define one vertex (texture coordinate)
        -: 1340:// NOTE: Texture coordinates are limited to QUADS only
function rlTexCoord2f called 2912 returned 100% blocks executed 100%
     2912: 1341:void rlTexCoord2f(float x, float y)
        -: 1342:{
     2912: 1343:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].texcoords[2*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter] = x;
     2912: 1344:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].texcoords[2*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter + 1] = y;
     2912: 1345:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter++;
     2912: 1346:}
        -: 1347:
        -: 1348:// Define one vertex (normal)
        -: 1349:// NOTE: Normals limited to TRIANGLES only?
function rlNormal3f called 728 returned 100% blocks executed 100%
      728: 1350:void rlNormal3f(float x, float y, float z)
        -: 1351:{
        -: 1352:    // TODO: Normals usage...
      728: 1353:}
        -: 1354:
        -: 1355:// Define one vertex (color)
function rlColor4ub called 728 returned 100% blocks executed 100%
      728: 1356:void rlColor4ub(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
        -: 1357:{
      728: 1358:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter] = x;
      728: 1359:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter + 1] = y;
      728: 1360:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter + 2] = z;
      728: 1361:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].colors[4*RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter + 3] = w;
      728: 1362:    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter++;
      728: 1363:}
        -: 1364:
        -: 1365:// Define one vertex (color)
function rlColor4f called 0 returned 0% blocks executed 0%
    #####: 1366:void rlColor4f(float r, float g, float b, float a)
        -: 1367:{
    #####: 1368:    rlColor4ub((unsigned char)(r*255), (unsigned char)(g*255), (unsigned char)(b*255), (unsigned char)(a*255));
    %%%%%: 1368-block  0
call    0 never executed
    #####: 1369:}
        -: 1370:
        -: 1371:// Define one vertex (color)
function rlColor3f called 0 returned 0% blocks executed 0%
    #####: 1372:void rlColor3f(float x, float y, float z)
        -: 1373:{
    #####: 1374:    rlColor4ub((unsigned char)(x*255), (unsigned char)(y*255), (unsigned char)(z*255), 255);
    %%%%%: 1374-block  0
call    0 never executed
    #####: 1375:}
        -: 1376:
        -: 1377:#endif
        -: 1378:
        -: 1379://--------------------------------------------------------------------------------------
        -: 1380:// Module Functions Definition - OpenGL style functions (common to 1.1, 3.3+, ES2)
        -: 1381://--------------------------------------------------------------------------------------
        -: 1382:
        -: 1383:// Set current texture to use
function rlSetTexture called 1456 returned 100% blocks executed 30%
     1456: 1384:void rlSetTexture(unsigned int id)
        -: 1385:{
     1456: 1386:    if (id == 0)
     1456: 1386-block  0
branch  0 taken 728 (fallthrough)
branch  1 taken 728
        -: 1387:    {
        -: 1388:#if defined(GRAPHICS_API_OPENGL_11)
        -: 1389:        rlDisableTexture();
        -: 1390:#else
        -: 1391:        // NOTE: If quads batch limit is reached, we force a draw call and next batch starts
      728: 1392:        if (RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter >=
      728: 1393:            RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].elementCount*4)
      728: 1393-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 728
        -: 1394:        {
    #####: 1395:            rlDrawRenderBatch(RLGL.currentBatch);
    %%%%%: 1395-block  0
call    0 never executed
        -: 1396:        }
        -: 1397:#endif
        -: 1398:    }
        -: 1399:    else
        -: 1400:    {
        -: 1401:#if defined(GRAPHICS_API_OPENGL_11)
        -: 1402:        rlEnableTexture(id);
        -: 1403:#else
      728: 1404:        if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].textureId != id)
      728: 1404-block  0
branch  0 taken 104 (fallthrough)
branch  1 taken 624
        -: 1405:        {
      104: 1406:            if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount > 0)
      104: 1406-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 104
        -: 1407:            {
        -: 1408:                // Make sure current RLGL.currentBatch->draws[i].vertexCount is aligned a multiple of 4,
        -: 1409:                // that way, following QUADS drawing will keep aligned with index processing
        -: 1410:                // It implies adding some extra alignment vertex at the end of the draw,
        -: 1411:                // those vertex are not processed but they are considered as an additional offset
        -: 1412:                // for the next set of vertex to be drawn
    #####: 1413:                if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].mode == RL_LINES) RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment = ((RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount < 4)? RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount : RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount%4);
    %%%%%: 1413-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1413-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1413-block  2
    %%%%%: 1413-block  3
    %%%%%: 1413-block  4
    #####: 1414:                else if (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].mode == RL_TRIANGLES) RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment = ((RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount < 4)? 1 : (4 - (RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount%4)));
    %%%%%: 1414-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1414-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1414-block  2
    %%%%%: 1414-block  3
    %%%%%: 1414-block  4
    #####: 1415:                else RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment = 0;
    %%%%%: 1415-block  0
        -: 1416:
    #####: 1417:                if (!rlCheckRenderBatchLimit(RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment))
    %%%%%: 1417-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1418:                {
    #####: 1419:                    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter += RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment;
    #####: 1420:                    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].cCounter += RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment;
    #####: 1421:                    RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].tcCounter += RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexAlignment;
        -: 1422:
    #####: 1423:                    RLGL.currentBatch->drawCounter++;
    %%%%%: 1423-block  0
        -: 1424:                }
        -: 1425:            }
        -: 1426:
     104*: 1427:            if (RLGL.currentBatch->drawCounter >= RL_DEFAULT_BATCH_DRAWCALLS) rlDrawRenderBatch(RLGL.currentBatch);
      104: 1427-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 104
    %%%%%: 1427-block  1
call    2 never executed
        -: 1428:
      104: 1429:            RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].textureId = id;
      104: 1430:            RLGL.currentBatch->draws[RLGL.currentBatch->drawCounter - 1].vertexCount = 0;
      104: 1430-block  0
        -: 1431:        }
        -: 1432:#endif
        -: 1433:    }
     1456: 1434:}
        -: 1435:
        -: 1436:// Select and active a texture slot
function rlActiveTextureSlot called 0 returned 0% blocks executed 0%
    #####: 1437:void rlActiveTextureSlot(int slot)
        -: 1438:{
        -: 1439:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 1440:    glActiveTexture(GL_TEXTURE0 + slot);
    %%%%%: 1440-block  0
call    0 never executed
        -: 1441:#endif
    #####: 1442:}
        -: 1443:
        -: 1444:// Enable texture
function rlEnableTexture called 0 returned 0% blocks executed 0%
    #####: 1445:void rlEnableTexture(unsigned int id)
        -: 1446:{
        -: 1447:#if defined(GRAPHICS_API_OPENGL_11)
        -: 1448:    glEnable(GL_TEXTURE_2D);
        -: 1449:#endif
    #####: 1450:    glBindTexture(GL_TEXTURE_2D, id);
    %%%%%: 1450-block  0
call    0 never executed
    #####: 1451:}
        -: 1452:
        -: 1453:// Disable texture
function rlDisableTexture called 0 returned 0% blocks executed 0%
    #####: 1454:void rlDisableTexture(void)
        -: 1455:{
        -: 1456:#if defined(GRAPHICS_API_OPENGL_11)
        -: 1457:    glDisable(GL_TEXTURE_2D);
        -: 1458:#endif
    #####: 1459:    glBindTexture(GL_TEXTURE_2D, 0);
    %%%%%: 1459-block  0
call    0 never executed
    #####: 1460:}
        -: 1461:
        -: 1462:// Enable texture cubemap
function rlEnableTextureCubemap called 0 returned 0% blocks executed 0%
    #####: 1463:void rlEnableTextureCubemap(unsigned int id)
        -: 1464:{
        -: 1465:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 1466:    glEnable(GL_TEXTURE_CUBE_MAP);   // Core in OpenGL 1.4
    %%%%%: 1466-block  0
call    0 never executed
    #####: 1467:    glBindTexture(GL_TEXTURE_CUBE_MAP, id);
call    0 never executed
        -: 1468:#endif
    #####: 1469:}
        -: 1470:
        -: 1471:// Disable texture cubemap
function rlDisableTextureCubemap called 0 returned 0% blocks executed 0%
    #####: 1472:void rlDisableTextureCubemap(void)
        -: 1473:{
        -: 1474:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 1475:    glDisable(GL_TEXTURE_CUBE_MAP);
    %%%%%: 1475-block  0
call    0 never executed
    #####: 1476:    glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
call    0 never executed
        -: 1477:#endif
    #####: 1478:}
        -: 1479:
        -: 1480:// Set texture parameters (wrap mode/filter mode)
function rlTextureParameters called 0 returned 0% blocks executed 0%
    #####: 1481:void rlTextureParameters(unsigned int id, int param, int value)
        -: 1482:{
    #####: 1483:    glBindTexture(GL_TEXTURE_2D, id);
    %%%%%: 1483-block  0
call    0 never executed
        -: 1484:
    #####: 1485:    switch (param)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1486:    {
    #####: 1487:        case RL_TEXTURE_WRAP_S:
        -: 1488:        case RL_TEXTURE_WRAP_T:
        -: 1489:        {
    #####: 1490:            if (value == RL_TEXTURE_WRAP_MIRROR_CLAMP)
    %%%%%: 1490-block  0
branch  0 never executed
branch  1 never executed
        -: 1491:            {
        -: 1492:#if !defined(GRAPHICS_API_OPENGL_11)
    #####: 1493:                if (RLGL.ExtSupported.texMirrorClamp) glTexParameteri(GL_TEXTURE_2D, param, value);
    %%%%%: 1493-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1493-block  1
call    2 never executed
    #####: 1494:                else TRACELOG(RL_LOG_WARNING, "GL: Clamp mirror wrap mode not supported (GL_MIRROR_CLAMP_EXT)");
    %%%%%: 1494-block  0
call    0 never executed
        -: 1495:#endif
        -: 1496:            }
    #####: 1497:            else glTexParameteri(GL_TEXTURE_2D, param, value);
    %%%%%: 1497-block  0
call    0 never executed
        -: 1498:
    #####: 1499:        } break;
    %%%%%: 1499-block  0
    #####: 1500:        case RL_TEXTURE_MAG_FILTER:
    #####: 1501:        case RL_TEXTURE_MIN_FILTER: glTexParameteri(GL_TEXTURE_2D, param, value); break;
    %%%%%: 1501-block  0
call    0 never executed
    #####: 1502:        case RL_TEXTURE_FILTER_ANISOTROPIC:
        -: 1503:        {
        -: 1504:#if !defined(GRAPHICS_API_OPENGL_11)
    #####: 1505:            if (value <= RLGL.ExtSupported.maxAnisotropyLevel) glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, (float)value);
    %%%%%: 1505-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1505-block  1
call    2 never executed
    #####: 1506:            else if (RLGL.ExtSupported.maxAnisotropyLevel > 0.0f)
    %%%%%: 1506-block  0
branch  0 never executed
branch  1 never executed
        -: 1507:            {
    #####: 1508:                TRACELOG(RL_LOG_WARNING, "GL: Maximum anisotropic filter level supported is %iX", id, RLGL.ExtSupported.maxAnisotropyLevel);
    %%%%%: 1508-block  0
call    0 never executed
    #####: 1509:                glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, (float)value);
call    0 never executed
        -: 1510:            }
    #####: 1511:            else TRACELOG(RL_LOG_WARNING, "GL: Anisotropic filtering not supported");
    %%%%%: 1511-block  0
call    0 never executed
        -: 1512:#endif
    #####: 1513:        } break;
    %%%%%: 1513-block  0
    #####: 1514:        default: break;
    %%%%%: 1514-block  0
        -: 1515:    }
        -: 1516:
    #####: 1517:    glBindTexture(GL_TEXTURE_2D, 0);
    %%%%%: 1517-block  0
call    0 never executed
    #####: 1518:}
        -: 1519:
        -: 1520:// Enable shader program
function rlEnableShader called 0 returned 0% blocks executed 0%
    #####: 1521:void rlEnableShader(unsigned int id)
        -: 1522:{
        -: 1523:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2))
    #####: 1524:    glUseProgram(id);
    %%%%%: 1524-block  0
call    0 never executed
        -: 1525:#endif
    #####: 1526:}
        -: 1527:
        -: 1528:// Disable shader program
function rlDisableShader called 0 returned 0% blocks executed 0%
    #####: 1529:void rlDisableShader(void)
        -: 1530:{
        -: 1531:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2))
    #####: 1532:    glUseProgram(0);
    %%%%%: 1532-block  0
call    0 never executed
        -: 1533:#endif
    #####: 1534:}
        -: 1535:
        -: 1536:// Enable rendering to texture (fbo)
function rlEnableFramebuffer called 0 returned 0% blocks executed 0%
    #####: 1537:void rlEnableFramebuffer(unsigned int id)
        -: 1538:{
        -: 1539:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)) && defined(SUPPORT_RENDER_TEXTURES_HINT)
    #####: 1540:    glBindFramebuffer(GL_FRAMEBUFFER, id);
    %%%%%: 1540-block  0
call    0 never executed
        -: 1541:#endif
    #####: 1542:}
        -: 1543:
        -: 1544:// Disable rendering to texture
function rlDisableFramebuffer called 0 returned 0% blocks executed 0%
    #####: 1545:void rlDisableFramebuffer(void)
        -: 1546:{
        -: 1547:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)) && defined(SUPPORT_RENDER_TEXTURES_HINT)
    #####: 1548:    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    %%%%%: 1548-block  0
call    0 never executed
        -: 1549:#endif
    #####: 1550:}
        -: 1551:
        -: 1552:// Activate multiple draw color buffers
        -: 1553:// NOTE: One color buffer is always active by default
function rlActiveDrawBuffers called 0 returned 0% blocks executed 0%
    #####: 1554:void rlActiveDrawBuffers(int count)
        -: 1555:{
        -: 1556:#if (defined(GRAPHICS_API_OPENGL_33) && defined(SUPPORT_RENDER_TEXTURES_HINT))
        -: 1557:    // NOTE: Maximum number of draw buffers supported is implementation dependant,
        -: 1558:    // it can be queried with glGet*() but it must be at least 8
        -: 1559:    //GLint maxDrawBuffers = 0;
        -: 1560:    //glGetIntegerv(GL_MAX_DRAW_BUFFERS, &maxDrawBuffers);
        -: 1561:
    #####: 1562:    if (count > 0)
    %%%%%: 1562-block  0
branch  0 never executed
branch  1 never executed
        -: 1563:    {
    #####: 1564:        if (count > 8) TRACELOG(LOG_WARNING, "GL: Max color buffers limited to 8");
    %%%%%: 1564-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1564-block  1
call    2 never executed
        -: 1565:        else
        -: 1566:        {
    #####: 1567:            unsigned int buffers[8] = {
        -: 1568:                GL_COLOR_ATTACHMENT0,
        -: 1569:                GL_COLOR_ATTACHMENT1,
        -: 1570:                GL_COLOR_ATTACHMENT2,
        -: 1571:                GL_COLOR_ATTACHMENT3,
        -: 1572:                GL_COLOR_ATTACHMENT4,
        -: 1573:                GL_COLOR_ATTACHMENT5,
        -: 1574:                GL_COLOR_ATTACHMENT6,
        -: 1575:                GL_COLOR_ATTACHMENT7,
        -: 1576:            };
        -: 1577:
    #####: 1578:            glDrawBuffers(count, buffers);
    %%%%%: 1578-block  0
call    0 never executed
        -: 1579:        }
        -: 1580:    }
    #####: 1581:    else TRACELOG(LOG_WARNING, "GL: One color buffer active by default");
    %%%%%: 1581-block  0
call    0 never executed
        -: 1582:#endif
    #####: 1583:}
        -: 1584:
        -: 1585://----------------------------------------------------------------------------------
        -: 1586:// General render state configuration
        -: 1587://----------------------------------------------------------------------------------
        -: 1588:
        -: 1589:// Enable color blending
function rlEnableColorBlend called 0 returned 0% blocks executed 0%
    #####: 1590:void rlEnableColorBlend(void) { glEnable(GL_BLEND); }
    %%%%%: 1590-block  0
call    0 never executed
        -: 1591:
        -: 1592:// Disable color blending
function rlDisableColorBlend called 0 returned 0% blocks executed 0%
    #####: 1593:void rlDisableColorBlend(void) { glDisable(GL_BLEND); }
    %%%%%: 1593-block  0
call    0 never executed
        -: 1594:
        -: 1595:// Enable depth test
function rlEnableDepthTest called 0 returned 0% blocks executed 0%
    #####: 1596:void rlEnableDepthTest(void) { glEnable(GL_DEPTH_TEST); }
    %%%%%: 1596-block  0
call    0 never executed
        -: 1597:
        -: 1598:// Disable depth test
function rlDisableDepthTest called 0 returned 0% blocks executed 0%
    #####: 1599:void rlDisableDepthTest(void) { glDisable(GL_DEPTH_TEST); }
    %%%%%: 1599-block  0
call    0 never executed
        -: 1600:
        -: 1601:// Enable depth write
function rlEnableDepthMask called 0 returned 0% blocks executed 0%
    #####: 1602:void rlEnableDepthMask(void) { glDepthMask(GL_TRUE); }
    %%%%%: 1602-block  0
call    0 never executed
        -: 1603:
        -: 1604:// Disable depth write
function rlDisableDepthMask called 0 returned 0% blocks executed 0%
    #####: 1605:void rlDisableDepthMask(void) { glDepthMask(GL_FALSE); }
    %%%%%: 1605-block  0
call    0 never executed
        -: 1606:
        -: 1607:// Enable backface culling
function rlEnableBackfaceCulling called 0 returned 0% blocks executed 0%
    #####: 1608:void rlEnableBackfaceCulling(void) { glEnable(GL_CULL_FACE); }
    %%%%%: 1608-block  0
call    0 never executed
        -: 1609:
        -: 1610:// Disable backface culling
function rlDisableBackfaceCulling called 0 returned 0% blocks executed 0%
    #####: 1611:void rlDisableBackfaceCulling(void) { glDisable(GL_CULL_FACE); }
    %%%%%: 1611-block  0
call    0 never executed
        -: 1612:
        -: 1613:// Enable scissor test
function rlEnableScissorTest called 0 returned 0% blocks executed 0%
    #####: 1614:void rlEnableScissorTest(void) { glEnable(GL_SCISSOR_TEST); }
    %%%%%: 1614-block  0
call    0 never executed
        -: 1615:
        -: 1616:// Disable scissor test
function rlDisableScissorTest called 0 returned 0% blocks executed 0%
    #####: 1617:void rlDisableScissorTest(void) { glDisable(GL_SCISSOR_TEST); }
    %%%%%: 1617-block  0
call    0 never executed
        -: 1618:
        -: 1619:// Scissor test
function rlScissor called 0 returned 0% blocks executed 0%
    #####: 1620:void rlScissor(int x, int y, int width, int height) { glScissor(x, y, width, height); }
    %%%%%: 1620-block  0
call    0 never executed
        -: 1621:
        -: 1622:// Enable wire mode
function rlEnableWireMode called 0 returned 0% blocks executed 0%
    #####: 1623:void rlEnableWireMode(void)
        -: 1624:{
        -: 1625:#if defined(GRAPHICS_API_OPENGL_11) || defined(GRAPHICS_API_OPENGL_33)
        -: 1626:    // NOTE: glPolygonMode() not available on OpenGL ES
    #####: 1627:    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    %%%%%: 1627-block  0
call    0 never executed
        -: 1628:#endif
    #####: 1629:}
        -: 1630:
        -: 1631:// Disable wire mode
function rlDisableWireMode called 0 returned 0% blocks executed 0%
    #####: 1632:void rlDisableWireMode(void)
        -: 1633:{
        -: 1634:#if defined(GRAPHICS_API_OPENGL_11) || defined(GRAPHICS_API_OPENGL_33)
        -: 1635:    // NOTE: glPolygonMode() not available on OpenGL ES
    #####: 1636:    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    %%%%%: 1636-block  0
call    0 never executed
        -: 1637:#endif
    #####: 1638:}
        -: 1639:
        -: 1640:// Set the line drawing width
function rlSetLineWidth called 0 returned 0% blocks executed 0%
    #####: 1641:void rlSetLineWidth(float width) { glLineWidth(width); }
    %%%%%: 1641-block  0
call    0 never executed
        -: 1642:
        -: 1643:// Get the line drawing width
function rlGetLineWidth called 0 returned 0% blocks executed 0%
    #####: 1644:float rlGetLineWidth(void)
        -: 1645:{
    #####: 1646:    float width = 0;
    #####: 1647:    glGetFloatv(GL_LINE_WIDTH, &width);
    %%%%%: 1647-block  0
call    0 never executed
    #####: 1648:    return width;
        -: 1649:}
        -: 1650:
        -: 1651:// Enable line aliasing
function rlEnableSmoothLines called 0 returned 0% blocks executed 0%
    #####: 1652:void rlEnableSmoothLines(void)
        -: 1653:{
        -: 1654:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_11)
    #####: 1655:    glEnable(GL_LINE_SMOOTH);
    %%%%%: 1655-block  0
call    0 never executed
        -: 1656:#endif
    #####: 1657:}
        -: 1658:
        -: 1659:// Disable line aliasing
function rlDisableSmoothLines called 0 returned 0% blocks executed 0%
    #####: 1660:void rlDisableSmoothLines(void)
        -: 1661:{
        -: 1662:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_11)
    #####: 1663:    glDisable(GL_LINE_SMOOTH);
    %%%%%: 1663-block  0
call    0 never executed
        -: 1664:#endif
    #####: 1665:}
        -: 1666:
        -: 1667:// Enable stereo rendering
function rlEnableStereoRender called 0 returned 0% blocks executed 0%
    #####: 1668:void rlEnableStereoRender(void)
        -: 1669:{
        -: 1670:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2))
    #####: 1671:    RLGL.State.stereoRender = true;
        -: 1672:#endif
    #####: 1673:}
        -: 1674:
        -: 1675:// Disable stereo rendering
function rlDisableStereoRender called 0 returned 0% blocks executed 0%
    #####: 1676:void rlDisableStereoRender(void)
        -: 1677:{
        -: 1678:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2))
    #####: 1679:    RLGL.State.stereoRender = false;
        -: 1680:#endif
    #####: 1681:}
        -: 1682:
        -: 1683:// Check if stereo render is enabled
function rlIsStereoRenderEnabled called 0 returned 0% blocks executed 0%
    #####: 1684:bool rlIsStereoRenderEnabled(void)
        -: 1685:{
        -: 1686:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2))
    #####: 1687:    return RLGL.State.stereoRender;
    %%%%%: 1687-block  0
        -: 1688:#else
        -: 1689:    return false;
        -: 1690:#endif
        -: 1691:}
        -: 1692:
        -: 1693:// Clear color buffer with color
function rlClearColor called 105 returned 100% blocks executed 100%
      105: 1694:void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
        -: 1695:{
        -: 1696:    // Color values clamp to 0.0f(0) and 1.0f(255)
      105: 1697:    float cr = (float)r/255;
      105: 1698:    float cg = (float)g/255;
      105: 1699:    float cb = (float)b/255;
      105: 1700:    float ca = (float)a/255;
        -: 1701:
      105: 1702:    glClearColor(cr, cg, cb, ca);
      105: 1702-block  0
call    0 returned 105
      105: 1703:}
        -: 1704:
        -: 1705:// Clear used screen buffers (color and depth)
function rlClearScreenBuffers called 105 returned 100% blocks executed 100%
      105: 1706:void rlClearScreenBuffers(void)
        -: 1707:{
      105: 1708:    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     // Clear used buffers: Color and Depth (Depth is used for 3D)
      105: 1708-block  0
call    0 returned 105
        -: 1709:    //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);     // Stencil buffer not used...
      105: 1710:}
        -: 1711:
        -: 1712:// Check and log OpenGL error codes
function rlCheckErrors called 0 returned 0% blocks executed 0%
    #####: 1713:void rlCheckErrors()
        -: 1714:{
        -: 1715:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 1716:    int check = 1;
    #####: 1717:    while (check)
    %%%%%: 1717-block  0
    %%%%%: 1717-block  1
branch  0 never executed
branch  1 never executed
        -: 1718:    {
    #####: 1719:        const GLenum err = glGetError();
    %%%%%: 1719-block  0
call    0 never executed
    #####: 1720:        switch (err)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 1721:        {
    #####: 1722:            case GL_NO_ERROR: check = 0; break;
    %%%%%: 1722-block  0
    #####: 1723:            case 0x0500: TRACELOG(RL_LOG_WARNING, "GL: Error detected: GL_INVALID_ENUM"); break;
    %%%%%: 1723-block  0
call    0 never executed
    #####: 1724:            case 0x0501: TRACELOG(RL_LOG_WARNING, "GL: Error detected: GL_INVALID_VALUE"); break;
    %%%%%: 1724-block  0
call    0 never executed
    #####: 1725:            case 0x0502: TRACELOG(RL_LOG_WARNING, "GL: Error detected: GL_INVALID_OPERATION"); break;
    %%%%%: 1725-block  0
call    0 never executed
    #####: 1726:            case 0x0503: TRACELOG(RL_LOG_WARNING, "GL: Error detected: GL_STACK_OVERFLOW"); break;
    %%%%%: 1726-block  0
call    0 never executed
    #####: 1727:            case 0x0504: TRACELOG(RL_LOG_WARNING, "GL: Error detected: GL_STACK_UNDERFLOW"); break;
    %%%%%: 1727-block  0
call    0 never executed
    #####: 1728:            case 0x0505: TRACELOG(RL_LOG_WARNING, "GL: Error detected: GL_OUT_OF_MEMORY"); break;
    %%%%%: 1728-block  0
call    0 never executed
    #####: 1729:            case 0x0506: TRACELOG(RL_LOG_WARNING, "GL: Error detected: GL_INVALID_FRAMEBUFFER_OPERATION"); break;
    %%%%%: 1729-block  0
call    0 never executed
    #####: 1730:            default: TRACELOG(RL_LOG_WARNING, "GL: Error detected: Unknown error code: %x", err); break;
    %%%%%: 1730-block  0
call    0 never executed
        -: 1731:        }
        -: 1732:    }
        -: 1733:#endif
    #####: 1734:}
        -: 1735:
        -: 1736:// Set blend mode
function rlSetBlendMode called 0 returned 0% blocks executed 0%
    #####: 1737:void rlSetBlendMode(int mode)
        -: 1738:{
        -: 1739:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 1740:    if (RLGL.State.currentBlendMode != mode)
    %%%%%: 1740-block  0
branch  0 never executed
branch  1 never executed
        -: 1741:    {
    #####: 1742:        rlDrawRenderBatch(RLGL.currentBatch);
    %%%%%: 1742-block  0
call    0 never executed
        -: 1743:
    #####: 1744:        switch (mode)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1745:        {
    #####: 1746:            case RL_BLEND_ALPHA: glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glBlendEquation(GL_FUNC_ADD); break;
    %%%%%: 1746-block  0
call    0 never executed
call    1 never executed
    #####: 1747:            case RL_BLEND_ADDITIVE: glBlendFunc(GL_SRC_ALPHA, GL_ONE); glBlendEquation(GL_FUNC_ADD); break;
    %%%%%: 1747-block  0
call    0 never executed
call    1 never executed
    #####: 1748:            case RL_BLEND_MULTIPLIED: glBlendFunc(GL_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA); glBlendEquation(GL_FUNC_ADD); break;
    %%%%%: 1748-block  0
call    0 never executed
call    1 never executed
    #####: 1749:            case RL_BLEND_ADD_COLORS: glBlendFunc(GL_ONE, GL_ONE); glBlendEquation(GL_FUNC_ADD); break;
    %%%%%: 1749-block  0
call    0 never executed
call    1 never executed
    #####: 1750:            case RL_BLEND_SUBTRACT_COLORS: glBlendFunc(GL_ONE, GL_ONE); glBlendEquation(GL_FUNC_SUBTRACT); break;
    %%%%%: 1750-block  0
call    0 never executed
call    1 never executed
    #####: 1751:            case RL_BLEND_CUSTOM: glBlendFunc(RLGL.State.glBlendSrcFactor, RLGL.State.glBlendDstFactor); glBlendEquation(RLGL.State.glBlendEquation); break;
    %%%%%: 1751-block  0
call    0 never executed
call    1 never executed
    #####: 1752:            default: break;
    %%%%%: 1752-block  0
        -: 1753:        }
        -: 1754:
    #####: 1755:        RLGL.State.currentBlendMode = mode;
    %%%%%: 1755-block  0
        -: 1756:    }
        -: 1757:#endif
    #####: 1758:}
        -: 1759:
        -: 1760:// Set blending mode factor and equation
function rlSetBlendFactors called 0 returned 0% blocks executed 0%
    #####: 1761:void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
        -: 1762:{
        -: 1763:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 1764:    RLGL.State.glBlendSrcFactor = glSrcFactor;
    #####: 1765:    RLGL.State.glBlendDstFactor = glDstFactor;
    #####: 1766:    RLGL.State.glBlendEquation = glEquation;
        -: 1767:#endif
    #####: 1768:}
        -: 1769:
        -: 1770://----------------------------------------------------------------------------------
        -: 1771:// Module Functions Definition - rlgl functionality
        -: 1772://----------------------------------------------------------------------------------
        -: 1773:
        -: 1774:// Initialize rlgl: OpenGL extensions, default buffers/shaders/textures, OpenGL states
function rlglInit called 1 returned 100% blocks executed 96%
        1: 1775:void rlglInit(int width, int height)
        -: 1776:{
        -: 1777:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 1778:    // Init default white texture
        1: 1779:    unsigned char pixels[4] = { 255, 255, 255, 255 };   // 1 pixel RGBA (4 bytes)
        1: 1780:    RLGL.State.defaultTextureId = rlLoadTexture(pixels, 1, 1, RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8, 1);
        1: 1780-block  0
call    0 returned 1
        -: 1781:
        1: 1782:    if (RLGL.State.defaultTextureId != 0) TRACELOG(RL_LOG_INFO, "TEXTURE: [ID %i] Default texture loaded successfully", RLGL.State.defaultTextureId);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1782-block  0
call    2 returned 1
    #####: 1783:    else TRACELOG(RL_LOG_WARNING, "TEXTURE: Failed to load default texture");
    %%%%%: 1783-block  0
call    0 never executed
        -: 1784:
        -: 1785:    // Init default Shader (customized for GL 3.3 and ES2)
        -: 1786:    // Loaded: RLGL.State.defaultShaderId + RLGL.State.defaultShaderLocs
        1: 1787:    rlLoadShaderDefault();
        1: 1787-block  0
call    0 returned 1
        1: 1788:    RLGL.State.currentShaderId = RLGL.State.defaultShaderId;
        1: 1789:    RLGL.State.currentShaderLocs = RLGL.State.defaultShaderLocs;
        -: 1790:
        -: 1791:    // Init default vertex arrays buffers
        1: 1792:    RLGL.defaultBatch = rlLoadRenderBatch(RL_DEFAULT_BATCH_BUFFERS, RL_DEFAULT_BATCH_BUFFER_ELEMENTS);
call    0 returned 1
        1: 1793:    RLGL.currentBatch = &RLGL.defaultBatch;
        -: 1794:
        -: 1795:    // Init stack matrices (emulating OpenGL 1.1)
       33: 1796:    for (int i = 0; i < RL_MAX_MATRIX_STACK_SIZE; i++) RLGL.State.stack[i] = rlMatrixIdentity();
       32: 1796-block  0
call    0 returned 32
       33: 1796-block  1
branch  1 taken 32
branch  2 taken 1 (fallthrough)
        -: 1797:
        -: 1798:    // Init internal matrices
        1: 1799:    RLGL.State.transform = rlMatrixIdentity();
        1: 1799-block  0
call    0 returned 1
        1: 1800:    RLGL.State.projection = rlMatrixIdentity();
call    0 returned 1
        1: 1801:    RLGL.State.modelview = rlMatrixIdentity();
call    0 returned 1
        1: 1802:    RLGL.State.currentMatrix = &RLGL.State.modelview;
        -: 1803:#endif  // GRAPHICS_API_OPENGL_33 || GRAPHICS_API_OPENGL_ES2
        -: 1804:
        -: 1805:    // Initialize OpenGL default states
        -: 1806:    //----------------------------------------------------------
        -: 1807:    // Init state: Depth test
        1: 1808:    glDepthFunc(GL_LEQUAL);                                 // Type of depth testing to apply
call    0 returned 1
        1: 1809:    glDisable(GL_DEPTH_TEST);                               // Disable depth testing for 2D (only used for 3D)
call    0 returned 1
        -: 1810:
        -: 1811:    // Init state: Blending mode
        1: 1812:    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);      // Color blending function (how colors are mixed)
call    0 returned 1
        1: 1813:    glEnable(GL_BLEND);                                     // Enable color blending (required to work with transparencies)
call    0 returned 1
        -: 1814:
        -: 1815:    // Init state: Culling
        -: 1816:    // NOTE: All shapes/models triangles are drawn CCW
        1: 1817:    glCullFace(GL_BACK);                                    // Cull the back face (default)
call    0 returned 1
        1: 1818:    glFrontFace(GL_CCW);                                    // Front face are defined counter clockwise (default)
call    0 returned 1
        1: 1819:    glEnable(GL_CULL_FACE);                                 // Enable backface culling
call    0 returned 1
        -: 1820:
        -: 1821:    // Init state: Cubemap seamless
        -: 1822:#if defined(GRAPHICS_API_OPENGL_33)
        1: 1823:    glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);                 // Seamless cubemaps (not supported on OpenGL ES 2.0)
call    0 returned 1
        -: 1824:#endif
        -: 1825:
        -: 1826:#if defined(GRAPHICS_API_OPENGL_11)
        -: 1827:    // Init state: Color hints (deprecated in OpenGL 3.0+)
        -: 1828:    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);      // Improve quality of color and texture coordinate interpolation
        -: 1829:    glShadeModel(GL_SMOOTH);                                // Smooth shading between vertex (vertex colors interpolation)
        -: 1830:#endif
        -: 1831:
        -: 1832:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 1833:    // Store screen size into global variables
        1: 1834:    RLGL.State.framebufferWidth = width;
        1: 1835:    RLGL.State.framebufferHeight = height;
        -: 1836:
        1: 1837:    TRACELOG(RL_LOG_INFO, "RLGL: Default OpenGL state initialized successfully");
call    0 returned 1
        -: 1838:    //----------------------------------------------------------
        -: 1839:#endif
        -: 1840:
        -: 1841:    // Init state: Color/Depth buffers clear
        1: 1842:    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);                   // Set clear color (black)
call    0 returned 1
        1: 1843:    glClearDepth(1.0f);                                     // Set clear depth value (default)
call    0 returned 1
        1: 1844:    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     // Clear color and depth buffers (depth buffer required for 3D)
call    0 returned 1
        1: 1845:}
        -: 1846:
        -: 1847:// Vertex Buffer Object deinitialization (memory free)
function rlglClose called 1 returned 100% blocks executed 100%
        1: 1848:void rlglClose(void)
        -: 1849:{
        -: 1850:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        1: 1851:    rlUnloadRenderBatch(RLGL.defaultBatch);
        1: 1851-block  0
call    0 returned 1
        -: 1852:
        1: 1853:    rlUnloadShaderDefault();          // Unload default shader
call    0 returned 1
        -: 1854:
        1: 1855:    glDeleteTextures(1, &RLGL.State.defaultTextureId); // Unload default texture
call    0 returned 1
        1: 1856:    TRACELOG(RL_LOG_INFO, "TEXTURE: [ID %i] Default texture unloaded successfully", RLGL.State.defaultTextureId);
call    0 returned 1
        -: 1857:#endif
        1: 1858:}
        -: 1859:
        -: 1860:// Load OpenGL extensions
        -: 1861:// NOTE: External loader function must be provided
function rlLoadExtensions called 1 returned 100% blocks executed 87%
        1: 1862:void rlLoadExtensions(void *loader)
        -: 1863:{
        -: 1864:#if defined(GRAPHICS_API_OPENGL_33)     // Also defined for GRAPHICS_API_OPENGL_21
        -: 1865:    // NOTE: glad is generated and contains only required OpenGL 3.3 Core extensions (and lower versions)
        -: 1866:    #if !defined(__APPLE__)
       1*: 1867:        if (!gladLoadGLLoader((GLADloadproc)loader)) TRACELOG(RL_LOG_WARNING, "GLAD: Cannot load OpenGL extensions");
        1: 1867-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 1867-block  1
call    3 never executed
        1: 1868:        else TRACELOG(RL_LOG_INFO, "GLAD: OpenGL extensions loaded successfully");
        1: 1868-block  0
call    0 returned 1
        -: 1869:    #endif
        -: 1870:
        -: 1871:    // Get number of supported extensions
        1: 1872:    GLint numExt = 0;
        1: 1873:    glGetIntegerv(GL_NUM_EXTENSIONS, &numExt);
        1: 1873-block  0
call    0 returned 1
        1: 1874:    TRACELOG(RL_LOG_INFO, "GL: Supported extensions count: %i", numExt);
call    0 returned 1
        -: 1875:
        -: 1876:#if defined(SUPPORT_GL_DETAILS_INFO)
        -: 1877:    // Get supported extensions list
        -: 1878:    // WARNING: glGetStringi() not available on OpenGL 2.1
        -: 1879:    char **extList = RL_MALLOC(numExt*sizeof(char *));
        -: 1880:    TRACELOG(RL_LOG_INFO, "GL: OpenGL extensions:");
        -: 1881:    for (int i = 0; i < numExt; i++)
        -: 1882:    {
        -: 1883:        extList[i] = (char *)glGetStringi(GL_EXTENSIONS, i);
        -: 1884:        TRACELOG(RL_LOG_INFO, "    %s", extList[i]);
        -: 1885:    }
        -: 1886:    RL_FREE(extList);       // Free extensions pointers
        -: 1887:#endif
        -: 1888:
        -: 1889:    // Register supported extensions flags
        -: 1890:    // OpenGL 3.3 extensions supported by default (core)
        1: 1891:    RLGL.ExtSupported.vao = true;
        1: 1892:    RLGL.ExtSupported.instancing = true;
        1: 1893:    RLGL.ExtSupported.texNPOT = true;
        1: 1894:    RLGL.ExtSupported.texFloat32 = true;
        1: 1895:    RLGL.ExtSupported.texDepth = true;
        1: 1896:    RLGL.ExtSupported.maxDepthBits = 32;
        1: 1897:    RLGL.ExtSupported.texAnisoFilter = true;
        1: 1898:    RLGL.ExtSupported.texMirrorClamp = true;
        -: 1899:    #if !defined(__APPLE__)
        -: 1900:    // NOTE: With GLAD, we can check if an extension is supported using the GLAD_GL_xxx booleans
        1: 1901:    if (GLAD_GL_EXT_texture_compression_s3tc) RLGL.ExtSupported.texCompDXT = true;  // Texture compression: DXT
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1901-block  0
        1: 1902:    if (GLAD_GL_ARB_ES3_compatibility) RLGL.ExtSupported.texCompETC2 = true;        // Texture compression: ETC2/EAC
        1: 1902-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1902-block  1
        -: 1903:    #endif
        -: 1904:#endif  // GRAPHICS_API_OPENGL_33
        -: 1905:
        -: 1906:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 1907:    // Get supported extensions list
        -: 1908:    GLint numExt = 0;
        -: 1909:    const char **extList = RL_MALLOC(512*sizeof(const char *)); // Allocate 512 strings pointers (2 KB)
        -: 1910:    const char *extensions = (const char *)glGetString(GL_EXTENSIONS);  // One big const string
        -: 1911:
        -: 1912:    // NOTE: We have to duplicate string because glGetString() returns a const string
        -: 1913:    int size = strlen(extensions) + 1;      // Get extensions string size in bytes
        -: 1914:    char *extensionsDup = (char *)RL_CALLOC(size, sizeof(char));
        -: 1915:    strcpy(extensionsDup, extensions);
        -: 1916:    extList[numExt] = extensionsDup;
        -: 1917:
        -: 1918:    for (int i = 0; i < size; i++)
        -: 1919:    {
        -: 1920:        if (extensionsDup[i] == ' ')
        -: 1921:        {
        -: 1922:            extensionsDup[i] = '\0';
        -: 1923:            numExt++;
        -: 1924:            extList[numExt] = &extensionsDup[i + 1];
        -: 1925:        }
        -: 1926:    }
        -: 1927:
        -: 1928:    TRACELOG(RL_LOG_INFO, "GL: Supported extensions count: %i", numExt);
        -: 1929:
        -: 1930:#if defined(SUPPORT_GL_DETAILS_INFO)
        -: 1931:    TRACELOG(RL_LOG_INFO, "GL: OpenGL extensions:");
        -: 1932:    for (int i = 0; i < numExt; i++) TRACELOG(RL_LOG_INFO, "    %s", extList[i]);
        -: 1933:#endif
        -: 1934:
        -: 1935:    // Check required extensions
        -: 1936:    for (int i = 0; i < numExt; i++)
        -: 1937:    {
        -: 1938:        // Check VAO support
        -: 1939:        // NOTE: Only check on OpenGL ES, OpenGL 3.3 has VAO support as core feature
        -: 1940:        if (strcmp(extList[i], (const char *)"GL_OES_vertex_array_object") == 0)
        -: 1941:        {
        -: 1942:            // The extension is supported by our hardware and driver, try to get related functions pointers
        -: 1943:            // NOTE: emscripten does not support VAOs natively, it uses emulation and it reduces overall performance...
        -: 1944:            glGenVertexArrays = (PFNGLGENVERTEXARRAYSOESPROC)((rlglLoadProc)loader)("glGenVertexArraysOES");
        -: 1945:            glBindVertexArray = (PFNGLBINDVERTEXARRAYOESPROC)((rlglLoadProc)loader)("glBindVertexArrayOES");
        -: 1946:            glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSOESPROC)((rlglLoadProc)loader)("glDeleteVertexArraysOES");
        -: 1947:            //glIsVertexArray = (PFNGLISVERTEXARRAYOESPROC)loader("glIsVertexArrayOES");     // NOTE: Fails in WebGL, omitted
        -: 1948:
        -: 1949:            if ((glGenVertexArrays != NULL) && (glBindVertexArray != NULL) && (glDeleteVertexArrays != NULL)) RLGL.ExtSupported.vao = true;
        -: 1950:        }
        -: 1951:
        -: 1952:        // Check instanced rendering support
        -: 1953:        if (strcmp(extList[i], (const char *)"GL_ANGLE_instanced_arrays") == 0)         // Web ANGLE
        -: 1954:        {
        -: 1955:            glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDEXTPROC)((rlglLoadProc)loader)("glDrawArraysInstancedANGLE");
        -: 1956:            glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDEXTPROC)((rlglLoadProc)loader)("glDrawElementsInstancedANGLE");
        -: 1957:            glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISOREXTPROC)((rlglLoadProc)loader)("glVertexAttribDivisorANGLE");
        -: 1958:
        -: 1959:            if ((glDrawArraysInstanced != NULL) && (glDrawElementsInstanced != NULL) && (glVertexAttribDivisor != NULL)) RLGL.ExtSupported.instancing = true;
        -: 1960:        }
        -: 1961:        else
        -: 1962:        {
        -: 1963:            if ((strcmp(extList[i], (const char *)"GL_EXT_draw_instanced") == 0) &&     // Standard EXT
        -: 1964:                (strcmp(extList[i], (const char *)"GL_EXT_instanced_arrays") == 0))
        -: 1965:            {
        -: 1966:                glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDEXTPROC)((rlglLoadProc)loader)("glDrawArraysInstancedEXT");
        -: 1967:                glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDEXTPROC)((rlglLoadProc)loader)("glDrawElementsInstancedEXT");
        -: 1968:                glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISOREXTPROC)((rlglLoadProc)loader)("glVertexAttribDivisorEXT");
        -: 1969:
        -: 1970:                if ((glDrawArraysInstanced != NULL) && (glDrawElementsInstanced != NULL) && (glVertexAttribDivisor != NULL)) RLGL.ExtSupported.instancing = true;
        -: 1971:            }
        -: 1972:        }
        -: 1973:
        -: 1974:        // Check NPOT textures support
        -: 1975:        // NOTE: Only check on OpenGL ES, OpenGL 3.3 has NPOT textures full support as core feature
        -: 1976:        if (strcmp(extList[i], (const char *)"GL_OES_texture_npot") == 0) RLGL.ExtSupported.texNPOT = true;
        -: 1977:
        -: 1978:        // Check texture float support
        -: 1979:        if (strcmp(extList[i], (const char *)"GL_OES_texture_float") == 0) RLGL.ExtSupported.texFloat32 = true;
        -: 1980:
        -: 1981:        // Check depth texture support
        -: 1982:        if ((strcmp(extList[i], (const char *)"GL_OES_depth_texture") == 0) ||
        -: 1983:            (strcmp(extList[i], (const char *)"GL_WEBGL_depth_texture") == 0)) RLGL.ExtSupported.texDepth = true;
        -: 1984:
        -: 1985:        if (strcmp(extList[i], (const char *)"GL_OES_depth24") == 0) RLGL.ExtSupported.maxDepthBits = 24;
        -: 1986:        if (strcmp(extList[i], (const char *)"GL_OES_depth32") == 0) RLGL.ExtSupported.maxDepthBits = 32;
        -: 1987:
        -: 1988:        // Check texture compression support: DXT
        -: 1989:        if ((strcmp(extList[i], (const char *)"GL_EXT_texture_compression_s3tc") == 0) ||
        -: 1990:            (strcmp(extList[i], (const char *)"GL_WEBGL_compressed_texture_s3tc") == 0) ||
        -: 1991:            (strcmp(extList[i], (const char *)"GL_WEBKIT_WEBGL_compressed_texture_s3tc") == 0)) RLGL.ExtSupported.texCompDXT = true;
        -: 1992:
        -: 1993:        // Check texture compression support: ETC1
        -: 1994:        if ((strcmp(extList[i], (const char *)"GL_OES_compressed_ETC1_RGB8_texture") == 0) ||
        -: 1995:            (strcmp(extList[i], (const char *)"GL_WEBGL_compressed_texture_etc1") == 0)) RLGL.ExtSupported.texCompETC1 = true;
        -: 1996:
        -: 1997:        // Check texture compression support: ETC2/EAC
        -: 1998:        if (strcmp(extList[i], (const char *)"GL_ARB_ES3_compatibility") == 0) RLGL.ExtSupported.texCompETC2 = true;
        -: 1999:
        -: 2000:        // Check texture compression support: PVR
        -: 2001:        if (strcmp(extList[i], (const char *)"GL_IMG_texture_compression_pvrtc") == 0) RLGL.ExtSupported.texCompPVRT = true;
        -: 2002:
        -: 2003:        // Check texture compression support: ASTC
        -: 2004:        if (strcmp(extList[i], (const char *)"GL_KHR_texture_compression_astc_hdr") == 0) RLGL.ExtSupported.texCompASTC = true;
        -: 2005:
        -: 2006:        // Check anisotropic texture filter support
        -: 2007:        if (strcmp(extList[i], (const char *)"GL_EXT_texture_filter_anisotropic") == 0) RLGL.ExtSupported.texAnisoFilter = true;
        -: 2008:
        -: 2009:        // Check clamp mirror wrap mode support
        -: 2010:        if (strcmp(extList[i], (const char *)"GL_EXT_texture_mirror_clamp") == 0) RLGL.ExtSupported.texMirrorClamp = true;
        -: 2011:    }
        -: 2012:
        -: 2013:    // Free extensions pointers
        -: 2014:    RL_FREE(extList);
        -: 2015:    RL_FREE(extensionsDup);    // Duplicated string must be deallocated
        -: 2016:#endif  // GRAPHICS_API_OPENGL_ES2
        -: 2017:
        -: 2018:    // Check OpenGL information and capabilities
        -: 2019:    //------------------------------------------------------------------------------
        -: 2020:    // Show current OpenGL and GLSL version
        1: 2021:    TRACELOG(RL_LOG_INFO, "GL: OpenGL device information:");
        1: 2021-block  0
call    0 returned 1
        1: 2022:    TRACELOG(RL_LOG_INFO, "    > Vendor:   %s", glGetString(GL_VENDOR));
call    0 returned 1
call    1 returned 1
        1: 2023:    TRACELOG(RL_LOG_INFO, "    > Renderer: %s", glGetString(GL_RENDERER));
call    0 returned 1
call    1 returned 1
        1: 2024:    TRACELOG(RL_LOG_INFO, "    > Version:  %s", glGetString(GL_VERSION));
call    0 returned 1
call    1 returned 1
        1: 2025:    TRACELOG(RL_LOG_INFO, "    > GLSL:     %s", glGetString(GL_SHADING_LANGUAGE_VERSION));
call    0 returned 1
call    1 returned 1
        -: 2026:
        -: 2027:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 2028:    // NOTE: Anisotropy levels capability is an extension
        -: 2029:    #ifndef GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
        -: 2030:        #define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
        -: 2031:    #endif
        1: 2032:    glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &RLGL.ExtSupported.maxAnisotropyLevel);
call    0 returned 1
        -: 2033:
        -: 2034:#if defined(SUPPORT_GL_DETAILS_INFO)
        -: 2035:    // Show some OpenGL GPU capabilities
        -: 2036:    TRACELOG(RL_LOG_INFO, "GL: OpenGL capabilities:");
        -: 2037:    GLint capability = 0;
        -: 2038:    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &capability);
        -: 2039:    TRACELOG(RL_LOG_INFO, "    GL_MAX_TEXTURE_SIZE: %i", capability);
        -: 2040:    glGetIntegerv(GL_MAX_CUBE_MAP_TEXTURE_SIZE, &capability);
        -: 2041:    TRACELOG(RL_LOG_INFO, "    GL_MAX_CUBE_MAP_TEXTURE_SIZE: %i", capability);
        -: 2042:    glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &capability);
        -: 2043:    TRACELOG(RL_LOG_INFO, "    GL_MAX_TEXTURE_IMAGE_UNITS: %i", capability);
        -: 2044:    glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &capability);
        -: 2045:    TRACELOG(RL_LOG_INFO, "    GL_MAX_VERTEX_ATTRIBS: %i", capability);
        -: 2046:    #if !defined(GRAPHICS_API_OPENGL_ES2)
        -: 2047:    glGetIntegerv(GL_MAX_UNIFORM_BLOCK_SIZE, &capability);
        -: 2048:    TRACELOG(RL_LOG_INFO, "    GL_MAX_UNIFORM_BLOCK_SIZE: %i", capability);
        -: 2049:    glGetIntegerv(GL_MAX_DRAW_BUFFERS, &capability);
        -: 2050:    TRACELOG(RL_LOG_INFO, "    GL_MAX_DRAW_BUFFERS: %i", capability);
        -: 2051:    if (RLGL.ExtSupported.texAnisoFilter) TRACELOG(RL_LOG_INFO, "    GL_MAX_TEXTURE_MAX_ANISOTROPY: %.0f", RLGL.ExtSupported.maxAnisotropyLevel);
        -: 2052:    #endif
        -: 2053:    glGetIntegerv(GL_NUM_COMPRESSED_TEXTURE_FORMATS, &capability);
        -: 2054:    TRACELOG(RL_LOG_INFO, "    GL_NUM_COMPRESSED_TEXTURE_FORMATS: %i", capability);
        -: 2055:    GLint format[32] = { 0 };
        -: 2056:    glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS, format);
        -: 2057:    for (int i = 0; i < capability; i++) TRACELOG(RL_LOG_INFO, "        %s", rlGetCompressedFormatName(format[i]));
        -: 2058:
        -: 2059:    /*
        -: 2060:    // Following capabilities are only supported by OpenGL 4.3 or greater
        -: 2061:    glGetIntegerv(GL_MAX_VERTEX_ATTRIB_BINDINGS, &capability);
        -: 2062:    TRACELOG(RL_LOG_INFO, "    GL_MAX_VERTEX_ATTRIB_BINDINGS: %i", capability);
        -: 2063:    glGetIntegerv(GL_MAX_UNIFORM_LOCATIONS, &capability);
        -: 2064:    TRACELOG(RL_LOG_INFO, "    GL_MAX_UNIFORM_LOCATIONS: %i", capability);
        -: 2065:    */
        -: 2066:#else   // SUPPORT_GL_DETAILS_INFO
        -: 2067:
        -: 2068:    // Show some basic info about GL supported features
        -: 2069:    #if defined(GRAPHICS_API_OPENGL_ES2)
        -: 2070:    if (RLGL.ExtSupported.vao) TRACELOG(RL_LOG_INFO, "GL: VAO extension detected, VAO functions loaded successfully");
        -: 2071:    else TRACELOG(RL_LOG_WARNING, "GL: VAO extension not found, VAO not supported");
        -: 2072:    if (RLGL.ExtSupported.texNPOT) TRACELOG(RL_LOG_INFO, "GL: NPOT textures extension detected, full NPOT textures supported");
        -: 2073:    else TRACELOG(RL_LOG_WARNING, "GL: NPOT textures extension not found, limited NPOT support (no-mipmaps, no-repeat)");
        -: 2074:    #endif
        1: 2075:    if (RLGL.ExtSupported.texCompDXT) TRACELOG(RL_LOG_INFO, "GL: DXT compressed textures supported");
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2075-block  0
call    2 returned 1
       1*: 2076:    if (RLGL.ExtSupported.texCompETC1) TRACELOG(RL_LOG_INFO, "GL: ETC1 compressed textures supported");
        1: 2076-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2076-block  1
call    2 never executed
        1: 2077:    if (RLGL.ExtSupported.texCompETC2) TRACELOG(RL_LOG_INFO, "GL: ETC2/EAC compressed textures supported");
        1: 2077-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2077-block  1
call    2 returned 1
       1*: 2078:    if (RLGL.ExtSupported.texCompPVRT) TRACELOG(RL_LOG_INFO, "GL: PVRT compressed textures supported");
        1: 2078-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2078-block  1
call    2 never executed
       1*: 2079:    if (RLGL.ExtSupported.texCompASTC) TRACELOG(RL_LOG_INFO, "GL: ASTC compressed textures supported");
        1: 2079-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2079-block  1
call    2 never executed
        -: 2080:#endif  // SUPPORT_GL_DETAILS_INFO
        -: 2081:
        -: 2082:#endif  // GRAPHICS_API_OPENGL_33 || GRAPHICS_API_OPENGL_ES2
        1: 2083:}
        -: 2084:
        -: 2085:// Get current OpenGL version
function rlGetVersion called 2 returned 100% blocks executed 100%
        2: 2086:int rlGetVersion(void)
        -: 2087:{
        2: 2088:    int glVersion = 0;
        -: 2089:#if defined(GRAPHICS_API_OPENGL_11)
        -: 2090:    glVersion = OPENGL_11;
        -: 2091:#endif
        -: 2092:#if defined(GRAPHICS_API_OPENGL_21)
        -: 2093:    #if defined(__APPLE__)
        -: 2094:        glVersion = OPENGL_33;           // NOTE: Force OpenGL 3.3 on OSX
        -: 2095:    #else
        -: 2096:        glVersion = OPENGL_21;
        -: 2097:    #endif
        -: 2098:#elif defined(GRAPHICS_API_OPENGL_33)
        2: 2099:    glVersion = OPENGL_33;
        -: 2100:#endif
        -: 2101:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 2102:    glVersion = OPENGL_ES_20;
        -: 2103:#endif
        2: 2104:    return glVersion;
        2: 2104-block  0
        -: 2105:}
        -: 2106:
        -: 2107:// Get default framebuffer width
function rlGetFramebufferWidth called 0 returned 0% blocks executed 0%
    #####: 2108:int rlGetFramebufferWidth(void)
        -: 2109:{
    #####: 2110:    int width = 0;
        -: 2111:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2112:    width = RLGL.State.framebufferWidth;
        -: 2113:#endif
    #####: 2114:    return width;
    %%%%%: 2114-block  0
        -: 2115:}
        -: 2116:
        -: 2117:// Get default framebuffer height
function rlGetFramebufferHeight called 0 returned 0% blocks executed 0%
    #####: 2118:int rlGetFramebufferHeight(void)
        -: 2119:{
    #####: 2120:    int height = 0;
        -: 2121:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2122:    height = RLGL.State.framebufferHeight;
        -: 2123:#endif
    #####: 2124:    return height;
    %%%%%: 2124-block  0
        -: 2125:}
        -: 2126:
        -: 2127:// Get default internal texture (white texture)
        -: 2128:// NOTE: Default texture is a 1x1 pixel UNCOMPRESSED_R8G8B8A8
function rlGetTextureIdDefault called 0 returned 0% blocks executed 0%
    #####: 2129:unsigned int rlGetTextureIdDefault(void)
        -: 2130:{
    #####: 2131:    unsigned int id = 0;
        -: 2132:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2133:    id = RLGL.State.defaultTextureId;
        -: 2134:#endif
    #####: 2135:    return id;
    %%%%%: 2135-block  0
        -: 2136:}
        -: 2137:
        -: 2138:// Get default shader id
function rlGetShaderIdDefault called 0 returned 0% blocks executed 0%
    #####: 2139:unsigned int rlGetShaderIdDefault(void)
        -: 2140:{
    #####: 2141:    unsigned int id = 0;
        -: 2142:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2143:    id = RLGL.State.defaultShaderId;
        -: 2144:#endif
    #####: 2145:    return id;
    %%%%%: 2145-block  0
        -: 2146:}
        -: 2147:
        -: 2148:// Get default shader locs
function rlGetShaderLocsDefault called 0 returned 0% blocks executed 0%
    #####: 2149:int *rlGetShaderLocsDefault(void)
        -: 2150:{
    #####: 2151:    int *locs = NULL;
        -: 2152:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2153:    locs = RLGL.State.defaultShaderLocs;
        -: 2154:#endif
    #####: 2155:    return locs;
    %%%%%: 2155-block  0
        -: 2156:}
        -: 2157:
        -: 2158:// Render batch management
        -: 2159://------------------------------------------------------------------------------------------------
        -: 2160:// Load render batch
function rlLoadRenderBatch called 1 returned 100% blocks executed 100%
        1: 2161:rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
        -: 2162:{
        1: 2163:    rlRenderBatch batch = { 0 };
        -: 2164:
        -: 2165:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 2166:    // Initialize CPU (RAM) vertex buffers (position, texcoord, color data and indexes)
        -: 2167:    //--------------------------------------------------------------------------------------------
        1: 2168:    batch.vertexBuffer = (rlVertexBuffer *)RL_MALLOC(numBuffers*sizeof(rlVertexBuffer));
        -: 2169:
        2: 2170:    for (int i = 0; i < numBuffers; i++)
        1: 2170-block  0
        2: 2170-block  1
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -: 2171:    {
        1: 2172:        batch.vertexBuffer[i].elementCount = bufferElements;
        -: 2173:
        1: 2174:        batch.vertexBuffer[i].vertices = (float *)RL_MALLOC(bufferElements*3*4*sizeof(float));        // 3 float by vertex, 4 vertex by quad
        1: 2175:        batch.vertexBuffer[i].texcoords = (float *)RL_MALLOC(bufferElements*2*4*sizeof(float));       // 2 float by texcoord, 4 texcoord by quad
        1: 2176:        batch.vertexBuffer[i].colors = (unsigned char *)RL_MALLOC(bufferElements*4*4*sizeof(unsigned char));   // 4 float by color, 4 colors by quad
        -: 2177:#if defined(GRAPHICS_API_OPENGL_33)
        1: 2178:        batch.vertexBuffer[i].indices = (unsigned int *)RL_MALLOC(bufferElements*6*sizeof(unsigned int));      // 6 int by quad (indices)
        -: 2179:#endif
        -: 2180:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 2181:        batch.vertexBuffer[i].indices = (unsigned short *)RL_MALLOC(bufferElements*6*sizeof(unsigned short));  // 6 int by quad (indices)
        -: 2182:#endif
        -: 2183:
    98305: 2184:        for (int j = 0; j < (3*4*bufferElements); j++) batch.vertexBuffer[i].vertices[j] = 0.0f;
        1: 2184-block  0
    98304: 2184-block  1
    98305: 2184-block  2
branch  0 taken 98304
branch  1 taken 1 (fallthrough)
    65537: 2185:        for (int j = 0; j < (2*4*bufferElements); j++) batch.vertexBuffer[i].texcoords[j] = 0.0f;
        1: 2185-block  0
    65536: 2185-block  1
    65537: 2185-block  2
branch  0 taken 65536
branch  1 taken 1 (fallthrough)
   131073: 2186:        for (int j = 0; j < (4*4*bufferElements); j++) batch.vertexBuffer[i].colors[j] = 0;
        1: 2186-block  0
   131072: 2186-block  1
   131073: 2186-block  2
branch  0 taken 131072
branch  1 taken 1 (fallthrough)
        -: 2187:
        1: 2188:        int k = 0;
        -: 2189:
        -: 2190:        // Indices can be initialized right now
     8193: 2191:        for (int j = 0; j < (6*bufferElements); j += 6)
        1: 2191-block  0
     8193: 2191-block  1
branch  0 taken 8192
branch  1 taken 1 (fallthrough)
        -: 2192:        {
     8192: 2193:            batch.vertexBuffer[i].indices[j] = 4*k;
     8192: 2194:            batch.vertexBuffer[i].indices[j + 1] = 4*k + 1;
     8192: 2195:            batch.vertexBuffer[i].indices[j + 2] = 4*k + 2;
     8192: 2196:            batch.vertexBuffer[i].indices[j + 3] = 4*k;
     8192: 2197:            batch.vertexBuffer[i].indices[j + 4] = 4*k + 2;
     8192: 2198:            batch.vertexBuffer[i].indices[j + 5] = 4*k + 3;
        -: 2199:
     8192: 2200:            k++;
     8192: 2200-block  0
        -: 2201:        }
        -: 2202:
        1: 2203:        batch.vertexBuffer[i].vCounter = 0;
        1: 2204:        batch.vertexBuffer[i].tcCounter = 0;
        1: 2205:        batch.vertexBuffer[i].cCounter = 0;
        1: 2205-block  0
        -: 2206:    }
        -: 2207:
        1: 2208:    TRACELOG(RL_LOG_INFO, "RLGL: Render batch vertex buffers loaded successfully in RAM (CPU)");
        1: 2208-block  0
call    0 returned 1
        -: 2209:    //--------------------------------------------------------------------------------------------
        -: 2210:
        -: 2211:    // Upload to GPU (VRAM) vertex data and initialize VAOs/VBOs
        -: 2212:    //--------------------------------------------------------------------------------------------
        2: 2213:    for (int i = 0; i < numBuffers; i++)
        2: 2213-block  0
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -: 2214:    {
        1: 2215:        if (RLGL.ExtSupported.vao)
        1: 2215-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2216:        {
        -: 2217:            // Initialize Quads VAO
        1: 2218:            glGenVertexArrays(1, &batch.vertexBuffer[i].vaoId);
        1: 2218-block  0
call    0 returned 1
        1: 2219:            glBindVertexArray(batch.vertexBuffer[i].vaoId);
call    0 returned 1
        -: 2220:        }
        -: 2221:
        -: 2222:        // Quads - Vertex buffers binding and attributes enable
        -: 2223:        // Vertex position buffer (shader-location = 0)
        1: 2224:        glGenBuffers(1, &batch.vertexBuffer[i].vboId[0]);
        1: 2224-block  0
call    0 returned 1
        1: 2225:        glBindBuffer(GL_ARRAY_BUFFER, batch.vertexBuffer[i].vboId[0]);
call    0 returned 1
        1: 2226:        glBufferData(GL_ARRAY_BUFFER, bufferElements*3*4*sizeof(float), batch.vertexBuffer[i].vertices, GL_DYNAMIC_DRAW);
call    0 returned 1
        1: 2227:        glEnableVertexAttribArray(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_POSITION]);
call    0 returned 1
        1: 2228:        glVertexAttribPointer(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_POSITION], 3, GL_FLOAT, 0, 0, 0);
call    0 returned 1
        -: 2229:
        -: 2230:        // Vertex texcoord buffer (shader-location = 1)
        1: 2231:        glGenBuffers(1, &batch.vertexBuffer[i].vboId[1]);
call    0 returned 1
        1: 2232:        glBindBuffer(GL_ARRAY_BUFFER, batch.vertexBuffer[i].vboId[1]);
call    0 returned 1
        1: 2233:        glBufferData(GL_ARRAY_BUFFER, bufferElements*2*4*sizeof(float), batch.vertexBuffer[i].texcoords, GL_DYNAMIC_DRAW);
call    0 returned 1
        1: 2234:        glEnableVertexAttribArray(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_TEXCOORD01]);
call    0 returned 1
        1: 2235:        glVertexAttribPointer(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_TEXCOORD01], 2, GL_FLOAT, 0, 0, 0);
call    0 returned 1
        -: 2236:
        -: 2237:        // Vertex color buffer (shader-location = 3)
        1: 2238:        glGenBuffers(1, &batch.vertexBuffer[i].vboId[2]);
call    0 returned 1
        1: 2239:        glBindBuffer(GL_ARRAY_BUFFER, batch.vertexBuffer[i].vboId[2]);
call    0 returned 1
        1: 2240:        glBufferData(GL_ARRAY_BUFFER, bufferElements*4*4*sizeof(unsigned char), batch.vertexBuffer[i].colors, GL_DYNAMIC_DRAW);
call    0 returned 1
        1: 2241:        glEnableVertexAttribArray(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_COLOR]);
call    0 returned 1
        1: 2242:        glVertexAttribPointer(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_COLOR], 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, 0);
call    0 returned 1
        -: 2243:
        -: 2244:        // Fill index buffer
        1: 2245:        glGenBuffers(1, &batch.vertexBuffer[i].vboId[3]);
call    0 returned 1
        1: 2246:        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, batch.vertexBuffer[i].vboId[3]);
call    0 returned 1
        -: 2247:#if defined(GRAPHICS_API_OPENGL_33)
        1: 2248:        glBufferData(GL_ELEMENT_ARRAY_BUFFER, bufferElements*6*sizeof(int), batch.vertexBuffer[i].indices, GL_STATIC_DRAW);
call    0 returned 1
        -: 2249:#endif
        -: 2250:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 2251:        glBufferData(GL_ELEMENT_ARRAY_BUFFER, bufferElements*6*sizeof(short), batch.vertexBuffer[i].indices, GL_STATIC_DRAW);
        -: 2252:#endif
        -: 2253:    }
        -: 2254:
        1: 2255:    TRACELOG(RL_LOG_INFO, "RLGL: Render batch vertex buffers loaded successfully in VRAM (GPU)");
        1: 2255-block  0
call    0 returned 1
        -: 2256:
        -: 2257:    // Unbind the current VAO
        1: 2258:    if (RLGL.ExtSupported.vao) glBindVertexArray(0);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2258-block  0
call    2 returned 1
        -: 2259:    //--------------------------------------------------------------------------------------------
        -: 2260:
        -: 2261:    // Init draw calls tracking system
        -: 2262:    //--------------------------------------------------------------------------------------------
        1: 2263:    batch.draws = (rlDrawCall *)RL_MALLOC(RL_DEFAULT_BATCH_DRAWCALLS*sizeof(rlDrawCall));
        -: 2264:
      257: 2265:    for (int i = 0; i < RL_DEFAULT_BATCH_DRAWCALLS; i++)
        1: 2265-block  0
      257: 2265-block  1
branch  0 taken 256
branch  1 taken 1 (fallthrough)
        -: 2266:    {
      256: 2267:        batch.draws[i].mode = RL_QUADS;
      256: 2268:        batch.draws[i].vertexCount = 0;
      256: 2269:        batch.draws[i].vertexAlignment = 0;
        -: 2270:        //batch.draws[i].vaoId = 0;
        -: 2271:        //batch.draws[i].shaderId = 0;
      256: 2272:        batch.draws[i].textureId = RLGL.State.defaultTextureId;
      256: 2272-block  0
        -: 2273:        //batch.draws[i].RLGL.State.projection = rlMatrixIdentity();
        -: 2274:        //batch.draws[i].RLGL.State.modelview = rlMatrixIdentity();
        -: 2275:    }
        -: 2276:
        1: 2277:    batch.bufferCount = numBuffers;    // Record buffer count
        1: 2278:    batch.drawCounter = 1;             // Reset draws counter
        1: 2279:    batch.currentDepth = -1.0f;         // Reset depth value
        -: 2280:    //--------------------------------------------------------------------------------------------
        -: 2281:#endif
        -: 2282:
        1: 2283:    return batch;
        1: 2283-block  0
        -: 2284:}
        -: 2285:
        -: 2286:// Unload default internal buffers vertex data from CPU and GPU
function rlUnloadRenderBatch called 1 returned 100% blocks executed 100%
        1: 2287:void rlUnloadRenderBatch(rlRenderBatch batch)
        -: 2288:{
        -: 2289:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 2290:    // Unbind everything
        1: 2291:    if (RLGL.ExtSupported.vao) glBindVertexArray(0);
        1: 2291-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2291-block  1
call    2 returned 1
        1: 2292:    glDisableVertexAttribArray(0);
        1: 2292-block  0
call    0 returned 1
        1: 2293:    glDisableVertexAttribArray(1);
call    0 returned 1
        1: 2294:    glDisableVertexAttribArray(2);
call    0 returned 1
        1: 2295:    glDisableVertexAttribArray(3);
call    0 returned 1
        1: 2296:    glBindBuffer(GL_ARRAY_BUFFER, 0);
call    0 returned 1
        1: 2297:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
call    0 returned 1
        -: 2298:
        -: 2299:    // Unload all vertex buffers data
        2: 2300:    for (int i = 0; i < batch.bufferCount; i++)
        2: 2300-block  0
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -: 2301:    {
        -: 2302:        // Delete VBOs from GPU (VRAM)
        1: 2303:        glDeleteBuffers(1, &batch.vertexBuffer[i].vboId[0]);
        1: 2303-block  0
call    0 returned 1
        1: 2304:        glDeleteBuffers(1, &batch.vertexBuffer[i].vboId[1]);
call    0 returned 1
        1: 2305:        glDeleteBuffers(1, &batch.vertexBuffer[i].vboId[2]);
call    0 returned 1
        1: 2306:        glDeleteBuffers(1, &batch.vertexBuffer[i].vboId[3]);
call    0 returned 1
        -: 2307:
        -: 2308:        // Delete VAOs from GPU (VRAM)
        1: 2309:        if (RLGL.ExtSupported.vao) glDeleteVertexArrays(1, &batch.vertexBuffer[i].vaoId);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2309-block  0
call    2 returned 1
        -: 2310:
        -: 2311:        // Free vertex arrays memory from CPU (RAM)
        1: 2312:        RL_FREE(batch.vertexBuffer[i].vertices);
        1: 2313:        RL_FREE(batch.vertexBuffer[i].texcoords);
        1: 2314:        RL_FREE(batch.vertexBuffer[i].colors);
        1: 2315:        RL_FREE(batch.vertexBuffer[i].indices);
        1: 2315-block  0
        -: 2316:    }
        -: 2317:
        -: 2318:    // Unload arrays
        1: 2319:    RL_FREE(batch.vertexBuffer);
        1: 2320:    RL_FREE(batch.draws);
        -: 2321:#endif
        1: 2322:}
        -: 2323:
        -: 2324:// Draw render batch
        -: 2325:// NOTE: We require a pointer to reset batch and increase current buffer (multi-buffer)
function rlDrawRenderBatch called 104 returned 100% blocks executed 72%
      104: 2326:void rlDrawRenderBatch(rlRenderBatch *batch)
        -: 2327:{
        -: 2328:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 2329:    // Update batch vertex buffers
        -: 2330:    //------------------------------------------------------------------------------------------------------------
        -: 2331:    // NOTE: If there is not vertex data, buffers doesn't need to be updated (vertexCount > 0)
        -: 2332:    // TODO: If no data changed on the CPU arrays --> No need to re-update GPU arrays (change flag required)
      104: 2333:    if (batch->vertexBuffer[batch->currentBuffer].vCounter > 0)
      104: 2333-block  0
branch  0 taken 104 (fallthrough)
branch  1 taken 0
        -: 2334:    {
        -: 2335:        // Activate elements VAO
      104: 2336:        if (RLGL.ExtSupported.vao) glBindVertexArray(batch->vertexBuffer[batch->currentBuffer].vaoId);
      104: 2336-block  0
branch  0 taken 104 (fallthrough)
branch  1 taken 0
      104: 2336-block  1
call    2 returned 104
        -: 2337:
        -: 2338:        // Vertex positions buffer
      104: 2339:        glBindBuffer(GL_ARRAY_BUFFER, batch->vertexBuffer[batch->currentBuffer].vboId[0]);
      104: 2339-block  0
call    0 returned 104
      104: 2340:        glBufferSubData(GL_ARRAY_BUFFER, 0, batch->vertexBuffer[batch->currentBuffer].vCounter*3*sizeof(float), batch->vertexBuffer[batch->currentBuffer].vertices);
call    0 returned 104
        -: 2341:        //glBufferData(GL_ARRAY_BUFFER, sizeof(float)*3*4*batch->vertexBuffer[batch->currentBuffer].elementCount, batch->vertexBuffer[batch->currentBuffer].vertices, GL_DYNAMIC_DRAW);  // Update all buffer
        -: 2342:
        -: 2343:        // Texture coordinates buffer
      104: 2344:        glBindBuffer(GL_ARRAY_BUFFER, batch->vertexBuffer[batch->currentBuffer].vboId[1]);
call    0 returned 104
      104: 2345:        glBufferSubData(GL_ARRAY_BUFFER, 0, batch->vertexBuffer[batch->currentBuffer].vCounter*2*sizeof(float), batch->vertexBuffer[batch->currentBuffer].texcoords);
call    0 returned 104
        -: 2346:        //glBufferData(GL_ARRAY_BUFFER, sizeof(float)*2*4*batch->vertexBuffer[batch->currentBuffer].elementCount, batch->vertexBuffer[batch->currentBuffer].texcoords, GL_DYNAMIC_DRAW); // Update all buffer
        -: 2347:
        -: 2348:        // Colors buffer
      104: 2349:        glBindBuffer(GL_ARRAY_BUFFER, batch->vertexBuffer[batch->currentBuffer].vboId[2]);
call    0 returned 104
      104: 2350:        glBufferSubData(GL_ARRAY_BUFFER, 0, batch->vertexBuffer[batch->currentBuffer].vCounter*4*sizeof(unsigned char), batch->vertexBuffer[batch->currentBuffer].colors);
call    0 returned 104
        -: 2351:        //glBufferData(GL_ARRAY_BUFFER, sizeof(float)*4*4*batch->vertexBuffer[batch->currentBuffer].elementCount, batch->vertexBuffer[batch->currentBuffer].colors, GL_DYNAMIC_DRAW);    // Update all buffer
        -: 2352:
        -: 2353:        // NOTE: glMapBuffer() causes sync issue.
        -: 2354:        // If GPU is working with this buffer, glMapBuffer() will wait(stall) until GPU to finish its job.
        -: 2355:        // To avoid waiting (idle), you can call first glBufferData() with NULL pointer before glMapBuffer().
        -: 2356:        // If you do that, the previous data in PBO will be discarded and glMapBuffer() returns a new
        -: 2357:        // allocated pointer immediately even if GPU is still working with the previous data.
        -: 2358:
        -: 2359:        // Another option: map the buffer object into client's memory
        -: 2360:        // Probably this code could be moved somewhere else...
        -: 2361:        // batch->vertexBuffer[batch->currentBuffer].vertices = (float *)glMapBuffer(GL_ARRAY_BUFFER, GL_READ_WRITE);
        -: 2362:        // if (batch->vertexBuffer[batch->currentBuffer].vertices)
        -: 2363:        // {
        -: 2364:            // Update vertex data
        -: 2365:        // }
        -: 2366:        // glUnmapBuffer(GL_ARRAY_BUFFER);
        -: 2367:
        -: 2368:        // Unbind the current VAO
      104: 2369:        if (RLGL.ExtSupported.vao) glBindVertexArray(0);
branch  0 taken 104 (fallthrough)
branch  1 taken 0
      104: 2369-block  0
call    2 returned 104
        -: 2370:    }
        -: 2371:    //------------------------------------------------------------------------------------------------------------
        -: 2372:
        -: 2373:    // Draw batch vertex buffers (considering VR stereo if required)
        -: 2374:    //------------------------------------------------------------------------------------------------------------
      104: 2375:    Matrix matProjection = RLGL.State.projection;
      104: 2376:    Matrix matModelView = RLGL.State.modelview;
        -: 2377:
      104: 2378:    int eyeCount = 1;
     104*: 2379:    if (RLGL.State.stereoRender) eyeCount = 2;
      104: 2379-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 104
    %%%%%: 2379-block  1
        -: 2380:
      208: 2381:    for (int eye = 0; eye < eyeCount; eye++)
      104: 2381-block  0
      208: 2381-block  1
branch  0 taken 104
branch  1 taken 104 (fallthrough)
        -: 2382:    {
      104: 2383:        if (eyeCount == 2)
      104: 2383-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 104
        -: 2384:        {
        -: 2385:            // Setup current eye viewport (half screen width)
    #####: 2386:            rlViewport(eye*RLGL.State.framebufferWidth/2, 0, RLGL.State.framebufferWidth/2, RLGL.State.framebufferHeight);
    %%%%%: 2386-block  0
call    0 never executed
        -: 2387:
        -: 2388:            // Set current eye view offset to modelview matrix
    #####: 2389:            rlSetMatrixModelview(rlMatrixMultiply(matModelView, RLGL.State.viewOffsetStereo[eye]));
call    0 never executed
call    1 never executed
        -: 2390:            // Set current eye projection matrix
    #####: 2391:            rlSetMatrixProjection(RLGL.State.projectionStereo[eye]);
call    0 never executed
        -: 2392:        }
        -: 2393:
        -: 2394:        // Draw buffers
      104: 2395:        if (batch->vertexBuffer[batch->currentBuffer].vCounter > 0)
      104: 2395-block  0
branch  0 taken 104 (fallthrough)
branch  1 taken 0
        -: 2396:        {
        -: 2397:            // Set current shader and upload current MVP matrix
      104: 2398:            glUseProgram(RLGL.State.currentShaderId);
      104: 2398-block  0
call    0 returned 104
        -: 2399:
        -: 2400:            // Create modelview-projection matrix and upload to shader
      104: 2401:            Matrix matMVP = rlMatrixMultiply(RLGL.State.modelview, RLGL.State.projection);
call    0 returned 104
      104: 2402:            float matMVPfloat[16] = {
      104: 2403:                matMVP.m0, matMVP.m1, matMVP.m2, matMVP.m3,
      104: 2404:                matMVP.m4, matMVP.m5, matMVP.m6, matMVP.m7,
      104: 2405:                matMVP.m8, matMVP.m9, matMVP.m10, matMVP.m11,
      104: 2406:                matMVP.m12, matMVP.m13, matMVP.m14, matMVP.m15
        -: 2407:            };
      104: 2408:            glUniformMatrix4fv(RLGL.State.currentShaderLocs[RL_SHADER_LOC_MATRIX_MVP], 1, false, matMVPfloat);
call    0 returned 104
        -: 2409:
      104: 2410:            if (RLGL.ExtSupported.vao) glBindVertexArray(batch->vertexBuffer[batch->currentBuffer].vaoId);
branch  0 taken 104 (fallthrough)
branch  1 taken 0
      104: 2410-block  0
call    2 returned 104
        -: 2411:            else
        -: 2412:            {
        -: 2413:                // Bind vertex attrib: position (shader-location = 0)
    #####: 2414:                glBindBuffer(GL_ARRAY_BUFFER, batch->vertexBuffer[batch->currentBuffer].vboId[0]);
    %%%%%: 2414-block  0
call    0 never executed
    #####: 2415:                glVertexAttribPointer(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_POSITION], 3, GL_FLOAT, 0, 0, 0);
call    0 never executed
    #####: 2416:                glEnableVertexAttribArray(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_POSITION]);
call    0 never executed
        -: 2417:
        -: 2418:                // Bind vertex attrib: texcoord (shader-location = 1)
    #####: 2419:                glBindBuffer(GL_ARRAY_BUFFER, batch->vertexBuffer[batch->currentBuffer].vboId[1]);
call    0 never executed
    #####: 2420:                glVertexAttribPointer(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_TEXCOORD01], 2, GL_FLOAT, 0, 0, 0);
call    0 never executed
    #####: 2421:                glEnableVertexAttribArray(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_TEXCOORD01]);
call    0 never executed
        -: 2422:
        -: 2423:                // Bind vertex attrib: color (shader-location = 3)
    #####: 2424:                glBindBuffer(GL_ARRAY_BUFFER, batch->vertexBuffer[batch->currentBuffer].vboId[2]);
call    0 never executed
    #####: 2425:                glVertexAttribPointer(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_COLOR], 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, 0);
call    0 never executed
    #####: 2426:                glEnableVertexAttribArray(RLGL.State.currentShaderLocs[RL_SHADER_LOC_VERTEX_COLOR]);
call    0 never executed
        -: 2427:
    #####: 2428:                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, batch->vertexBuffer[batch->currentBuffer].vboId[3]);
call    0 never executed
        -: 2429:            }
        -: 2430:
        -: 2431:            // Setup some default shader values
      104: 2432:            glUniform4f(RLGL.State.currentShaderLocs[RL_SHADER_LOC_COLOR_DIFFUSE], 1.0f, 1.0f, 1.0f, 1.0f);
      104: 2432-block  0
call    0 returned 104
      104: 2433:            glUniform1i(RLGL.State.currentShaderLocs[RL_SHADER_LOC_MAP_DIFFUSE], 0);  // Active default sampler2D: texture0
call    0 returned 104
        -: 2434:
        -: 2435:            // Activate additional sampler textures
        -: 2436:            // Those additional textures will be common for all draw calls of the batch
      520: 2437:            for (int i = 0; i < RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS; i++)
      416: 2437-block  0
      520: 2437-block  1
branch  0 taken 416
branch  1 taken 104 (fallthrough)
        -: 2438:            {
      416: 2439:                if (RLGL.State.activeTextureId[i] > 0)
      416: 2439-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 416
        -: 2440:                {
    #####: 2441:                    glActiveTexture(GL_TEXTURE0 + 1 + i);
    %%%%%: 2441-block  0
call    0 never executed
    #####: 2442:                    glBindTexture(GL_TEXTURE_2D, RLGL.State.activeTextureId[i]);
call    0 never executed
        -: 2443:                }
        -: 2444:            }
        -: 2445:
        -: 2446:            // Activate default sampler2D texture0 (one texture is always active for default batch shader)
        -: 2447:            // NOTE: Batch system accumulates calls by texture0 changes, additional textures are enabled for all the draw calls
      104: 2448:            glActiveTexture(GL_TEXTURE0);
      104: 2448-block  0
call    0 returned 104
        -: 2449:
      208: 2450:            for (int i = 0, vertexOffset = 0; i < batch->drawCounter; i++)
      208: 2450-block  0
branch  0 taken 104
branch  1 taken 104 (fallthrough)
        -: 2451:            {
        -: 2452:                // Bind current draw call texture, activated as GL_TEXTURE0 and binded to sampler2D texture0 by default
      104: 2453:                glBindTexture(GL_TEXTURE_2D, batch->draws[i].textureId);
      104: 2453-block  0
call    0 returned 104
        -: 2454:
     104*: 2455:                if ((batch->draws[i].mode == RL_LINES) || (batch->draws[i].mode == RL_TRIANGLES)) glDrawArrays(batch->draws[i].mode, vertexOffset, batch->draws[i].vertexCount);
branch  0 taken 104 (fallthrough)
branch  1 taken 0
      104: 2455-block  0
branch  2 taken 0 (fallthrough)
branch  3 taken 104
    %%%%%: 2455-block  1
call    4 never executed
        -: 2456:                else
        -: 2457:                {
        -: 2458:#if defined(GRAPHICS_API_OPENGL_33)
        -: 2459:                    // We need to define the number of indices to be processed: elementCount*6
        -: 2460:                    // NOTE: The final parameter tells the GPU the offset in bytes from the
        -: 2461:                    // start of the index buffer to the location of the first index to process
      104: 2462:                    glDrawElements(GL_TRIANGLES, batch->draws[i].vertexCount/4*6, GL_UNSIGNED_INT, (GLvoid *)(vertexOffset/4*6*sizeof(GLuint)));
      104: 2462-block  0
call    0 returned 104
        -: 2463:#endif
        -: 2464:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 2465:                    glDrawElements(GL_TRIANGLES, batch->draws[i].vertexCount/4*6, GL_UNSIGNED_SHORT, (GLvoid *)(vertexOffset/4*6*sizeof(GLushort)));
        -: 2466:#endif
        -: 2467:                }
        -: 2468:
      104: 2469:                vertexOffset += (batch->draws[i].vertexCount + batch->draws[i].vertexAlignment);
      104: 2469-block  0
        -: 2470:            }
        -: 2471:
      104: 2472:            if (!RLGL.ExtSupported.vao)
      104: 2472-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 104
        -: 2473:            {
    #####: 2474:                glBindBuffer(GL_ARRAY_BUFFER, 0);
    %%%%%: 2474-block  0
call    0 never executed
    #####: 2475:                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
call    0 never executed
        -: 2476:            }
        -: 2477:
      104: 2478:            glBindTexture(GL_TEXTURE_2D, 0);    // Unbind textures
      104: 2478-block  0
call    0 returned 104
        -: 2479:        }
        -: 2480:
      104: 2481:        if (RLGL.ExtSupported.vao) glBindVertexArray(0); // Unbind VAO
      104: 2481-block  0
branch  0 taken 104 (fallthrough)
branch  1 taken 0
      104: 2481-block  1
call    2 returned 104
        -: 2482:
      104: 2483:        glUseProgram(0);    // Unbind shader program
      104: 2483-block  0
call    0 returned 104
        -: 2484:    }
        -: 2485:    //------------------------------------------------------------------------------------------------------------
        -: 2486:
        -: 2487:    // Reset batch buffers
        -: 2488:    //------------------------------------------------------------------------------------------------------------
        -: 2489:    // Reset vertex counters for next frame
      104: 2490:    batch->vertexBuffer[batch->currentBuffer].vCounter = 0;
      104: 2491:    batch->vertexBuffer[batch->currentBuffer].tcCounter = 0;
      104: 2492:    batch->vertexBuffer[batch->currentBuffer].cCounter = 0;
        -: 2493:
        -: 2494:    // Reset depth for next draw
      104: 2495:    batch->currentDepth = -1.0f;
        -: 2496:
        -: 2497:    // Restore projection/modelview matrices
      104: 2498:    RLGL.State.projection = matProjection;
      104: 2499:    RLGL.State.modelview = matModelView;
        -: 2500:
        -: 2501:    // Reset RLGL.currentBatch->draws array
    26728: 2502:    for (int i = 0; i < RL_DEFAULT_BATCH_DRAWCALLS; i++)
      104: 2502-block  0
    26728: 2502-block  1
branch  0 taken 26624
branch  1 taken 104 (fallthrough)
        -: 2503:    {
    26624: 2504:        batch->draws[i].mode = RL_QUADS;
    26624: 2505:        batch->draws[i].vertexCount = 0;
    26624: 2506:        batch->draws[i].textureId = RLGL.State.defaultTextureId;
    26624: 2506-block  0
        -: 2507:    }
        -: 2508:
        -: 2509:    // Reset active texture units for next batch
      520: 2510:    for (int i = 0; i < RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS; i++) RLGL.State.activeTextureId[i] = 0;
      104: 2510-block  0
      416: 2510-block  1
      520: 2510-block  2
branch  0 taken 416
branch  1 taken 104 (fallthrough)
        -: 2511:
        -: 2512:    // Reset draws counter to one draw for the batch
      104: 2513:    batch->drawCounter = 1;
        -: 2514:    //------------------------------------------------------------------------------------------------------------
        -: 2515:
        -: 2516:    // Change to next buffer in the list (in case of multi-buffering)
      104: 2517:    batch->currentBuffer++;
      104: 2518:    if (batch->currentBuffer >= batch->bufferCount) batch->currentBuffer = 0;
      104: 2518-block  0
branch  0 taken 104 (fallthrough)
branch  1 taken 0
      104: 2518-block  1
        -: 2519:#endif
      104: 2520:}
        -: 2521:
        -: 2522:// Set the active render batch for rlgl
function rlSetRenderBatchActive called 0 returned 0% blocks executed 0%
    #####: 2523:void rlSetRenderBatchActive(rlRenderBatch *batch)
        -: 2524:{
        -: 2525:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2526:    rlDrawRenderBatch(RLGL.currentBatch);
    %%%%%: 2526-block  0
call    0 never executed
        -: 2527:
    #####: 2528:    if (batch != NULL) RLGL.currentBatch = batch;
branch  0 never executed
branch  1 never executed
    %%%%%: 2528-block  0
    #####: 2529:    else RLGL.currentBatch = &RLGL.defaultBatch;
    %%%%%: 2529-block  0
        -: 2530:#endif
    #####: 2531:}
        -: 2532:
        -: 2533:// Update and draw internal render batch
function rlDrawRenderBatchActive called 104 returned 100% blocks executed 100%
      104: 2534:void rlDrawRenderBatchActive(void)
        -: 2535:{
        -: 2536:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
      104: 2537:    rlDrawRenderBatch(RLGL.currentBatch);    // NOTE: Stereo rendering is checked inside
      104: 2537-block  0
call    0 returned 104
        -: 2538:#endif
      104: 2539:}
        -: 2540:
        -: 2541:// Check internal buffer overflow for a given number of vertex
        -: 2542:// and force a rlRenderBatch draw call if required
function rlCheckRenderBatchLimit called 728 returned 100% blocks executed 75%
      728: 2543:bool rlCheckRenderBatchLimit(int vCount)
        -: 2544:{
      728: 2545:    bool overflow = false;
        -: 2546:
        -: 2547:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
      728: 2548:    if ((RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].vCounter + vCount) >=
      728: 2549:        (RLGL.currentBatch->vertexBuffer[RLGL.currentBatch->currentBuffer].elementCount*4))
      728: 2549-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 728
        -: 2550:    {
    #####: 2551:        overflow = true;
    #####: 2552:        rlDrawRenderBatch(RLGL.currentBatch);    // NOTE: Stereo rendering is checked inside
    %%%%%: 2552-block  0
call    0 never executed
        -: 2553:    }
        -: 2554:#endif
        -: 2555:
      728: 2556:    return overflow;
      728: 2556-block  0
        -: 2557:}
        -: 2558:
        -: 2559:// Textures data management
        -: 2560://-----------------------------------------------------------------------------------------
        -: 2561:// Convert image data to OpenGL texture (returns OpenGL valid Id)
function rlLoadTexture called 2 returned 100% blocks executed 66%
        2: 2562:unsigned int rlLoadTexture(void *data, int width, int height, int format, int mipmapCount)
        -: 2563:{
        2: 2564:    glBindTexture(GL_TEXTURE_2D, 0);    // Free any old binding
        2: 2564-block  0
call    0 returned 2
        -: 2565:
        2: 2566:    unsigned int id = 0;
        -: 2567:
        -: 2568:    // Check texture format support by OpenGL 1.1 (compressed textures not supported)
        -: 2569:#if defined(GRAPHICS_API_OPENGL_11)
        -: 2570:    if (format >= RL_PIXELFORMAT_COMPRESSED_DXT1_RGB)
        -: 2571:    {
        -: 2572:        TRACELOG(RL_LOG_WARNING, "GL: OpenGL 1.1 does not support GPU compressed texture formats");
        -: 2573:        return id;
        -: 2574:    }
        -: 2575:#else
       2*: 2576:    if ((!RLGL.ExtSupported.texCompDXT) && ((format == RL_PIXELFORMAT_COMPRESSED_DXT1_RGB) || (format == RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA) ||
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%: 2576-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 2576-block  1
branch  4 never executed
branch  5 never executed
    %%%%%: 2576-block  2
branch  6 never executed
branch  7 never executed
    #####: 2577:        (format == RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA) || (format == RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA)))
    %%%%%: 2577-block  0
branch  0 never executed
branch  1 never executed
        -: 2578:    {
    #####: 2579:        TRACELOG(RL_LOG_WARNING, "GL: DXT compressed texture format not supported");
    %%%%%: 2579-block  0
call    0 never executed
    #####: 2580:        return id;
        -: 2581:    }
        -: 2582:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        2: 2583:    if ((!RLGL.ExtSupported.texCompETC1) && (format == RL_PIXELFORMAT_COMPRESSED_ETC1_RGB))
        2: 2583-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2583-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        -: 2584:    {
    #####: 2585:        TRACELOG(RL_LOG_WARNING, "GL: ETC1 compressed texture format not supported");
    %%%%%: 2585-block  0
call    0 never executed
    #####: 2586:        return id;
        -: 2587:    }
        -: 2588:
       2*: 2589:    if ((!RLGL.ExtSupported.texCompETC2) && ((format == RL_PIXELFORMAT_COMPRESSED_ETC2_RGB) || (format == RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA)))
        2: 2589-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%: 2589-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2589-block  2
branch  4 never executed
branch  5 never executed
        -: 2590:    {
    #####: 2591:        TRACELOG(RL_LOG_WARNING, "GL: ETC2 compressed texture format not supported");
    %%%%%: 2591-block  0
call    0 never executed
    #####: 2592:        return id;
        -: 2593:    }
        -: 2594:
        2: 2595:    if ((!RLGL.ExtSupported.texCompPVRT) && ((format == RL_PIXELFORMAT_COMPRESSED_PVRT_RGB) || (format == RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA)))
        2: 2595-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2595-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2595-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
        -: 2596:    {
    #####: 2597:        TRACELOG(RL_LOG_WARNING, "GL: PVRT compressed texture format not supported");
    %%%%%: 2597-block  0
call    0 never executed
    #####: 2598:        return id;
        -: 2599:    }
        -: 2600:
        2: 2601:    if ((!RLGL.ExtSupported.texCompASTC) && ((format == RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA) || (format == RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA)))
        2: 2601-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2601-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2601-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
        -: 2602:    {
    #####: 2603:        TRACELOG(RL_LOG_WARNING, "GL: ASTC compressed texture format not supported");
    %%%%%: 2603-block  0
call    0 never executed
    #####: 2604:        return id;
        -: 2605:    }
        -: 2606:#endif
        -: 2607:#endif  // GRAPHICS_API_OPENGL_11
        -: 2608:
        2: 2609:    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        2: 2609-block  0
call    0 returned 2
        -: 2610:
        2: 2611:    glGenTextures(1, &id);              // Generate texture id
call    0 returned 2
        -: 2612:
        2: 2613:    glBindTexture(GL_TEXTURE_2D, id);
call    0 returned 2
        -: 2614:
        2: 2615:    int mipWidth = width;
        2: 2616:    int mipHeight = height;
        2: 2617:    int mipOffset = 0;          // Mipmap data offset
        -: 2618:
        -: 2619:    // Load the different mipmap levels
        4: 2620:    for (int i = 0; i < mipmapCount; i++)
        2: 2620-block  0
        4: 2620-block  1
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        -: 2621:    {
        2: 2622:        unsigned int mipSize = rlGetPixelDataSize(mipWidth, mipHeight, format);
        2: 2622-block  0
call    0 returned 2
        -: 2623:
        -: 2624:        unsigned int glInternalFormat, glFormat, glType;
        2: 2625:        rlGetGlTextureFormats(format, &glInternalFormat, &glFormat, &glType);
call    0 returned 2
        -: 2626:
        -: 2627:        TRACELOGD("TEXTURE: Load mipmap level %i (%i x %i), size: %i, offset: %i", i, mipWidth, mipHeight, mipSize, mipOffset);
        -: 2628:
        2: 2629:        if (glInternalFormat != -1)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 2630:        {
        2: 2631:            if (format < RL_PIXELFORMAT_COMPRESSED_DXT1_RGB) glTexImage2D(GL_TEXTURE_2D, i, glInternalFormat, mipWidth, mipHeight, 0, glFormat, glType, (unsigned char *)data + mipOffset);
        2: 2631-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2631-block  1
call    2 returned 2
        -: 2632:#if !defined(GRAPHICS_API_OPENGL_11)
    #####: 2633:            else glCompressedTexImage2D(GL_TEXTURE_2D, i, glInternalFormat, mipWidth, mipHeight, 0, mipSize, (unsigned char *)data + mipOffset);
    %%%%%: 2633-block  0
call    0 never executed
        -: 2634:#endif
        -: 2635:
        -: 2636:#if defined(GRAPHICS_API_OPENGL_33)
        2: 2637:            if (format == RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE)
        2: 2637-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 2638:            {
    #####: 2639:                GLint swizzleMask[] = { GL_RED, GL_RED, GL_RED, GL_ONE };
    #####: 2640:                glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzleMask);
    %%%%%: 2640-block  0
call    0 never executed
        -: 2641:            }
        2: 2642:            else if (format == RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA)
        2: 2642-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 2643:            {
        -: 2644:#if defined(GRAPHICS_API_OPENGL_21)
        -: 2645:                GLint swizzleMask[] = { GL_RED, GL_RED, GL_RED, GL_ALPHA };
        -: 2646:#elif defined(GRAPHICS_API_OPENGL_33)
        1: 2647:                GLint swizzleMask[] = { GL_RED, GL_RED, GL_RED, GL_GREEN };
        -: 2648:#endif
        1: 2649:                glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzleMask);
        1: 2649-block  0
call    0 returned 1
        -: 2650:            }
        -: 2651:#endif
        -: 2652:        }
        -: 2653:
        2: 2654:        mipWidth /= 2;
        2: 2655:        mipHeight /= 2;
        2: 2656:        mipOffset += mipSize;
        -: 2657:
        -: 2658:        // Security check for NPOT textures
        2: 2659:        if (mipWidth < 1) mipWidth = 1;
        2: 2659-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 2659-block  1
        2: 2660:        if (mipHeight < 1) mipHeight = 1;
        2: 2660-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 2660-block  1
        -: 2661:    }
        -: 2662:
        -: 2663:    // Texture parameters configuration
        -: 2664:    // NOTE: glTexParameteri does NOT affect texture uploading, just the way it's used
        -: 2665:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 2666:    // NOTE: OpenGL ES 2.0 with no GL_OES_texture_npot support (i.e. WebGL) has limited NPOT support, so CLAMP_TO_EDGE must be used
        -: 2667:    if (RLGL.ExtSupported.texNPOT)
        -: 2668:    {
        -: 2669:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);       // Set texture to repeat on x-axis
        -: 2670:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);       // Set texture to repeat on y-axis
        -: 2671:    }
        -: 2672:    else
        -: 2673:    {
        -: 2674:        // NOTE: If using negative texture coordinates (LoadOBJ()), it does not work!
        -: 2675:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);       // Set texture to clamp on x-axis
        -: 2676:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);       // Set texture to clamp on y-axis
        -: 2677:    }
        -: 2678:#else
        2: 2679:    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);       // Set texture to repeat on x-axis
        2: 2679-block  0
call    0 returned 2
        2: 2680:    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);       // Set texture to repeat on y-axis
call    0 returned 2
        -: 2681:#endif
        -: 2682:
        -: 2683:    // Magnification and minification filters
        2: 2684:    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);  // Alternative: GL_LINEAR
call    0 returned 2
        2: 2685:    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);  // Alternative: GL_LINEAR
call    0 returned 2
        -: 2686:
        -: 2687:#if defined(GRAPHICS_API_OPENGL_33)
        2: 2688:    if (mipmapCount > 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 2689:    {
        -: 2690:        // Activate Trilinear filtering if mipmaps are available
    #####: 2691:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    %%%%%: 2691-block  0
call    0 never executed
    #####: 2692:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
call    0 never executed
        -: 2693:    }
        -: 2694:#endif
        -: 2695:
        -: 2696:    // At this point we have the texture loaded in GPU and texture parameters configured
        -: 2697:
        -: 2698:    // NOTE: If mipmaps were not in data, they are not generated automatically
        -: 2699:
        -: 2700:    // Unbind current texture
        2: 2701:    glBindTexture(GL_TEXTURE_2D, 0);
        2: 2701-block  0
call    0 returned 2
        -: 2702:
        2: 2703:    if (id > 0) TRACELOG(RL_LOG_INFO, "TEXTURE: [ID %i] Texture loaded successfully (%ix%i | %s | %i mipmaps)", id, width, height, rlGetPixelFormatName(format), mipmapCount);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2703-block  0
call    2 returned 2
call    3 returned 2
    #####: 2704:    else TRACELOG(RL_LOG_WARNING, "TEXTURE: Failed to load texture");
    %%%%%: 2704-block  0
call    0 never executed
        -: 2705:
        2: 2706:    return id;
        2: 2706-block  0
        -: 2707:}
        -: 2708:
        -: 2709:// Load depth texture/renderbuffer (to be attached to fbo)
        -: 2710:// WARNING: OpenGL ES 2.0 requires GL_OES_depth_texture/WEBGL_depth_texture extensions
function rlLoadTextureDepth called 0 returned 0% blocks executed 0%
    #####: 2711:unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
        -: 2712:{
    #####: 2713:    unsigned int id = 0;
        -: 2714:
        -: 2715:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 2716:    // In case depth textures not supported, we force renderbuffer usage
    #####: 2717:    if (!RLGL.ExtSupported.texDepth) useRenderBuffer = true;
    %%%%%: 2717-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2717-block  1
        -: 2718:
        -: 2719:    // NOTE: We let the implementation to choose the best bit-depth
        -: 2720:    // Possible formats: GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32 and GL_DEPTH_COMPONENT32F
    #####: 2721:    unsigned int glInternalFormat = GL_DEPTH_COMPONENT;
        -: 2722:
        -: 2723:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 2724:    if (RLGL.ExtSupported.maxDepthBits == 32) glInternalFormat = GL_DEPTH_COMPONENT32_OES;
        -: 2725:    else if (RLGL.ExtSupported.maxDepthBits == 24) glInternalFormat = GL_DEPTH_COMPONENT24_OES;
        -: 2726:    else glInternalFormat = GL_DEPTH_COMPONENT16;
        -: 2727:#endif
        -: 2728:
    #####: 2729:    if (!useRenderBuffer && RLGL.ExtSupported.texDepth)
    %%%%%: 2729-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2729-block  1
branch  2 never executed
branch  3 never executed
        -: 2730:    {
    #####: 2731:        glGenTextures(1, &id);
    %%%%%: 2731-block  0
call    0 never executed
    #####: 2732:        glBindTexture(GL_TEXTURE_2D, id);
call    0 never executed
    #####: 2733:        glTexImage2D(GL_TEXTURE_2D, 0, glInternalFormat, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
call    0 never executed
        -: 2734:
    #####: 2735:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
call    0 never executed
    #####: 2736:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
call    0 never executed
    #####: 2737:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
call    0 never executed
    #####: 2738:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
call    0 never executed
        -: 2739:
    #####: 2740:        glBindTexture(GL_TEXTURE_2D, 0);
call    0 never executed
        -: 2741:
    #####: 2742:        TRACELOG(RL_LOG_INFO, "TEXTURE: Depth texture loaded successfully");
call    0 never executed
        -: 2743:    }
        -: 2744:    else
        -: 2745:    {
        -: 2746:        // Create the renderbuffer that will serve as the depth attachment for the framebuffer
        -: 2747:        // NOTE: A renderbuffer is simpler than a texture and could offer better performance on embedded devices
    #####: 2748:        glGenRenderbuffers(1, &id);
    %%%%%: 2748-block  0
call    0 never executed
    #####: 2749:        glBindRenderbuffer(GL_RENDERBUFFER, id);
call    0 never executed
    #####: 2750:        glRenderbufferStorage(GL_RENDERBUFFER, glInternalFormat, width, height);
call    0 never executed
        -: 2751:
    #####: 2752:        glBindRenderbuffer(GL_RENDERBUFFER, 0);
call    0 never executed
        -: 2753:
    #####: 2754:        TRACELOG(RL_LOG_INFO, "TEXTURE: [ID %i] Depth renderbuffer loaded successfully (%i bits)", id, (RLGL.ExtSupported.maxDepthBits >= 24)? RLGL.ExtSupported.maxDepthBits : 16);
branch  0 never executed
branch  1 never executed
    %%%%%: 2754-block  0
    %%%%%: 2754-block  1
    %%%%%: 2754-block  2
call    2 never executed
        -: 2755:    }
        -: 2756:#endif
        -: 2757:
    #####: 2758:    return id;
    %%%%%: 2758-block  0
        -: 2759:}
        -: 2760:
        -: 2761:// Load texture cubemap
        -: 2762:// NOTE: Cubemap data is expected to be 6 images in a single data array (one after the other),
        -: 2763:// expected the following convention: +X, -X, +Y, -Y, +Z, -Z
function rlLoadTextureCubemap called 0 returned 0% blocks executed 0%
    #####: 2764:unsigned int rlLoadTextureCubemap(void *data, int size, int format)
        -: 2765:{
    #####: 2766:    unsigned int id = 0;
        -: 2767:
        -: 2768:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2769:    unsigned int dataSize = rlGetPixelDataSize(size, size, format);
    %%%%%: 2769-block  0
call    0 never executed
        -: 2770:
    #####: 2771:    glGenTextures(1, &id);
call    0 never executed
    #####: 2772:    glBindTexture(GL_TEXTURE_CUBE_MAP, id);
call    0 never executed
        -: 2773:
        -: 2774:    unsigned int glInternalFormat, glFormat, glType;
    #####: 2775:    rlGetGlTextureFormats(format, &glInternalFormat, &glFormat, &glType);
call    0 never executed
        -: 2776:
    #####: 2777:    if (glInternalFormat != -1)
branch  0 never executed
branch  1 never executed
        -: 2778:    {
        -: 2779:        // Load cubemap faces
    #####: 2780:        for (unsigned int i = 0; i < 6; i++)
    %%%%%: 2780-block  0
    %%%%%: 2780-block  1
    %%%%%: 2780-block  2
branch  0 never executed
branch  1 never executed
        -: 2781:        {
    #####: 2782:            if (data == NULL)
    %%%%%: 2782-block  0
branch  0 never executed
branch  1 never executed
        -: 2783:            {
    #####: 2784:                if (format < RL_PIXELFORMAT_COMPRESSED_DXT1_RGB)
    %%%%%: 2784-block  0
branch  0 never executed
branch  1 never executed
        -: 2785:                {
    #####: 2786:                    if (format == RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32)
    %%%%%: 2786-block  0
branch  0 never executed
branch  1 never executed
        -: 2787:                    {
        -: 2788:                        // Instead of using a sized internal texture format (GL_RGB16F, GL_RGB32F), we let the driver to choose the better format for us (GL_RGB)
    #####: 2789:                        if (RLGL.ExtSupported.texFloat32) glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, size, size, 0, GL_RGB, GL_FLOAT, NULL);
    %%%%%: 2789-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2789-block  1
call    2 never executed
    #####: 2790:                        else TRACELOG(RL_LOG_WARNING, "TEXTURES: Cubemap requested format not supported");
    %%%%%: 2790-block  0
call    0 never executed
        -: 2791:                    }
    #####: 2792:                    else if ((format == RL_PIXELFORMAT_UNCOMPRESSED_R32) || (format == RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32)) TRACELOG(RL_LOG_WARNING, "TEXTURES: Cubemap requested format not supported");
    %%%%%: 2792-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2792-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2792-block  2
call    4 never executed
    #####: 2793:                    else glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, size, size, 0, glFormat, glType, NULL);
    %%%%%: 2793-block  0
call    0 never executed
        -: 2794:                }
    #####: 2795:                else TRACELOG(RL_LOG_WARNING, "TEXTURES: Empty cubemap creation does not support compressed format");
    %%%%%: 2795-block  0
call    0 never executed
        -: 2796:            }
        -: 2797:            else
        -: 2798:            {
    #####: 2799:                if (format < RL_PIXELFORMAT_COMPRESSED_DXT1_RGB) glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, size, size, 0, glFormat, glType, (unsigned char *)data + i*dataSize);
    %%%%%: 2799-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2799-block  1
call    2 never executed
    #####: 2800:                else glCompressedTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, size, size, 0, dataSize, (unsigned char *)data + i*dataSize);
    %%%%%: 2800-block  0
call    0 never executed
        -: 2801:            }
        -: 2802:
        -: 2803:#if defined(GRAPHICS_API_OPENGL_33)
    #####: 2804:            if (format == RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE)
    %%%%%: 2804-block  0
branch  0 never executed
branch  1 never executed
        -: 2805:            {
    #####: 2806:                GLint swizzleMask[] = { GL_RED, GL_RED, GL_RED, GL_ONE };
    #####: 2807:                glTexParameteriv(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_SWIZZLE_RGBA, swizzleMask);
    %%%%%: 2807-block  0
call    0 never executed
        -: 2808:            }
    #####: 2809:            else if (format == RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA)
    %%%%%: 2809-block  0
branch  0 never executed
branch  1 never executed
        -: 2810:            {
        -: 2811:#if defined(GRAPHICS_API_OPENGL_21)
        -: 2812:                GLint swizzleMask[] = { GL_RED, GL_RED, GL_RED, GL_ALPHA };
        -: 2813:#elif defined(GRAPHICS_API_OPENGL_33)
    #####: 2814:                GLint swizzleMask[] = { GL_RED, GL_RED, GL_RED, GL_GREEN };
        -: 2815:#endif
    #####: 2816:                glTexParameteriv(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_SWIZZLE_RGBA, swizzleMask);
    %%%%%: 2816-block  0
call    0 never executed
        -: 2817:            }
        -: 2818:#endif
        -: 2819:        }
        -: 2820:    }
        -: 2821:
        -: 2822:    // Set cubemap texture sampling parameters
    #####: 2823:    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    %%%%%: 2823-block  0
call    0 never executed
    #####: 2824:    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
call    0 never executed
    #####: 2825:    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
call    0 never executed
    #####: 2826:    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
call    0 never executed
        -: 2827:#if defined(GRAPHICS_API_OPENGL_33)
    #####: 2828:    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);  // Flag not supported on OpenGL ES 2.0
call    0 never executed
        -: 2829:#endif
        -: 2830:
    #####: 2831:    glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
call    0 never executed
        -: 2832:#endif
        -: 2833:
    #####: 2834:    if (id > 0) TRACELOG(RL_LOG_INFO, "TEXTURE: [ID %i] Cubemap texture loaded successfully (%ix%i)", id, size, size);
branch  0 never executed
branch  1 never executed
    %%%%%: 2834-block  0
call    2 never executed
    #####: 2835:    else TRACELOG(RL_LOG_WARNING, "TEXTURE: Failed to load cubemap texture");
    %%%%%: 2835-block  0
call    0 never executed
        -: 2836:
    #####: 2837:    return id;
    %%%%%: 2837-block  0
        -: 2838:}
        -: 2839:
        -: 2840:// Update already loaded texture in GPU with new data
        -: 2841:// NOTE: We don't know safely if internal texture format is the expected one...
function rlUpdateTexture called 0 returned 0% blocks executed 0%
    #####: 2842:void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
        -: 2843:{
    #####: 2844:    glBindTexture(GL_TEXTURE_2D, id);
    %%%%%: 2844-block  0
call    0 never executed
        -: 2845:
        -: 2846:    unsigned int glInternalFormat, glFormat, glType;
    #####: 2847:    rlGetGlTextureFormats(format, &glInternalFormat, &glFormat, &glType);
call    0 never executed
        -: 2848:
    #####: 2849:    if ((glInternalFormat != -1) && (format < RL_PIXELFORMAT_COMPRESSED_DXT1_RGB))
branch  0 never executed
branch  1 never executed
    %%%%%: 2849-block  0
branch  2 never executed
branch  3 never executed
        -: 2850:    {
    #####: 2851:        glTexSubImage2D(GL_TEXTURE_2D, 0, offsetX, offsetY, width, height, glFormat, glType, (unsigned char *)data);
    %%%%%: 2851-block  0
call    0 never executed
        -: 2852:    }
    #####: 2853:    else TRACELOG(RL_LOG_WARNING, "TEXTURE: [ID %i] Failed to update for current texture format (%i)", id, format);
    %%%%%: 2853-block  0
call    0 never executed
    #####: 2854:}
        -: 2855:
        -: 2856:// Get OpenGL internal formats and data type from raylib PixelFormat
function rlGetGlTextureFormats called 2 returned 100% blocks executed 8%
        2: 2857:void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
        -: 2858:{
        2: 2859:    *glInternalFormat = -1;
        2: 2860:    *glFormat = -1;
        2: 2861:    *glType = -1;
        -: 2862:
        2: 2863:    switch (format)
        2: 2863-block  0
branch  0 taken 0
branch  1 taken 1
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 1
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 0
branch 20 taken 0
branch 21 taken 0
        -: 2864:    {
        -: 2865:    #if defined(GRAPHICS_API_OPENGL_11) || defined(GRAPHICS_API_OPENGL_21) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 2866:        // NOTE: on OpenGL ES 2.0 (WebGL), internalFormat must match format and options allowed are: GL_LUMINANCE, GL_RGB, GL_RGBA
        -: 2867:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: *glInternalFormat = GL_LUMINANCE; *glFormat = GL_LUMINANCE; *glType = GL_UNSIGNED_BYTE; break;
        -: 2868:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: *glInternalFormat = GL_LUMINANCE_ALPHA; *glFormat = GL_LUMINANCE_ALPHA; *glType = GL_UNSIGNED_BYTE; break;
        -: 2869:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5: *glInternalFormat = GL_RGB; *glFormat = GL_RGB; *glType = GL_UNSIGNED_SHORT_5_6_5; break;
        -: 2870:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8: *glInternalFormat = GL_RGB; *glFormat = GL_RGB; *glType = GL_UNSIGNED_BYTE; break;
        -: 2871:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: *glInternalFormat = GL_RGBA; *glFormat = GL_RGBA; *glType = GL_UNSIGNED_SHORT_5_5_5_1; break;
        -: 2872:        case RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: *glInternalFormat = GL_RGBA; *glFormat = GL_RGBA; *glType = GL_UNSIGNED_SHORT_4_4_4_4; break;
        -: 2873:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: *glInternalFormat = GL_RGBA; *glFormat = GL_RGBA; *glType = GL_UNSIGNED_BYTE; break;
        -: 2874:        #if !defined(GRAPHICS_API_OPENGL_11)
        -: 2875:        case RL_PIXELFORMAT_UNCOMPRESSED_R32: if (RLGL.ExtSupported.texFloat32) *glInternalFormat = GL_LUMINANCE; *glFormat = GL_LUMINANCE; *glType = GL_FLOAT; break;   // NOTE: Requires extension OES_texture_float
        -: 2876:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32: if (RLGL.ExtSupported.texFloat32) *glInternalFormat = GL_RGB; *glFormat = GL_RGB; *glType = GL_FLOAT; break;         // NOTE: Requires extension OES_texture_float
        -: 2877:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: if (RLGL.ExtSupported.texFloat32) *glInternalFormat = GL_RGBA; *glFormat = GL_RGBA; *glType = GL_FLOAT; break;    // NOTE: Requires extension OES_texture_float
        -: 2878:        #endif
        -: 2879:    #elif defined(GRAPHICS_API_OPENGL_33)
    #####: 2880:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: *glInternalFormat = GL_R8; *glFormat = GL_RED; *glType = GL_UNSIGNED_BYTE; break;
    %%%%%: 2880-block  0
        1: 2881:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: *glInternalFormat = GL_RG8; *glFormat = GL_RG; *glType = GL_UNSIGNED_BYTE; break;
        1: 2881-block  0
    #####: 2882:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5: *glInternalFormat = GL_RGB565; *glFormat = GL_RGB; *glType = GL_UNSIGNED_SHORT_5_6_5; break;
    %%%%%: 2882-block  0
    #####: 2883:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8: *glInternalFormat = GL_RGB8; *glFormat = GL_RGB; *glType = GL_UNSIGNED_BYTE; break;
    %%%%%: 2883-block  0
    #####: 2884:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: *glInternalFormat = GL_RGB5_A1; *glFormat = GL_RGBA; *glType = GL_UNSIGNED_SHORT_5_5_5_1; break;
    %%%%%: 2884-block  0
    #####: 2885:        case RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: *glInternalFormat = GL_RGBA4; *glFormat = GL_RGBA; *glType = GL_UNSIGNED_SHORT_4_4_4_4; break;
    %%%%%: 2885-block  0
        1: 2886:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: *glInternalFormat = GL_RGBA8; *glFormat = GL_RGBA; *glType = GL_UNSIGNED_BYTE; break;
        1: 2886-block  0
    #####: 2887:        case RL_PIXELFORMAT_UNCOMPRESSED_R32: if (RLGL.ExtSupported.texFloat32) *glInternalFormat = GL_R32F; *glFormat = GL_RED; *glType = GL_FLOAT; break;
    %%%%%: 2887-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2887-block  1
    %%%%%: 2887-block  2
    #####: 2888:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32: if (RLGL.ExtSupported.texFloat32) *glInternalFormat = GL_RGB32F; *glFormat = GL_RGB; *glType = GL_FLOAT; break;
    %%%%%: 2888-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2888-block  1
    %%%%%: 2888-block  2
    #####: 2889:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: if (RLGL.ExtSupported.texFloat32) *glInternalFormat = GL_RGBA32F; *glFormat = GL_RGBA; *glType = GL_FLOAT; break;
    %%%%%: 2889-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2889-block  1
    %%%%%: 2889-block  2
        -: 2890:    #endif
        -: 2891:    #if !defined(GRAPHICS_API_OPENGL_11)
    #####: 2892:        case RL_PIXELFORMAT_COMPRESSED_DXT1_RGB: if (RLGL.ExtSupported.texCompDXT) *glInternalFormat = GL_COMPRESSED_RGB_S3TC_DXT1_EXT; break;
    %%%%%: 2892-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2892-block  1
    #####: 2893:        case RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA: if (RLGL.ExtSupported.texCompDXT) *glInternalFormat = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT; break;
    %%%%%: 2893-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2893-block  1
    #####: 2894:        case RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA: if (RLGL.ExtSupported.texCompDXT) *glInternalFormat = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT; break;
    %%%%%: 2894-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2894-block  1
    #####: 2895:        case RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA: if (RLGL.ExtSupported.texCompDXT) *glInternalFormat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT; break;
    %%%%%: 2895-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2895-block  1
    #####: 2896:        case RL_PIXELFORMAT_COMPRESSED_ETC1_RGB: if (RLGL.ExtSupported.texCompETC1) *glInternalFormat = GL_ETC1_RGB8_OES; break;                      // NOTE: Requires OpenGL ES 2.0 or OpenGL 4.3
    %%%%%: 2896-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2896-block  1
    #####: 2897:        case RL_PIXELFORMAT_COMPRESSED_ETC2_RGB: if (RLGL.ExtSupported.texCompETC2) *glInternalFormat = GL_COMPRESSED_RGB8_ETC2; break;               // NOTE: Requires OpenGL ES 3.0 or OpenGL 4.3
    %%%%%: 2897-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2897-block  1
    #####: 2898:        case RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA: if (RLGL.ExtSupported.texCompETC2) *glInternalFormat = GL_COMPRESSED_RGBA8_ETC2_EAC; break;     // NOTE: Requires OpenGL ES 3.0 or OpenGL 4.3
    %%%%%: 2898-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2898-block  1
    #####: 2899:        case RL_PIXELFORMAT_COMPRESSED_PVRT_RGB: if (RLGL.ExtSupported.texCompPVRT) *glInternalFormat = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG; break;    // NOTE: Requires PowerVR GPU
    %%%%%: 2899-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2899-block  1
    #####: 2900:        case RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA: if (RLGL.ExtSupported.texCompPVRT) *glInternalFormat = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; break;  // NOTE: Requires PowerVR GPU
    %%%%%: 2900-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2900-block  1
    #####: 2901:        case RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: if (RLGL.ExtSupported.texCompASTC) *glInternalFormat = GL_COMPRESSED_RGBA_ASTC_4x4_KHR; break;  // NOTE: Requires OpenGL ES 3.1 or OpenGL 4.3
    %%%%%: 2901-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2901-block  1
    #####: 2902:        case RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: if (RLGL.ExtSupported.texCompASTC) *glInternalFormat = GL_COMPRESSED_RGBA_ASTC_8x8_KHR; break;  // NOTE: Requires OpenGL ES 3.1 or OpenGL 4.3
    %%%%%: 2902-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2902-block  1
        -: 2903:    #endif
    #####: 2904:        default: TRACELOG(RL_LOG_WARNING, "TEXTURE: Current format not supported (%i)", format); break;
    %%%%%: 2904-block  0
call    0 never executed
        -: 2905:    }
        2: 2906:}
        -: 2907:
        -: 2908:// Unload texture from GPU memory
function rlUnloadTexture called 1 returned 100% blocks executed 100%
        1: 2909:void rlUnloadTexture(unsigned int id)
        -: 2910:{
        1: 2911:    glDeleteTextures(1, &id);
        1: 2911-block  0
call    0 returned 1
        1: 2912:}
        -: 2913:
        -: 2914:// Generate mipmap data for selected texture
function rlGenTextureMipmaps called 0 returned 0% blocks executed 0%
    #####: 2915:void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
        -: 2916:{
    #####: 2917:    glBindTexture(GL_TEXTURE_2D, id);
    %%%%%: 2917-block  0
call    0 never executed
        -: 2918:
        -: 2919:    // Check if texture is power-of-two (POT)
    #####: 2920:    bool texIsPOT = false;
        -: 2921:
    #####: 2922:    if (((width > 0) && ((width & (width - 1)) == 0)) &&
branch  0 never executed
branch  1 never executed
    %%%%%: 2922-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 2922-block  1
branch  4 never executed
branch  5 never executed
    #####: 2923:        ((height > 0) && ((height & (height - 1)) == 0))) texIsPOT = true;
    %%%%%: 2923-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2923-block  1
        -: 2924:
        -: 2925:#if defined(GRAPHICS_API_OPENGL_11)
        -: 2926:    if (texIsPOT)
        -: 2927:    {
        -: 2928:        // WARNING: Manual mipmap generation only works for RGBA 32bit textures!
        -: 2929:        if (format == RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)
        -: 2930:        {
        -: 2931:            // Retrieve texture data from VRAM
        -: 2932:            void *texData = rlReadTexturePixels(id, width, height, format);
        -: 2933:
        -: 2934:            // NOTE: Texture data size is reallocated to fit mipmaps data
        -: 2935:            // NOTE: CPU mipmap generation only supports RGBA 32bit data
        -: 2936:            int mipmapCount = rlGenTextureMipmapsData(texData, width, height);
        -: 2937:
        -: 2938:            int size = width*height*4;
        -: 2939:            int offset = size;
        -: 2940:
        -: 2941:            int mipWidth = width/2;
        -: 2942:            int mipHeight = height/2;
        -: 2943:
        -: 2944:            // Load the mipmaps
        -: 2945:            for (int level = 1; level < mipmapCount; level++)
        -: 2946:            {
        -: 2947:                glTexImage2D(GL_TEXTURE_2D, level, GL_RGBA8, mipWidth, mipHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, (unsigned char *)texData + offset);
        -: 2948:
        -: 2949:                size = mipWidth*mipHeight*4;
        -: 2950:                offset += size;
        -: 2951:
        -: 2952:                mipWidth /= 2;
        -: 2953:                mipHeight /= 2;
        -: 2954:            }
        -: 2955:
        -: 2956:            *mipmaps = mipmapCount + 1;
        -: 2957:            RL_FREE(texData); // Once mipmaps have been generated and data has been uploaded to GPU VRAM, we can discard RAM data
        -: 2958:
        -: 2959:            TRACELOG(RL_LOG_WARNING, "TEXTURE: [ID %i] Mipmaps generated manually on CPU side, total: %i", id, *mipmaps);
        -: 2960:        }
        -: 2961:        else TRACELOG(RL_LOG_WARNING, "TEXTURE: [ID %i] Failed to generate mipmaps for provided texture format", id);
        -: 2962:    }
        -: 2963:#endif
        -: 2964:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 2965:    if ((texIsPOT) || (RLGL.ExtSupported.texNPOT))
    %%%%%: 2965-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2965-block  1
branch  2 never executed
branch  3 never executed
        -: 2966:    {
        -: 2967:        //glHint(GL_GENERATE_MIPMAP_HINT, GL_DONT_CARE);   // Hint for mipmaps generation algorythm: GL_FASTEST, GL_NICEST, GL_DONT_CARE
    #####: 2968:        glGenerateMipmap(GL_TEXTURE_2D);    // Generate mipmaps automatically
    %%%%%: 2968-block  0
call    0 never executed
        -: 2969:
    #####: 2970:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
call    0 never executed
    #####: 2971:        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);   // Activate Trilinear filtering for mipmaps
call    0 never executed
        -: 2972:
        -: 2973:        #define MIN(a,b) (((a)<(b))?(a):(b))
        -: 2974:        #define MAX(a,b) (((a)>(b))?(a):(b))
        -: 2975:
    #####: 2976:        *mipmaps = 1 + (int)floor(log(MAX(width, height))/log(2));
    #####: 2977:        TRACELOG(RL_LOG_INFO, "TEXTURE: [ID %i] Mipmaps generated automatically, total: %i", id, *mipmaps);
call    0 never executed
        -: 2978:    }
        -: 2979:#endif
    #####: 2980:    else TRACELOG(RL_LOG_WARNING, "TEXTURE: [ID %i] Failed to generate mipmaps", id);
    %%%%%: 2980-block  0
call    0 never executed
        -: 2981:
    #####: 2982:    glBindTexture(GL_TEXTURE_2D, 0);
    %%%%%: 2982-block  0
call    0 never executed
    #####: 2983:}
        -: 2984:
        -: 2985:
        -: 2986:// Read texture pixel data
function rlReadTexturePixels called 0 returned 0% blocks executed 0%
    #####: 2987:void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
        -: 2988:{
    #####: 2989:    void *pixels = NULL;
        -: 2990:
        -: 2991:#if defined(GRAPHICS_API_OPENGL_11) || defined(GRAPHICS_API_OPENGL_33)
    #####: 2992:    glBindTexture(GL_TEXTURE_2D, id);
    %%%%%: 2992-block  0
call    0 never executed
        -: 2993:
        -: 2994:    // NOTE: Using texture id, we can retrieve some texture info (but not on OpenGL ES 2.0)
        -: 2995:    // Possible texture info: GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE
        -: 2996:    //int width, height, format;
        -: 2997:    //glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);
        -: 2998:    //glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &height);
        -: 2999:    //glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_INTERNAL_FORMAT, &format);
        -: 3000:
        -: 3001:    // NOTE: Each row written to or read from by OpenGL pixel operations like glGetTexImage are aligned to a 4 byte boundary by default, which may add some padding.
        -: 3002:    // Use glPixelStorei to modify padding with the GL_[UN]PACK_ALIGNMENT setting.
        -: 3003:    // GL_PACK_ALIGNMENT affects operations that read from OpenGL memory (glReadPixels, glGetTexImage, etc.)
        -: 3004:    // GL_UNPACK_ALIGNMENT affects operations that write to OpenGL memory (glTexImage, etc.)
    #####: 3005:    glPixelStorei(GL_PACK_ALIGNMENT, 1);
call    0 never executed
        -: 3006:
        -: 3007:    unsigned int glInternalFormat, glFormat, glType;
    #####: 3008:    rlGetGlTextureFormats(format, &glInternalFormat, &glFormat, &glType);
call    0 never executed
    #####: 3009:    unsigned int size = rlGetPixelDataSize(width, height, format);
call    0 never executed
        -: 3010:
    #####: 3011:    if ((glInternalFormat != -1) && (format < RL_PIXELFORMAT_COMPRESSED_DXT1_RGB))
branch  0 never executed
branch  1 never executed
    %%%%%: 3011-block  0
branch  2 never executed
branch  3 never executed
        -: 3012:    {
    #####: 3013:        pixels = RL_MALLOC(size);
    #####: 3014:        glGetTexImage(GL_TEXTURE_2D, 0, glFormat, glType, pixels);
    %%%%%: 3014-block  0
call    0 never executed
        -: 3015:    }
    #####: 3016:    else TRACELOG(RL_LOG_WARNING, "TEXTURE: [ID %i] Data retrieval not suported for pixel format (%i)", id, format);
    %%%%%: 3016-block  0
call    0 never executed
        -: 3017:
    #####: 3018:    glBindTexture(GL_TEXTURE_2D, 0);
    %%%%%: 3018-block  0
call    0 never executed
        -: 3019:#endif
        -: 3020:
        -: 3021:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 3022:    // glGetTexImage() is not available on OpenGL ES 2.0
        -: 3023:    // Texture width and height are required on OpenGL ES 2.0. There is no way to get it from texture id.
        -: 3024:    // Two possible Options:
        -: 3025:    // 1 - Bind texture to color fbo attachment and glReadPixels()
        -: 3026:    // 2 - Create an fbo, activate it, render quad with texture, glReadPixels()
        -: 3027:    // We are using Option 1, just need to care for texture format on retrieval
        -: 3028:    // NOTE: This behaviour could be conditioned by graphic driver...
        -: 3029:    unsigned int fboId = rlLoadFramebuffer(width, height);
        -: 3030:
        -: 3031:    // TODO: Create depth texture/renderbuffer for fbo?
        -: 3032:
        -: 3033:    glBindFramebuffer(GL_FRAMEBUFFER, fboId);
        -: 3034:    glBindTexture(GL_TEXTURE_2D, 0);
        -: 3035:
        -: 3036:    // Attach our texture to FBO
        -: 3037:    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, id, 0);
        -: 3038:
        -: 3039:    // We read data as RGBA because FBO texture is configured as RGBA, despite binding another texture format
        -: 3040:    pixels = (unsigned char *)RL_MALLOC(rlGetPixelDataSize(width, height, RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8));
        -: 3041:    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
        -: 3042:
        -: 3043:    glBindFramebuffer(GL_FRAMEBUFFER, 0);
        -: 3044:
        -: 3045:    // Clean up temporal fbo
        -: 3046:    rlUnloadFramebuffer(fboId);
        -: 3047:#endif
        -: 3048:
    #####: 3049:    return pixels;
        -: 3050:}
        -: 3051:
        -: 3052:
        -: 3053:// Read screen pixel data (color buffer)
function rlReadScreenPixels called 0 returned 0% blocks executed 0%
    #####: 3054:unsigned char *rlReadScreenPixels(int width, int height)
        -: 3055:{
    #####: 3056:    unsigned char *screenData = (unsigned char *)RL_CALLOC(width*height*4, sizeof(unsigned char));
        -: 3057:
        -: 3058:    // NOTE 1: glReadPixels returns image flipped vertically -> (0,0) is the bottom left corner of the framebuffer
        -: 3059:    // NOTE 2: We are getting alpha channel! Be careful, it can be transparent if not cleared properly!
    #####: 3060:    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, screenData);
    %%%%%: 3060-block  0
call    0 never executed
        -: 3061:
        -: 3062:    // Flip image vertically!
    #####: 3063:    unsigned char *imgData = (unsigned char *)RL_MALLOC(width*height*4*sizeof(unsigned char));
        -: 3064:
    #####: 3065:    for (int y = height - 1; y >= 0; y--)
    %%%%%: 3065-block  0
    %%%%%: 3065-block  1
branch  0 never executed
branch  1 never executed
        -: 3066:    {
    #####: 3067:        for (int x = 0; x < (width*4); x++)
    %%%%%: 3067-block  0
    %%%%%: 3067-block  1
    %%%%%: 3067-block  2
branch  0 never executed
branch  1 never executed
        -: 3068:        {
    #####: 3069:            imgData[((height - 1) - y)*width*4 + x] = screenData[(y*width*4) + x];  // Flip line
        -: 3070:
        -: 3071:            // Set alpha component value to 255 (no trasparent image retrieval)
        -: 3072:            // NOTE: Alpha value has already been applied to RGB in framebuffer, we don't need it!
    #####: 3073:            if (((x + 1)%4) == 0) imgData[((height - 1) - y)*width*4 + x] = 255;
    %%%%%: 3073-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3073-block  1
        -: 3074:        }
        -: 3075:    }
        -: 3076:
    #####: 3077:    RL_FREE(screenData);
        -: 3078:
    #####: 3079:    return imgData;     // NOTE: image data should be freed
    %%%%%: 3079-block  0
        -: 3080:}
        -: 3081:
        -: 3082:// Framebuffer management (fbo)
        -: 3083://-----------------------------------------------------------------------------------------
        -: 3084:// Load a framebuffer to be used for rendering
        -: 3085:// NOTE: No textures attached
function rlLoadFramebuffer called 0 returned 0% blocks executed 0%
    #####: 3086:unsigned int rlLoadFramebuffer(int width, int height)
        -: 3087:{
    #####: 3088:    unsigned int fboId = 0;
        -: 3089:
        -: 3090:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)) && defined(SUPPORT_RENDER_TEXTURES_HINT)
    #####: 3091:    glGenFramebuffers(1, &fboId);       // Create the framebuffer object
    %%%%%: 3091-block  0
call    0 never executed
    #####: 3092:    glBindFramebuffer(GL_FRAMEBUFFER, 0);   // Unbind any framebuffer
call    0 never executed
        -: 3093:#endif
        -: 3094:
    #####: 3095:    return fboId;
        -: 3096:}
        -: 3097:
        -: 3098:// Attach color buffer texture to an fbo (unloads previous attachment)
        -: 3099:// NOTE: Attach type: 0-Color, 1-Depth renderbuffer, 2-Depth texture
function rlFramebufferAttach called 0 returned 0% blocks executed 0%
    #####: 3100:void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
        -: 3101:{
        -: 3102:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)) && defined(SUPPORT_RENDER_TEXTURES_HINT)
    #####: 3103:    glBindFramebuffer(GL_FRAMEBUFFER, fboId);
    %%%%%: 3103-block  0
call    0 never executed
        -: 3104:
    #####: 3105:    switch (attachType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3106:    {
    #####: 3107:        case RL_ATTACHMENT_COLOR_CHANNEL0:
        -: 3108:        case RL_ATTACHMENT_COLOR_CHANNEL1:
        -: 3109:        case RL_ATTACHMENT_COLOR_CHANNEL2:
        -: 3110:        case RL_ATTACHMENT_COLOR_CHANNEL3:
        -: 3111:        case RL_ATTACHMENT_COLOR_CHANNEL4:
        -: 3112:        case RL_ATTACHMENT_COLOR_CHANNEL5:
        -: 3113:        case RL_ATTACHMENT_COLOR_CHANNEL6:
        -: 3114:        case RL_ATTACHMENT_COLOR_CHANNEL7:
        -: 3115:        {
    #####: 3116:            if (texType == RL_ATTACHMENT_TEXTURE2D) glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + attachType, GL_TEXTURE_2D, texId, mipLevel);
    %%%%%: 3116-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3116-block  1
call    2 never executed
    #####: 3117:            else if (texType == RL_ATTACHMENT_RENDERBUFFER) glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + attachType, GL_RENDERBUFFER, texId);
    %%%%%: 3117-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3117-block  1
call    2 never executed
    #####: 3118:            else if (texType >= RL_ATTACHMENT_CUBEMAP_POSITIVE_X) glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + attachType, GL_TEXTURE_CUBE_MAP_POSITIVE_X + texType, texId, mipLevel);
    %%%%%: 3118-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3118-block  1
call    2 never executed
        -: 3119:
    #####: 3120:        } break;
    %%%%%: 3120-block  0
    #####: 3121:        case RL_ATTACHMENT_DEPTH:
        -: 3122:        {
    #####: 3123:            if (texType == RL_ATTACHMENT_TEXTURE2D) glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texId, mipLevel);
    %%%%%: 3123-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3123-block  1
call    2 never executed
    #####: 3124:            else if (texType == RL_ATTACHMENT_RENDERBUFFER)  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, texId);
    %%%%%: 3124-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3124-block  1
call    2 never executed
        -: 3125:
    #####: 3126:        } break;
    %%%%%: 3126-block  0
    #####: 3127:        case RL_ATTACHMENT_STENCIL:
        -: 3128:        {
    #####: 3129:            if (texType == RL_ATTACHMENT_TEXTURE2D) glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texId, mipLevel);
    %%%%%: 3129-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3129-block  1
call    2 never executed
    #####: 3130:            else if (texType == RL_ATTACHMENT_RENDERBUFFER)  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, texId);
    %%%%%: 3130-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3130-block  1
call    2 never executed
        -: 3131:
    #####: 3132:        } break;
    %%%%%: 3132-block  0
    #####: 3133:        default: break;
    %%%%%: 3133-block  0
        -: 3134:    }
        -: 3135:
    #####: 3136:    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    %%%%%: 3136-block  0
call    0 never executed
        -: 3137:#endif
    #####: 3138:}
        -: 3139:
        -: 3140:// Verify render texture is complete
function rlFramebufferComplete called 0 returned 0% blocks executed 0%
    #####: 3141:bool rlFramebufferComplete(unsigned int id)
        -: 3142:{
    #####: 3143:    bool result = false;
        -: 3144:
        -: 3145:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)) && defined(SUPPORT_RENDER_TEXTURES_HINT)
    #####: 3146:    glBindFramebuffer(GL_FRAMEBUFFER, id);
    %%%%%: 3146-block  0
call    0 never executed
        -: 3147:
    #####: 3148:    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
call    0 never executed
        -: 3149:
    #####: 3150:    if (status != GL_FRAMEBUFFER_COMPLETE)
branch  0 never executed
branch  1 never executed
        -: 3151:    {
    #####: 3152:        switch (status)
    %%%%%: 3152-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3153:        {
    #####: 3154:            case GL_FRAMEBUFFER_UNSUPPORTED: TRACELOG(RL_LOG_WARNING, "FBO: [ID %i] Framebuffer is unsupported", id); break;
    %%%%%: 3154-block  0
call    0 never executed
    #####: 3155:            case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: TRACELOG(RL_LOG_WARNING, "FBO: [ID %i] Framebuffer has incomplete attachment", id); break;
    %%%%%: 3155-block  0
call    0 never executed
        -: 3156:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 3157:            case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: TRACELOG(RL_LOG_WARNING, "FBO: [ID %i] Framebuffer has incomplete dimensions", id); break;
        -: 3158:#endif
    #####: 3159:            case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: TRACELOG(RL_LOG_WARNING, "FBO: [ID %i] Framebuffer has a missing attachment", id); break;
    %%%%%: 3159-block  0
call    0 never executed
    #####: 3160:            default: break;
    %%%%%: 3160-block  0
        -: 3161:        }
    #####: 3162:    }
    %%%%%: 3162-block  0
        -: 3163:
    #####: 3164:    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    %%%%%: 3164-block  0
call    0 never executed
        -: 3165:
    #####: 3166:    result = (status == GL_FRAMEBUFFER_COMPLETE);
        -: 3167:#endif
        -: 3168:
    #####: 3169:    return result;
        -: 3170:}
        -: 3171:
        -: 3172:// Unload framebuffer from GPU memory
        -: 3173:// NOTE: All attached textures/cubemaps/renderbuffers are also deleted
function rlUnloadFramebuffer called 0 returned 0% blocks executed 0%
    #####: 3174:void rlUnloadFramebuffer(unsigned int id)
        -: 3175:{
        -: 3176:#if (defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)) && defined(SUPPORT_RENDER_TEXTURES_HINT)
        -: 3177:
        -: 3178:    // Query depth attachment to automatically delete texture/renderbuffer
    #####: 3179:    int depthType = 0, depthId = 0;
    #####: 3180:    glBindFramebuffer(GL_FRAMEBUFFER, id);   // Bind framebuffer to query depth texture type
    %%%%%: 3180-block  0
call    0 never executed
    #####: 3181:    glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &depthType);
call    0 never executed
    #####: 3182:    glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &depthId);
call    0 never executed
        -: 3183:
    #####: 3184:    unsigned int depthIdU = (unsigned int)depthId;
    #####: 3185:    if (depthType == GL_RENDERBUFFER) glDeleteRenderbuffers(1, &depthIdU);
branch  0 never executed
branch  1 never executed
    %%%%%: 3185-block  0
call    2 never executed
    #####: 3186:    else if (depthType == GL_RENDERBUFFER) glDeleteTextures(1, &depthIdU);
    %%%%%: 3186-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3186-block  1
call    2 never executed
        -: 3187:
        -: 3188:    // NOTE: If a texture object is deleted while its image is attached to the *currently bound* framebuffer,
        -: 3189:    // the texture image is automatically detached from the currently bound framebuffer.
        -: 3190:
    #####: 3191:    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    %%%%%: 3191-block  0
call    0 never executed
    #####: 3192:    glDeleteFramebuffers(1, &id);
call    0 never executed
        -: 3193:
    #####: 3194:    TRACELOG(RL_LOG_INFO, "FBO: [ID %i] Unloaded framebuffer from VRAM (GPU)", id);
call    0 never executed
        -: 3195:#endif
    #####: 3196:}
        -: 3197:
        -: 3198:// Vertex data management
        -: 3199://-----------------------------------------------------------------------------------------
        -: 3200:// Load a new attributes buffer
function rlLoadVertexBuffer called 0 returned 0% blocks executed 0%
    #####: 3201:unsigned int rlLoadVertexBuffer(void *buffer, int size, bool dynamic)
        -: 3202:{
    #####: 3203:    unsigned int id = 0;
        -: 3204:
        -: 3205:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3206:    glGenBuffers(1, &id);
    %%%%%: 3206-block  0
call    0 never executed
    #####: 3207:    glBindBuffer(GL_ARRAY_BUFFER, id);
call    0 never executed
    #####: 3208:    glBufferData(GL_ARRAY_BUFFER, size, buffer, dynamic? GL_DYNAMIC_DRAW : GL_STATIC_DRAW);
branch  0 never executed
branch  1 never executed
    %%%%%: 3208-block  0
    %%%%%: 3208-block  1
    %%%%%: 3208-block  2
call    2 never executed
        -: 3209:#endif
        -: 3210:
    #####: 3211:    return id;
        -: 3212:}
        -: 3213:
        -: 3214:// Load a new attributes element buffer
function rlLoadVertexBufferElement called 0 returned 0% blocks executed 0%
    #####: 3215:unsigned int rlLoadVertexBufferElement(void *buffer, int size, bool dynamic)
        -: 3216:{
    #####: 3217:    unsigned int id = 0;
        -: 3218:
        -: 3219:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3220:    glGenBuffers(1, &id);
    %%%%%: 3220-block  0
call    0 never executed
    #####: 3221:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, id);
call    0 never executed
    #####: 3222:    glBufferData(GL_ELEMENT_ARRAY_BUFFER, size, buffer, dynamic? GL_DYNAMIC_DRAW : GL_STATIC_DRAW);
branch  0 never executed
branch  1 never executed
    %%%%%: 3222-block  0
    %%%%%: 3222-block  1
    %%%%%: 3222-block  2
call    2 never executed
        -: 3223:#endif
        -: 3224:
    #####: 3225:    return id;
        -: 3226:}
        -: 3227:
        -: 3228:// Enable vertex buffer (VBO)
function rlEnableVertexBuffer called 0 returned 0% blocks executed 0%
    #####: 3229:void rlEnableVertexBuffer(unsigned int id)
        -: 3230:{
        -: 3231:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3232:    glBindBuffer(GL_ARRAY_BUFFER, id);
    %%%%%: 3232-block  0
call    0 never executed
        -: 3233:#endif
    #####: 3234:}
        -: 3235:
        -: 3236:// Disable vertex buffer (VBO)
function rlDisableVertexBuffer called 0 returned 0% blocks executed 0%
    #####: 3237:void rlDisableVertexBuffer(void)
        -: 3238:{
        -: 3239:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3240:    glBindBuffer(GL_ARRAY_BUFFER, 0);
    %%%%%: 3240-block  0
call    0 never executed
        -: 3241:#endif
    #####: 3242:}
        -: 3243:
        -: 3244:// Enable vertex buffer element (VBO element)
function rlEnableVertexBufferElement called 0 returned 0% blocks executed 0%
    #####: 3245:void rlEnableVertexBufferElement(unsigned int id)
        -: 3246:{
        -: 3247:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3248:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, id);
    %%%%%: 3248-block  0
call    0 never executed
        -: 3249:#endif
    #####: 3250:}
        -: 3251:
        -: 3252:// Disable vertex buffer element (VBO element)
function rlDisableVertexBufferElement called 0 returned 0% blocks executed 0%
    #####: 3253:void rlDisableVertexBufferElement(void)
        -: 3254:{
        -: 3255:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3256:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    %%%%%: 3256-block  0
call    0 never executed
        -: 3257:#endif
    #####: 3258:}
        -: 3259:
        -: 3260:// Update vertex buffer with new data
        -: 3261:// NOTE: dataSize and offset must be provided in bytes
function rlUpdateVertexBuffer called 0 returned 0% blocks executed 0%
    #####: 3262:void rlUpdateVertexBuffer(unsigned int id, void *data, int dataSize, int offset)
        -: 3263:{
        -: 3264:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3265:    glBindBuffer(GL_ARRAY_BUFFER, id);
    %%%%%: 3265-block  0
call    0 never executed
    #####: 3266:    glBufferSubData(GL_ARRAY_BUFFER, offset, dataSize, data);
call    0 never executed
        -: 3267:#endif
    #####: 3268:}
        -: 3269:
        -: 3270:// Update vertex buffer elements with new data
        -: 3271:// NOTE: dataSize and offset must be provided in bytes
function rlUpdateVertexBufferElements called 0 returned 0% blocks executed 0%
    #####: 3272:void rlUpdateVertexBufferElements(unsigned int id, void *data, int dataSize, int offset)
        -: 3273:{
        -: 3274:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3275:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, id);
    %%%%%: 3275-block  0
call    0 never executed
    #####: 3276:    glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, offset, dataSize, data);
call    0 never executed
        -: 3277:#endif
    #####: 3278:}
        -: 3279:
        -: 3280:// Enable vertex array object (VAO)
function rlEnableVertexArray called 0 returned 0% blocks executed 0%
    #####: 3281:bool rlEnableVertexArray(unsigned int vaoId)
        -: 3282:{
    #####: 3283:    bool result = false;
        -: 3284:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3285:    if (RLGL.ExtSupported.vao)
    %%%%%: 3285-block  0
branch  0 never executed
branch  1 never executed
        -: 3286:    {
    #####: 3287:        glBindVertexArray(vaoId);
    %%%%%: 3287-block  0
call    0 never executed
    #####: 3288:        result = true;
        -: 3289:    }
        -: 3290:#endif
    #####: 3291:    return result;
    %%%%%: 3291-block  0
        -: 3292:}
        -: 3293:
        -: 3294:// Disable vertex array object (VAO)
function rlDisableVertexArray called 0 returned 0% blocks executed 0%
    #####: 3295:void rlDisableVertexArray(void)
        -: 3296:{
        -: 3297:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3298:    if (RLGL.ExtSupported.vao) glBindVertexArray(0);
    %%%%%: 3298-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3298-block  1
call    2 never executed
        -: 3299:#endif
    #####: 3300:}
        -: 3301:
        -: 3302:// Enable vertex attribute index
function rlEnableVertexAttribute called 0 returned 0% blocks executed 0%
    #####: 3303:void rlEnableVertexAttribute(unsigned int index)
        -: 3304:{
        -: 3305:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3306:    glEnableVertexAttribArray(index);
    %%%%%: 3306-block  0
call    0 never executed
        -: 3307:#endif
    #####: 3308:}
        -: 3309:
        -: 3310:// Disable vertex attribute index
function rlDisableVertexAttribute called 0 returned 0% blocks executed 0%
    #####: 3311:void rlDisableVertexAttribute(unsigned int index)
        -: 3312:{
        -: 3313:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3314:    glDisableVertexAttribArray(index);
    %%%%%: 3314-block  0
call    0 never executed
        -: 3315:#endif
    #####: 3316:}
        -: 3317:
        -: 3318:// Draw vertex array
function rlDrawVertexArray called 0 returned 0% blocks executed 0%
    #####: 3319:void rlDrawVertexArray(int offset, int count)
        -: 3320:{
    #####: 3321:    glDrawArrays(GL_TRIANGLES, offset, count);
    %%%%%: 3321-block  0
call    0 never executed
    #####: 3322:}
        -: 3323:
        -: 3324:// Draw vertex array elements
function rlDrawVertexArrayElements called 0 returned 0% blocks executed 0%
    #####: 3325:void rlDrawVertexArrayElements(int offset, int count, void *buffer)
        -: 3326:{
    #####: 3327:    glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_SHORT, (unsigned short *)buffer + offset);
    %%%%%: 3327-block  0
call    0 never executed
    #####: 3328:}
        -: 3329:
        -: 3330:// Draw vertex array instanced
function rlDrawVertexArrayInstanced called 0 returned 0% blocks executed 0%
    #####: 3331:void rlDrawVertexArrayInstanced(int offset, int count, int instances)
        -: 3332:{
        -: 3333:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3334:    glDrawArraysInstanced(GL_TRIANGLES, 0, count, instances);
    %%%%%: 3334-block  0
call    0 never executed
        -: 3335:#endif
    #####: 3336:}
        -: 3337:
        -: 3338:// Draw vertex array elements instanced
function rlDrawVertexArrayElementsInstanced called 0 returned 0% blocks executed 0%
    #####: 3339:void rlDrawVertexArrayElementsInstanced(int offset, int count, void *buffer, int instances)
        -: 3340:{
        -: 3341:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3342:    glDrawElementsInstanced(GL_TRIANGLES, count, GL_UNSIGNED_SHORT, (unsigned short *)buffer + offset, instances);
    %%%%%: 3342-block  0
call    0 never executed
        -: 3343:#endif
    #####: 3344:}
        -: 3345:
        -: 3346:#if defined(GRAPHICS_API_OPENGL_11)
        -: 3347:// Enable vertex state pointer
        -: 3348:void rlEnableStatePointer(int vertexAttribType, void *buffer)
        -: 3349:{
        -: 3350:    if (buffer != NULL) glEnableClientState(vertexAttribType);
        -: 3351:    switch (vertexAttribType)
        -: 3352:    {
        -: 3353:        case GL_VERTEX_ARRAY: glVertexPointer(3, GL_FLOAT, 0, buffer); break;
        -: 3354:        case GL_TEXTURE_COORD_ARRAY: glTexCoordPointer(2, GL_FLOAT, 0, buffer); break;
        -: 3355:        case GL_NORMAL_ARRAY: if (buffer != NULL) glNormalPointer(GL_FLOAT, 0, buffer); break;
        -: 3356:        case GL_COLOR_ARRAY: if (buffer != NULL) glColorPointer(4, GL_UNSIGNED_BYTE, 0, buffer); break;
        -: 3357:        //case GL_INDEX_ARRAY: if (buffer != NULL) glIndexPointer(GL_SHORT, 0, buffer); break; // Indexed colors
        -: 3358:        default: break;
        -: 3359:    }
        -: 3360:}
        -: 3361:
        -: 3362:// Disable vertex state pointer
        -: 3363:void rlDisableStatePointer(int vertexAttribType)
        -: 3364:{
        -: 3365:    glDisableClientState(vertexAttribType);
        -: 3366:}
        -: 3367:#endif
        -: 3368:
        -: 3369:// Load vertex array object (VAO)
function rlLoadVertexArray called 0 returned 0% blocks executed 0%
    #####: 3370:unsigned int rlLoadVertexArray(void)
        -: 3371:{
    #####: 3372:    unsigned int vaoId = 0;
        -: 3373:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3374:    if (RLGL.ExtSupported.vao)
    %%%%%: 3374-block  0
branch  0 never executed
branch  1 never executed
        -: 3375:    {
    #####: 3376:        glGenVertexArrays(1, &vaoId);
    %%%%%: 3376-block  0
call    0 never executed
        -: 3377:    }
        -: 3378:#endif
    #####: 3379:    return vaoId;
    %%%%%: 3379-block  0
        -: 3380:}
        -: 3381:
        -: 3382:// Set vertex attribute
function rlSetVertexAttribute called 0 returned 0% blocks executed 0%
    #####: 3383:void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, void *pointer)
        -: 3384:{
        -: 3385:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3386:    glVertexAttribPointer(index, compSize, type, normalized, stride, pointer);
    %%%%%: 3386-block  0
call    0 never executed
        -: 3387:#endif
    #####: 3388:}
        -: 3389:
        -: 3390:// Set vertex attribute divisor
function rlSetVertexAttributeDivisor called 0 returned 0% blocks executed 0%
    #####: 3391:void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
        -: 3392:{
        -: 3393:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3394:    glVertexAttribDivisor(index, divisor);
    %%%%%: 3394-block  0
call    0 never executed
        -: 3395:#endif
    #####: 3396:}
        -: 3397:
        -: 3398:// Unload vertex array object (VAO)
function rlUnloadVertexArray called 0 returned 0% blocks executed 0%
    #####: 3399:void rlUnloadVertexArray(unsigned int vaoId)
        -: 3400:{
        -: 3401:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3402:    if (RLGL.ExtSupported.vao)
    %%%%%: 3402-block  0
branch  0 never executed
branch  1 never executed
        -: 3403:    {
    #####: 3404:        glBindVertexArray(0);
    %%%%%: 3404-block  0
call    0 never executed
    #####: 3405:        glDeleteVertexArrays(1, &vaoId);
call    0 never executed
    #####: 3406:        TRACELOG(RL_LOG_INFO, "VAO: [ID %i] Unloaded vertex array data from VRAM (GPU)", vaoId);
call    0 never executed
        -: 3407:    }
        -: 3408:#endif
    #####: 3409:}
        -: 3410:
        -: 3411:// Unload vertex buffer (VBO)
function rlUnloadVertexBuffer called 0 returned 0% blocks executed 0%
    #####: 3412:void rlUnloadVertexBuffer(unsigned int vboId)
        -: 3413:{
        -: 3414:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3415:    glDeleteBuffers(1, &vboId);
    %%%%%: 3415-block  0
call    0 never executed
        -: 3416:    //TRACELOG(RL_LOG_INFO, "VBO: Unloaded vertex data from VRAM (GPU)");
        -: 3417:#endif
    #####: 3418:}
        -: 3419:
        -: 3420:// Shaders management
        -: 3421://-----------------------------------------------------------------------------------------------
        -: 3422:// Load shader from code strings
        -: 3423:// NOTE: If shader string is NULL, using default vertex/fragment shaders
function rlLoadShaderCode called 0 returned 0% blocks executed 0%
    #####: 3424:unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
        -: 3425:{
    #####: 3426:    unsigned int id = 0;
        -: 3427:
        -: 3428:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3429:    unsigned int vertexShaderId = RLGL.State.defaultVShaderId;
    #####: 3430:    unsigned int fragmentShaderId = RLGL.State.defaultFShaderId;
        -: 3431:
    #####: 3432:    if (vsCode != NULL) vertexShaderId = rlCompileShader(vsCode, GL_VERTEX_SHADER);
    %%%%%: 3432-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3432-block  1
call    2 never executed
    #####: 3433:    if (fsCode != NULL) fragmentShaderId = rlCompileShader(fsCode, GL_FRAGMENT_SHADER);
    %%%%%: 3433-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3433-block  1
call    2 never executed
        -: 3434:
    #####: 3435:    if ((vertexShaderId == RLGL.State.defaultVShaderId) && (fragmentShaderId == RLGL.State.defaultFShaderId)) id = RLGL.State.defaultShaderId;
    %%%%%: 3435-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3435-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3435-block  2
        -: 3436:    else
        -: 3437:    {
    #####: 3438:        id = rlLoadShaderProgram(vertexShaderId, fragmentShaderId);
    %%%%%: 3438-block  0
call    0 never executed
        -: 3439:
    #####: 3440:        if (vertexShaderId != RLGL.State.defaultVShaderId)
branch  0 never executed
branch  1 never executed
        -: 3441:        {
        -: 3442:            // Detach shader before deletion to make sure memory is freed
    #####: 3443:            glDetachShader(id, vertexShaderId);
    %%%%%: 3443-block  0
call    0 never executed
    #####: 3444:            glDeleteShader(vertexShaderId);
call    0 never executed
        -: 3445:        }
    #####: 3446:        if (fragmentShaderId != RLGL.State.defaultFShaderId)
    %%%%%: 3446-block  0
branch  0 never executed
branch  1 never executed
        -: 3447:        {
        -: 3448:            // Detach shader before deletion to make sure memory is freed
    #####: 3449:            glDetachShader(id, fragmentShaderId);
    %%%%%: 3449-block  0
call    0 never executed
    #####: 3450:            glDeleteShader(fragmentShaderId);
call    0 never executed
        -: 3451:        }
        -: 3452:
    #####: 3453:        if (id == 0)
    %%%%%: 3453-block  0
branch  0 never executed
branch  1 never executed
        -: 3454:        {
    #####: 3455:            TRACELOG(RL_LOG_WARNING, "SHADER: Failed to load custom shader code");
    %%%%%: 3455-block  0
call    0 never executed
    #####: 3456:            id = RLGL.State.defaultShaderId;
        -: 3457:        }
        -: 3458:    }
        -: 3459:
        -: 3460:    // Get available shader uniforms
        -: 3461:    // NOTE: This information is useful for debug...
    #####: 3462:    int uniformCount = -1;
        -: 3463:
    #####: 3464:    glGetProgramiv(id, GL_ACTIVE_UNIFORMS, &uniformCount);
    %%%%%: 3464-block  0
call    0 never executed
        -: 3465:
    #####: 3466:    for (int i = 0; i < uniformCount; i++)
    %%%%%: 3466-block  0
branch  0 never executed
branch  1 never executed
        -: 3467:    {
    #####: 3468:        int namelen = -1;
    #####: 3469:        int num = -1;
    #####: 3470:        char name[256] = { 0 };     // Assume no variable names longer than 256
    #####: 3471:        GLenum type = GL_ZERO;
        -: 3472:
        -: 3473:        // Get the name of the uniforms
    #####: 3474:        glGetActiveUniform(id, i, sizeof(name) - 1, &namelen, &num, &type, name);
    %%%%%: 3474-block  0
call    0 never executed
        -: 3475:
    #####: 3476:        name[namelen] = 0;
        -: 3477:
        -: 3478:        TRACELOGD("SHADER: [ID %i] Active uniform (%s) set at location: %i", id, name, glGetUniformLocation(id, name));
        -: 3479:    }
        -: 3480:#endif
        -: 3481:
    #####: 3482:    return id;
    %%%%%: 3482-block  0
        -: 3483:}
        -: 3484:
        -: 3485:// Compile custom shader and return shader id
function rlCompileShader called 2 returned 100% blocks executed 48%
        2: 3486:unsigned int rlCompileShader(const char *shaderCode, int type)
        -: 3487:{
        2: 3488:    unsigned int shader = 0;
        -: 3489:
        -: 3490:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        2: 3491:    shader = glCreateShader(type);
        2: 3491-block  0
call    0 returned 2
        2: 3492:    glShaderSource(shader, 1, &shaderCode, NULL);
call    0 returned 2
        -: 3493:
        2: 3494:    GLint success = 0;
        2: 3495:    glCompileShader(shader);
call    0 returned 2
        2: 3496:    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
call    0 returned 2
        -: 3497:
        2: 3498:    if (success == GL_FALSE)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 3499:    {
    #####: 3500:        switch (type)
    %%%%%: 3500-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 3501:        {
    #####: 3502:            case GL_VERTEX_SHADER: TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Failed to compile vertex shader code", shader); break;
    %%%%%: 3502-block  0
call    0 never executed
    #####: 3503:            case GL_FRAGMENT_SHADER: TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Failed to compile fragment shader code", shader); break;
    %%%%%: 3503-block  0
call    0 never executed
        -: 3504:            //case GL_GEOMETRY_SHADER:
        -: 3505:            //case GL_COMPUTE_SHADER:
    #####: 3506:            default: break;
    %%%%%: 3506-block  0
        -: 3507:        }
        -: 3508:
    #####: 3509:        int maxLength = 0;
    #####: 3510:        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &maxLength);
    %%%%%: 3510-block  0
call    0 never executed
        -: 3511:
    #####: 3512:        if (maxLength > 0)
branch  0 never executed
branch  1 never executed
        -: 3513:        {
    #####: 3514:            int length = 0;
    #####: 3515:            char *log = RL_CALLOC(maxLength, sizeof(char));
    #####: 3516:            glGetShaderInfoLog(shader, maxLength, &length, log);
    %%%%%: 3516-block  0
call    0 never executed
    #####: 3517:            TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Compile error: %s", shader, log);
call    0 never executed
    #####: 3518:            RL_FREE(log);
        -: 3519:        }
        -: 3520:    }
        -: 3521:    else
        -: 3522:    {
        2: 3523:        switch (type)
        2: 3523-block  0
branch  0 taken 1
branch  1 taken 1
branch  2 taken 0
        -: 3524:        {
        1: 3525:            case GL_VERTEX_SHADER: TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Vertex shader compiled successfully", shader); break;
        1: 3525-block  0
call    0 returned 1
        1: 3526:            case GL_FRAGMENT_SHADER: TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Fragment shader compiled successfully", shader); break;
        1: 3526-block  0
call    0 returned 1
        -: 3527:            //case GL_GEOMETRY_SHADER:
        -: 3528:            //case GL_COMPUTE_SHADER:
    #####: 3529:            default: break;
    %%%%%: 3529-block  0
        -: 3530:        }
        -: 3531:    }
        -: 3532:#endif
        -: 3533:
        2: 3534:    return shader;
        2: 3534-block  0
        -: 3535:}
        -: 3536:
        -: 3537:// Load custom shader strings and return program id
function rlLoadShaderProgram called 1 returned 100% blocks executed 65%
        1: 3538:unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
        -: 3539:{
        1: 3540:    unsigned int program = 0;
        -: 3541:
        -: 3542:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        1: 3543:    GLint success = 0;
        1: 3544:    program = glCreateProgram();
        1: 3544-block  0
call    0 returned 1
        -: 3545:
        1: 3546:    glAttachShader(program, vShaderId);
call    0 returned 1
        1: 3547:    glAttachShader(program, fShaderId);
call    0 returned 1
        -: 3548:
        -: 3549:    // NOTE: Default attribute shader locations must be binded before linking
        1: 3550:    glBindAttribLocation(program, 0, RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION);
call    0 returned 1
        1: 3551:    glBindAttribLocation(program, 1, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD);
call    0 returned 1
        1: 3552:    glBindAttribLocation(program, 2, RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL);
call    0 returned 1
        1: 3553:    glBindAttribLocation(program, 3, RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR);
call    0 returned 1
        1: 3554:    glBindAttribLocation(program, 4, RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT);
call    0 returned 1
        1: 3555:    glBindAttribLocation(program, 5, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2);
call    0 returned 1
        -: 3556:
        -: 3557:    // NOTE: If some attrib name is no found on the shader, it locations becomes -1
        -: 3558:
        1: 3559:    glLinkProgram(program);
call    0 returned 1
        -: 3560:
        -: 3561:    // NOTE: All uniform variables are intitialised to 0 when a program links
        -: 3562:
        1: 3563:    glGetProgramiv(program, GL_LINK_STATUS, &success);
call    0 returned 1
        -: 3564:
        1: 3565:    if (success == GL_FALSE)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3566:    {
    #####: 3567:        TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Failed to link shader program", program);
    %%%%%: 3567-block  0
call    0 never executed
        -: 3568:
    #####: 3569:        int maxLength = 0;
    #####: 3570:        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);
call    0 never executed
        -: 3571:
    #####: 3572:        if (maxLength > 0)
branch  0 never executed
branch  1 never executed
        -: 3573:        {
    #####: 3574:            int length = 0;
    #####: 3575:            char *log = RL_CALLOC(maxLength, sizeof(char));
    #####: 3576:            glGetProgramInfoLog(program, maxLength, &length, log);
    %%%%%: 3576-block  0
call    0 never executed
    #####: 3577:            TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Link error: %s", program, log);
call    0 never executed
    #####: 3578:            RL_FREE(log);
        -: 3579:        }
        -: 3580:
    #####: 3581:        glDeleteProgram(program);
    %%%%%: 3581-block  0
call    0 never executed
        -: 3582:
    #####: 3583:        program = 0;
        -: 3584:    }
        -: 3585:    else
        -: 3586:    {
        -: 3587:        // Get the size of compiled shader program (not available on OpenGL ES 2.0)
        -: 3588:        // NOTE: If GL_LINK_STATUS is GL_FALSE, program binary length is zero.
        -: 3589:        //GLint binarySize = 0;
        -: 3590:        //glGetProgramiv(id, GL_PROGRAM_BINARY_LENGTH, &binarySize);
        -: 3591:
        1: 3592:        TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Program shader loaded successfully", program);
        1: 3592-block  0
call    0 returned 1
        -: 3593:    }
        -: 3594:#endif
        1: 3595:    return program;
        1: 3595-block  0
        -: 3596:}
        -: 3597:
        -: 3598:// Unload shader program
function rlUnloadShaderProgram called 0 returned 0% blocks executed 0%
    #####: 3599:void rlUnloadShaderProgram(unsigned int id)
        -: 3600:{
        -: 3601:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3602:    glDeleteProgram(id);
    %%%%%: 3602-block  0
call    0 never executed
        -: 3603:
    #####: 3604:    TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Unloaded shader program data from VRAM (GPU)", id);
call    0 never executed
        -: 3605:#endif
    #####: 3606:}
        -: 3607:
        -: 3608:// Get shader location uniform
function rlGetLocationUniform called 0 returned 0% blocks executed 0%
    #####: 3609:int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
        -: 3610:{
    #####: 3611:    int location = -1;
        -: 3612:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3613:    location = glGetUniformLocation(shaderId, uniformName);
    %%%%%: 3613-block  0
call    0 never executed
        -: 3614:
    #####: 3615:    if (location == -1) TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Failed to find shader uniform: %s", shaderId, uniformName);
branch  0 never executed
branch  1 never executed
    %%%%%: 3615-block  0
call    2 never executed
    #####: 3616:    else TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Shader uniform (%s) set at location: %i", shaderId, uniformName, location);
    %%%%%: 3616-block  0
call    0 never executed
        -: 3617:#endif
    #####: 3618:    return location;
    %%%%%: 3618-block  0
        -: 3619:}
        -: 3620:
        -: 3621:// Get shader location attribute
function rlGetLocationAttrib called 0 returned 0% blocks executed 0%
    #####: 3622:int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
        -: 3623:{
    #####: 3624:    int location = -1;
        -: 3625:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3626:    location = glGetAttribLocation(shaderId, attribName);
    %%%%%: 3626-block  0
call    0 never executed
        -: 3627:
    #####: 3628:    if (location == -1) TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Failed to find shader attribute: %s", shaderId, attribName);
branch  0 never executed
branch  1 never executed
    %%%%%: 3628-block  0
call    2 never executed
    #####: 3629:    else TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Shader attribute (%s) set at location: %i", shaderId, attribName, location);
    %%%%%: 3629-block  0
call    0 never executed
        -: 3630:#endif
    #####: 3631:    return location;
    %%%%%: 3631-block  0
        -: 3632:}
        -: 3633:
        -: 3634:// Set shader value uniform
function rlSetUniform called 0 returned 0% blocks executed 0%
    #####: 3635:void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
        -: 3636:{
        -: 3637:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3638:    switch (uniformType)
    %%%%%: 3638-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 3639:    {
    #####: 3640:        case RL_SHADER_UNIFORM_FLOAT: glUniform1fv(locIndex, count, (float *)value); break;
    %%%%%: 3640-block  0
call    0 never executed
    #####: 3641:        case RL_SHADER_UNIFORM_VEC2: glUniform2fv(locIndex, count, (float *)value); break;
    %%%%%: 3641-block  0
call    0 never executed
    #####: 3642:        case RL_SHADER_UNIFORM_VEC3: glUniform3fv(locIndex, count, (float *)value); break;
    %%%%%: 3642-block  0
call    0 never executed
    #####: 3643:        case RL_SHADER_UNIFORM_VEC4: glUniform4fv(locIndex, count, (float *)value); break;
    %%%%%: 3643-block  0
call    0 never executed
    #####: 3644:        case RL_SHADER_UNIFORM_INT: glUniform1iv(locIndex, count, (int *)value); break;
    %%%%%: 3644-block  0
call    0 never executed
    #####: 3645:        case RL_SHADER_UNIFORM_IVEC2: glUniform2iv(locIndex, count, (int *)value); break;
    %%%%%: 3645-block  0
call    0 never executed
    #####: 3646:        case RL_SHADER_UNIFORM_IVEC3: glUniform3iv(locIndex, count, (int *)value); break;
    %%%%%: 3646-block  0
call    0 never executed
    #####: 3647:        case RL_SHADER_UNIFORM_IVEC4: glUniform4iv(locIndex, count, (int *)value); break;
    %%%%%: 3647-block  0
call    0 never executed
    #####: 3648:        case RL_SHADER_UNIFORM_SAMPLER2D: glUniform1iv(locIndex, count, (int *)value); break;
    %%%%%: 3648-block  0
call    0 never executed
    #####: 3649:        default: TRACELOG(RL_LOG_WARNING, "SHADER: Failed to set uniform value, data type not recognized");
    %%%%%: 3649-block  0
call    0 never executed
        -: 3650:    }
        -: 3651:#endif
    #####: 3652:}
        -: 3653:
        -: 3654:// Set shader value attribute
function rlSetVertexAttributeDefault called 0 returned 0% blocks executed 0%
    #####: 3655:void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
        -: 3656:{
        -: 3657:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3658:    switch (attribType)
    %%%%%: 3658-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 3659:    {
    #####: 3660:        case RL_SHADER_ATTRIB_FLOAT: if (count == 1) glVertexAttrib1fv(locIndex, (float *)value); break;
    %%%%%: 3660-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3660-block  1
call    2 never executed
    #####: 3661:        case RL_SHADER_ATTRIB_VEC2: if (count == 2) glVertexAttrib2fv(locIndex, (float *)value); break;
    %%%%%: 3661-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3661-block  1
call    2 never executed
    #####: 3662:        case RL_SHADER_ATTRIB_VEC3: if (count == 3) glVertexAttrib3fv(locIndex, (float *)value); break;
    %%%%%: 3662-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3662-block  1
call    2 never executed
    #####: 3663:        case RL_SHADER_ATTRIB_VEC4: if (count == 4) glVertexAttrib4fv(locIndex, (float *)value); break;
    %%%%%: 3663-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3663-block  1
call    2 never executed
    #####: 3664:        default: TRACELOG(RL_LOG_WARNING, "SHADER: Failed to set attrib default value, data type not recognized");
    %%%%%: 3664-block  0
call    0 never executed
        -: 3665:    }
        -: 3666:#endif
    #####: 3667:}
        -: 3668:
        -: 3669:// Set shader value uniform matrix
function rlSetUniformMatrix called 0 returned 0% blocks executed 0%
    #####: 3670:void rlSetUniformMatrix(int locIndex, Matrix mat)
        -: 3671:{
        -: 3672:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3673:    float matfloat[16] = {
    #####: 3674:        mat.m0, mat.m1, mat.m2, mat.m3,
    #####: 3675:        mat.m4, mat.m5, mat.m6, mat.m7,
    #####: 3676:        mat.m8, mat.m9, mat.m10, mat.m11,
    #####: 3677:        mat.m12, mat.m13, mat.m14, mat.m15
        -: 3678:    };
    #####: 3679:    glUniformMatrix4fv(locIndex, 1, false, matfloat);
    %%%%%: 3679-block  0
call    0 never executed
        -: 3680:#endif
    #####: 3681:}
        -: 3682:
        -: 3683:// Set shader value uniform sampler
function rlSetUniformSampler called 0 returned 0% blocks executed 0%
    #####: 3684:void rlSetUniformSampler(int locIndex, unsigned int textureId)
        -: 3685:{
        -: 3686:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 3687:    // Check if texture is already active
    #####: 3688:    for (int i = 0; i < RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS; i++) if (RLGL.State.activeTextureId[i] == textureId) return;
    %%%%%: 3688-block  0
    %%%%%: 3688-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 3688-block  2
    %%%%%: 3688-block  3
    %%%%%: 3688-block  4
branch  2 never executed
branch  3 never executed
        -: 3689:
        -: 3690:    // Register a new active texture for the internal batch system
        -: 3691:    // NOTE: Default texture is always activated as GL_TEXTURE0
    #####: 3692:    for (int i = 0; i < RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS; i++)
    %%%%%: 3692-block  0
    %%%%%: 3692-block  1
    %%%%%: 3692-block  2
branch  0 never executed
branch  1 never executed
        -: 3693:    {
    #####: 3694:        if (RLGL.State.activeTextureId[i] == 0)
    %%%%%: 3694-block  0
branch  0 never executed
branch  1 never executed
        -: 3695:        {
    #####: 3696:            glUniform1i(locIndex, 1 + i);              // Activate new texture unit
    %%%%%: 3696-block  0
call    0 never executed
    #####: 3697:            RLGL.State.activeTextureId[i] = textureId; // Save texture id for binding on drawing
    #####: 3698:            break;
        -: 3699:        }
        -: 3700:    }
        -: 3701:#endif
        -: 3702:}
        -: 3703:
        -: 3704:// Set shader currently active (id and locations)
function rlSetShader called 0 returned 0% blocks executed 0%
    #####: 3705:void rlSetShader(unsigned int id, int *locs)
        -: 3706:{
        -: 3707:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3708:    if (RLGL.State.currentShaderId != id)
    %%%%%: 3708-block  0
branch  0 never executed
branch  1 never executed
        -: 3709:    {
    #####: 3710:        rlDrawRenderBatch(RLGL.currentBatch);
    %%%%%: 3710-block  0
call    0 never executed
    #####: 3711:        RLGL.State.currentShaderId = id;
    #####: 3712:        RLGL.State.currentShaderLocs = locs;
        -: 3713:    }
        -: 3714:#endif
    #####: 3715:}
        -: 3716:
        -: 3717:// Matrix state management
        -: 3718://-----------------------------------------------------------------------------------------
        -: 3719:// Get internal modelview matrix
function rlGetMatrixModelview called 0 returned 0% blocks executed 0%
    #####: 3720:Matrix rlGetMatrixModelview(void)
        -: 3721:{
    #####: 3722:    Matrix matrix = rlMatrixIdentity();
    %%%%%: 3722-block  0
call    0 never executed
        -: 3723:#if defined(GRAPHICS_API_OPENGL_11)
        -: 3724:    float mat[16];
        -: 3725:    glGetFloatv(GL_MODELVIEW_MATRIX, mat);
        -: 3726:    matrix.m0 = mat[0];
        -: 3727:    matrix.m1 = mat[1];
        -: 3728:    matrix.m2 = mat[2];
        -: 3729:    matrix.m3 = mat[3];
        -: 3730:    matrix.m4 = mat[4];
        -: 3731:    matrix.m5 = mat[5];
        -: 3732:    matrix.m6 = mat[6];
        -: 3733:    matrix.m7 = mat[7];
        -: 3734:    matrix.m8 = mat[8];
        -: 3735:    matrix.m9 = mat[9];
        -: 3736:    matrix.m10 = mat[10];
        -: 3737:    matrix.m11 = mat[11];
        -: 3738:    matrix.m12 = mat[12];
        -: 3739:    matrix.m13 = mat[13];
        -: 3740:    matrix.m14 = mat[14];
        -: 3741:    matrix.m15 = mat[15];
        -: 3742:#else
    #####: 3743:    matrix = RLGL.State.modelview;
        -: 3744:#endif
    #####: 3745:    return matrix;
        -: 3746:}
        -: 3747:
        -: 3748:// Get internal projection matrix
function rlGetMatrixProjection called 0 returned 0% blocks executed 0%
    #####: 3749:Matrix rlGetMatrixProjection(void)
        -: 3750:{
        -: 3751:#if defined(GRAPHICS_API_OPENGL_11)
        -: 3752:    float mat[16];
        -: 3753:    glGetFloatv(GL_PROJECTION_MATRIX,mat);
        -: 3754:    Matrix m;
        -: 3755:    m.m0 = mat[0];
        -: 3756:    m.m1 = mat[1];
        -: 3757:    m.m2 = mat[2];
        -: 3758:    m.m3 = mat[3];
        -: 3759:    m.m4 = mat[4];
        -: 3760:    m.m5 = mat[5];
        -: 3761:    m.m6 = mat[6];
        -: 3762:    m.m7 = mat[7];
        -: 3763:    m.m8 = mat[8];
        -: 3764:    m.m9 = mat[9];
        -: 3765:    m.m10 = mat[10];
        -: 3766:    m.m11 = mat[11];
        -: 3767:    m.m12 = mat[12];
        -: 3768:    m.m13 = mat[13];
        -: 3769:    m.m14 = mat[14];
        -: 3770:    m.m15 = mat[15];
        -: 3771:    return m;
        -: 3772:#else
    #####: 3773:    return RLGL.State.projection;
    %%%%%: 3773-block  0
        -: 3774:#endif
        -: 3775:}
        -: 3776:
        -: 3777:// Get internal accumulated transform matrix
function rlGetMatrixTransform called 0 returned 0% blocks executed 0%
    #####: 3778:Matrix rlGetMatrixTransform(void)
        -: 3779:{
    #####: 3780:    Matrix mat = rlMatrixIdentity();
    %%%%%: 3780-block  0
call    0 never executed
        -: 3781:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 3782:    // TODO: Consider possible transform matrices in the RLGL.State.stack
        -: 3783:    // Is this the right order? or should we start with the first stored matrix instead of the last one?
        -: 3784:    //Matrix matStackTransform = rlMatrixIdentity();
        -: 3785:    //for (int i = RLGL.State.stackCounter; i > 0; i--) matStackTransform = rlMatrixMultiply(RLGL.State.stack[i], matStackTransform);
    #####: 3786:    mat = RLGL.State.transform;
        -: 3787:#endif
    #####: 3788:    return mat;
        -: 3789:}
        -: 3790:
        -: 3791:// Get internal projection matrix for stereo render (selected eye)
function rlGetMatrixProjectionStereo called 0 returned 0% blocks executed 0%
    #####: 3792:RLAPI Matrix rlGetMatrixProjectionStereo(int eye)
        -: 3793:{
    #####: 3794:    Matrix mat = rlMatrixIdentity();
    %%%%%: 3794-block  0
call    0 never executed
        -: 3795:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3796:    mat = RLGL.State.projectionStereo[eye];
        -: 3797:#endif
    #####: 3798:    return mat;
        -: 3799:}
        -: 3800:
        -: 3801:// Get internal view offset matrix for stereo render (selected eye)
function rlGetMatrixViewOffsetStereo called 0 returned 0% blocks executed 0%
    #####: 3802:RLAPI Matrix rlGetMatrixViewOffsetStereo(int eye)
        -: 3803:{
    #####: 3804:    Matrix mat = rlMatrixIdentity();
    %%%%%: 3804-block  0
call    0 never executed
        -: 3805:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3806:    mat = RLGL.State.viewOffsetStereo[eye];
        -: 3807:#endif
    #####: 3808:    return mat;
        -: 3809:}
        -: 3810:
        -: 3811:// Set a custom modelview matrix (replaces internal modelview matrix)
function rlSetMatrixModelview called 0 returned 0% blocks executed 0%
    #####: 3812:void rlSetMatrixModelview(Matrix view)
        -: 3813:{
        -: 3814:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3815:    RLGL.State.modelview = view;
        -: 3816:#endif
    #####: 3817:}
        -: 3818:
        -: 3819:// Set a custom projection matrix (replaces internal projection matrix)
function rlSetMatrixProjection called 0 returned 0% blocks executed 0%
    #####: 3820:void rlSetMatrixProjection(Matrix projection)
        -: 3821:{
        -: 3822:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3823:    RLGL.State.projection = projection;
        -: 3824:#endif
    #####: 3825:}
        -: 3826:
        -: 3827:// Set eyes projection matrices for stereo rendering
function rlSetMatrixProjectionStereo called 0 returned 0% blocks executed 0%
    #####: 3828:void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
        -: 3829:{
        -: 3830:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3831:    RLGL.State.projectionStereo[0] = right;
    #####: 3832:    RLGL.State.projectionStereo[1] = left;
        -: 3833:#endif
    #####: 3834:}
        -: 3835:
        -: 3836:// Set eyes view offsets matrices for stereo rendering
function rlSetMatrixViewOffsetStereo called 0 returned 0% blocks executed 0%
    #####: 3837:void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
        -: 3838:{
        -: 3839:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3840:    RLGL.State.viewOffsetStereo[0] = right;
    #####: 3841:    RLGL.State.viewOffsetStereo[1] = left;
        -: 3842:#endif
    #####: 3843:}
        -: 3844:
        -: 3845:// Load and draw a 1x1 XY quad in NDC
function rlLoadDrawQuad called 0 returned 0% blocks executed 0%
    #####: 3846:void rlLoadDrawQuad(void)
        -: 3847:{
        -: 3848:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3849:    unsigned int quadVAO = 0;
    #####: 3850:    unsigned int quadVBO = 0;
        -: 3851:
    #####: 3852:    float vertices[] = {
        -: 3853:         // Positions         Texcoords
        -: 3854:        -1.0f,  1.0f, 0.0f,   0.0f, 1.0f,
        -: 3855:        -1.0f, -1.0f, 0.0f,   0.0f, 0.0f,
        -: 3856:         1.0f,  1.0f, 0.0f,   1.0f, 1.0f,
        -: 3857:         1.0f, -1.0f, 0.0f,   1.0f, 0.0f,
        -: 3858:    };
        -: 3859:
        -: 3860:    // Gen VAO to contain VBO
    #####: 3861:    glGenVertexArrays(1, &quadVAO);
    %%%%%: 3861-block  0
call    0 never executed
    #####: 3862:    glBindVertexArray(quadVAO);
call    0 never executed
        -: 3863:
        -: 3864:    // Gen and fill vertex buffer (VBO)
    #####: 3865:    glGenBuffers(1, &quadVBO);
call    0 never executed
    #####: 3866:    glBindBuffer(GL_ARRAY_BUFFER, quadVBO);
call    0 never executed
    #####: 3867:    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), &vertices, GL_STATIC_DRAW);
call    0 never executed
        -: 3868:
        -: 3869:    // Bind vertex attributes (position, texcoords)
    #####: 3870:    glEnableVertexAttribArray(0);
call    0 never executed
    #####: 3871:    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5*sizeof(float), (void *)0); // Positions
call    0 never executed
    #####: 3872:    glEnableVertexAttribArray(1);
call    0 never executed
    #####: 3873:    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5*sizeof(float), (void *)(3*sizeof(float))); // Texcoords
call    0 never executed
        -: 3874:
        -: 3875:    // Draw quad
    #####: 3876:    glBindVertexArray(quadVAO);
call    0 never executed
    #####: 3877:    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
call    0 never executed
    #####: 3878:    glBindVertexArray(0);
call    0 never executed
        -: 3879:
        -: 3880:    // Delete buffers (VBO and VAO)
    #####: 3881:    glDeleteBuffers(1, &quadVBO);
call    0 never executed
    #####: 3882:    glDeleteVertexArrays(1, &quadVAO);
call    0 never executed
        -: 3883:#endif
    #####: 3884:}
        -: 3885:
        -: 3886:// Load and draw a 1x1 3D cube in NDC
function rlLoadDrawCube called 0 returned 0% blocks executed 0%
    #####: 3887:void rlLoadDrawCube(void)
        -: 3888:{
        -: 3889:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
    #####: 3890:    unsigned int cubeVAO = 0;
    #####: 3891:    unsigned int cubeVBO = 0;
        -: 3892:
    #####: 3893:    float vertices[] = {
        -: 3894:         // Positions          Normals               Texcoords
        -: 3895:        -1.0f, -1.0f, -1.0f,   0.0f,  0.0f, -1.0f,   0.0f, 0.0f,
        -: 3896:         1.0f,  1.0f, -1.0f,   0.0f,  0.0f, -1.0f,   1.0f, 1.0f,
        -: 3897:         1.0f, -1.0f, -1.0f,   0.0f,  0.0f, -1.0f,   1.0f, 0.0f,
        -: 3898:         1.0f,  1.0f, -1.0f,   0.0f,  0.0f, -1.0f,   1.0f, 1.0f,
        -: 3899:        -1.0f, -1.0f, -1.0f,   0.0f,  0.0f, -1.0f,   0.0f, 0.0f,
        -: 3900:        -1.0f,  1.0f, -1.0f,   0.0f,  0.0f, -1.0f,   0.0f, 1.0f,
        -: 3901:        -1.0f, -1.0f,  1.0f,   0.0f,  0.0f,  1.0f,   0.0f, 0.0f,
        -: 3902:         1.0f, -1.0f,  1.0f,   0.0f,  0.0f,  1.0f,   1.0f, 0.0f,
        -: 3903:         1.0f,  1.0f,  1.0f,   0.0f,  0.0f,  1.0f,   1.0f, 1.0f,
        -: 3904:         1.0f,  1.0f,  1.0f,   0.0f,  0.0f,  1.0f,   1.0f, 1.0f,
        -: 3905:        -1.0f,  1.0f,  1.0f,   0.0f,  0.0f,  1.0f,   0.0f, 1.0f,
        -: 3906:        -1.0f, -1.0f,  1.0f,   0.0f,  0.0f,  1.0f,   0.0f, 0.0f,
        -: 3907:        -1.0f,  1.0f,  1.0f,  -1.0f,  0.0f,  0.0f,   1.0f, 0.0f,
        -: 3908:        -1.0f,  1.0f, -1.0f,  -1.0f,  0.0f,  0.0f,   1.0f, 1.0f,
        -: 3909:        -1.0f, -1.0f, -1.0f,  -1.0f,  0.0f,  0.0f,   0.0f, 1.0f,
        -: 3910:        -1.0f, -1.0f, -1.0f,  -1.0f,  0.0f,  0.0f,   0.0f, 1.0f,
        -: 3911:        -1.0f, -1.0f,  1.0f,  -1.0f,  0.0f,  0.0f,   0.0f, 0.0f,
        -: 3912:        -1.0f,  1.0f,  1.0f,  -1.0f,  0.0f,  0.0f,   1.0f, 0.0f,
        -: 3913:         1.0f,  1.0f,  1.0f,   1.0f,  0.0f,  0.0f,   1.0f, 0.0f,
        -: 3914:         1.0f, -1.0f, -1.0f,   1.0f,  0.0f,  0.0f,   0.0f, 1.0f,
        -: 3915:         1.0f,  1.0f, -1.0f,   1.0f,  0.0f,  0.0f,   1.0f, 1.0f,
        -: 3916:         1.0f, -1.0f, -1.0f,   1.0f,  0.0f,  0.0f,   0.0f, 1.0f,
        -: 3917:         1.0f,  1.0f,  1.0f,   1.0f,  0.0f,  0.0f,   1.0f, 0.0f,
        -: 3918:         1.0f, -1.0f,  1.0f,   1.0f,  0.0f,  0.0f,   0.0f, 0.0f,
        -: 3919:        -1.0f, -1.0f, -1.0f,   0.0f, -1.0f,  0.0f,   0.0f, 1.0f,
        -: 3920:         1.0f, -1.0f, -1.0f,   0.0f, -1.0f,  0.0f,   1.0f, 1.0f,
        -: 3921:         1.0f, -1.0f,  1.0f,   0.0f, -1.0f,  0.0f,   1.0f, 0.0f,
        -: 3922:         1.0f, -1.0f,  1.0f,   0.0f, -1.0f,  0.0f,   1.0f, 0.0f,
        -: 3923:        -1.0f, -1.0f,  1.0f,   0.0f, -1.0f,  0.0f,   0.0f, 0.0f,
        -: 3924:        -1.0f, -1.0f, -1.0f,   0.0f, -1.0f,  0.0f,   0.0f, 1.0f,
        -: 3925:        -1.0f,  1.0f, -1.0f,   0.0f,  1.0f,  0.0f,   0.0f, 1.0f,
        -: 3926:         1.0f,  1.0f,  1.0f,   0.0f,  1.0f,  0.0f,   1.0f, 0.0f,
        -: 3927:         1.0f,  1.0f, -1.0f,   0.0f,  1.0f,  0.0f,   1.0f, 1.0f,
        -: 3928:         1.0f,  1.0f,  1.0f,   0.0f,  1.0f,  0.0f,   1.0f, 0.0f,
        -: 3929:        -1.0f,  1.0f, -1.0f,   0.0f,  1.0f,  0.0f,   0.0f, 1.0f,
        -: 3930:        -1.0f,  1.0f,  1.0f,   0.0f,  1.0f,  0.0f,   0.0f, 0.0f
        -: 3931:    };
        -: 3932:
        -: 3933:    // Gen VAO to contain VBO
    #####: 3934:    glGenVertexArrays(1, &cubeVAO);
    %%%%%: 3934-block  0
call    0 never executed
    #####: 3935:    glBindVertexArray(cubeVAO);
call    0 never executed
        -: 3936:
        -: 3937:    // Gen and fill vertex buffer (VBO)
    #####: 3938:    glGenBuffers(1, &cubeVBO);
call    0 never executed
    #####: 3939:    glBindBuffer(GL_ARRAY_BUFFER, cubeVBO);
call    0 never executed
    #####: 3940:    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
call    0 never executed
        -: 3941:
        -: 3942:    // Bind vertex attributes (position, normals, texcoords)
    #####: 3943:    glBindVertexArray(cubeVAO);
call    0 never executed
    #####: 3944:    glEnableVertexAttribArray(0);
call    0 never executed
    #####: 3945:    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void *)0); // Positions
call    0 never executed
    #####: 3946:    glEnableVertexAttribArray(1);
call    0 never executed
    #####: 3947:    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void *)(3*sizeof(float))); // Normals
call    0 never executed
    #####: 3948:    glEnableVertexAttribArray(2);
call    0 never executed
    #####: 3949:    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void *)(6*sizeof(float))); // Texcoords
call    0 never executed
    #####: 3950:    glBindBuffer(GL_ARRAY_BUFFER, 0);
call    0 never executed
    #####: 3951:    glBindVertexArray(0);
call    0 never executed
        -: 3952:
        -: 3953:    // Draw cube
    #####: 3954:    glBindVertexArray(cubeVAO);
call    0 never executed
    #####: 3955:    glDrawArrays(GL_TRIANGLES, 0, 36);
call    0 never executed
    #####: 3956:    glBindVertexArray(0);
call    0 never executed
        -: 3957:
        -: 3958:    // Delete VBO and VAO
    #####: 3959:    glDeleteBuffers(1, &cubeVBO);
call    0 never executed
    #####: 3960:    glDeleteVertexArrays(1, &cubeVAO);
call    0 never executed
        -: 3961:#endif
    #####: 3962:}
        -: 3963:
        -: 3964:// Get name string for pixel format
function rlGetPixelFormatName called 2 returned 100% blocks executed 17%
        2: 3965:const char *rlGetPixelFormatName(unsigned int format)
        -: 3966:{
        2: 3967:    switch (format)
        2: 3967-block  0
branch  0 taken 0
branch  1 taken 1
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 1
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 0
branch 20 taken 0
branch 21 taken 0
        -: 3968:    {
    #####: 3969:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: return "GRAYSCALE"; break;         // 8 bit per pixel (no alpha)
    %%%%%: 3969-block  0
        1: 3970:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: return "GRAY_ALPHA"; break;       // 8*2 bpp (2 channels)
        1: 3970-block  0
    #####: 3971:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5: return "R5G6B5"; break;               // 16 bpp
    %%%%%: 3971-block  0
    #####: 3972:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8: return "R8G8B8"; break;               // 24 bpp
    %%%%%: 3972-block  0
    #####: 3973:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: return "R5G5B5A1"; break;           // 16 bpp (1 bit alpha)
    %%%%%: 3973-block  0
    #####: 3974:        case RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: return "R4G4B4A4"; break;           // 16 bpp (4 bit alpha)
    %%%%%: 3974-block  0
        1: 3975:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: return "R8G8B8A8"; break;           // 32 bpp
        1: 3975-block  0
    #####: 3976:        case RL_PIXELFORMAT_UNCOMPRESSED_R32: return "R32"; break;                     // 32 bpp (1 channel - float)
    %%%%%: 3976-block  0
    #####: 3977:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32: return "R32G32B32"; break;         // 32*3 bpp (3 channels - float)
    %%%%%: 3977-block  0
    #####: 3978:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: return "R32G32B32A32"; break;   // 32*4 bpp (4 channels - float)
    %%%%%: 3978-block  0
    #####: 3979:        case RL_PIXELFORMAT_COMPRESSED_DXT1_RGB: return "DXT1_RGB"; break;             // 4 bpp (no alpha)
    %%%%%: 3979-block  0
    #####: 3980:        case RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA: return "DXT1_RGBA"; break;           // 4 bpp (1 bit alpha)
    %%%%%: 3980-block  0
    #####: 3981:        case RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA: return "DXT3_RGBA"; break;           // 8 bpp
    %%%%%: 3981-block  0
    #####: 3982:        case RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA: return "DXT5_RGBA"; break;           // 8 bpp
    %%%%%: 3982-block  0
    #####: 3983:        case RL_PIXELFORMAT_COMPRESSED_ETC1_RGB: return "ETC1_RGB"; break;             // 4 bpp
    %%%%%: 3983-block  0
    #####: 3984:        case RL_PIXELFORMAT_COMPRESSED_ETC2_RGB: return "ETC2_RGB"; break;             // 4 bpp
    %%%%%: 3984-block  0
    #####: 3985:        case RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA: return "ETC2_RGBA"; break;       // 8 bpp
    %%%%%: 3985-block  0
    #####: 3986:        case RL_PIXELFORMAT_COMPRESSED_PVRT_RGB: return "PVRT_RGB"; break;             // 4 bpp
    %%%%%: 3986-block  0
    #####: 3987:        case RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA: return "PVRT_RGBA"; break;           // 4 bpp
    %%%%%: 3987-block  0
    #####: 3988:        case RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: return "ASTC_4x4_RGBA"; break;   // 8 bpp
    %%%%%: 3988-block  0
    #####: 3989:        case RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: return "ASTC_8x8_RGBA"; break;   // 2 bpp
    %%%%%: 3989-block  0
    #####: 3990:        default: return "UNKNOWN"; break;
    %%%%%: 3990-block  0
        -: 3991:    }
        -: 3992:}
        -: 3993:
        -: 3994://----------------------------------------------------------------------------------
        -: 3995:// Module specific Functions Definition
        -: 3996://----------------------------------------------------------------------------------
        -: 3997:#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
        -: 3998:// Load default shader (just vertex positioning and texture coloring)
        -: 3999:// NOTE: This shader program is used for internal buffers
        -: 4000:// NOTE: Loaded: RLGL.State.defaultShaderId, RLGL.State.defaultShaderLocs
function rlLoadShaderDefault called 1 returned 100% blocks executed 94%
        1: 4001:static void rlLoadShaderDefault(void)
        -: 4002:{
        1: 4003:    RLGL.State.defaultShaderLocs = (int *)RL_CALLOC(RL_MAX_SHADER_LOCATIONS, sizeof(int));
        -: 4004:
        -: 4005:    // NOTE: All locations must be reseted to -1 (no location)
       33: 4006:    for (int i = 0; i < RL_MAX_SHADER_LOCATIONS; i++) RLGL.State.defaultShaderLocs[i] = -1;
        1: 4006-block  0
       32: 4006-block  1
       33: 4006-block  2
branch  0 taken 32
branch  1 taken 1 (fallthrough)
        -: 4007:
        -: 4008:    // Vertex shader directly defined, no external file required
        1: 4009:    const char *defaultVShaderCode =
        -: 4010:#if defined(GRAPHICS_API_OPENGL_21)
        -: 4011:    "#version 120                       \n"
        -: 4012:    "attribute vec3 vertexPosition;     \n"
        -: 4013:    "attribute vec2 vertexTexCoord;     \n"
        -: 4014:    "attribute vec4 vertexColor;        \n"
        -: 4015:    "varying vec2 fragTexCoord;         \n"
        -: 4016:    "varying vec4 fragColor;            \n"
        -: 4017:#elif defined(GRAPHICS_API_OPENGL_33)
        -: 4018:    "#version 330                       \n"
        -: 4019:    "in vec3 vertexPosition;            \n"
        -: 4020:    "in vec2 vertexTexCoord;            \n"
        -: 4021:    "in vec4 vertexColor;               \n"
        -: 4022:    "out vec2 fragTexCoord;             \n"
        -: 4023:    "out vec4 fragColor;                \n"
        -: 4024:#endif
        -: 4025:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 4026:    "#version 100                       \n"
        -: 4027:    "attribute vec3 vertexPosition;     \n"
        -: 4028:    "attribute vec2 vertexTexCoord;     \n"
        -: 4029:    "attribute vec4 vertexColor;        \n"
        -: 4030:    "varying vec2 fragTexCoord;         \n"
        -: 4031:    "varying vec4 fragColor;            \n"
        -: 4032:#endif
        -: 4033:    "uniform mat4 mvp;                  \n"
        -: 4034:    "void main()                        \n"
        -: 4035:    "{                                  \n"
        -: 4036:    "    fragTexCoord = vertexTexCoord; \n"
        -: 4037:    "    fragColor = vertexColor;       \n"
        -: 4038:    "    gl_Position = mvp*vec4(vertexPosition, 1.0); \n"
        -: 4039:    "}                                  \n";
        -: 4040:
        -: 4041:    // Fragment shader directly defined, no external file required
        1: 4042:    const char *defaultFShaderCode =
        -: 4043:#if defined(GRAPHICS_API_OPENGL_21)
        -: 4044:    "#version 120                       \n"
        -: 4045:    "varying vec2 fragTexCoord;         \n"
        -: 4046:    "varying vec4 fragColor;            \n"
        -: 4047:    "uniform sampler2D texture0;        \n"
        -: 4048:    "uniform vec4 colDiffuse;           \n"
        -: 4049:    "void main()                        \n"
        -: 4050:    "{                                  \n"
        -: 4051:    "    vec4 texelColor = texture2D(texture0, fragTexCoord); \n"
        -: 4052:    "    gl_FragColor = texelColor*colDiffuse*fragColor;      \n"
        -: 4053:    "}                                  \n";
        -: 4054:#elif defined(GRAPHICS_API_OPENGL_33)
        -: 4055:    "#version 330       \n"
        -: 4056:    "in vec2 fragTexCoord;              \n"
        -: 4057:    "in vec4 fragColor;                 \n"
        -: 4058:    "out vec4 finalColor;               \n"
        -: 4059:    "uniform sampler2D texture0;        \n"
        -: 4060:    "uniform vec4 colDiffuse;           \n"
        -: 4061:    "void main()                        \n"
        -: 4062:    "{                                  \n"
        -: 4063:    "    vec4 texelColor = texture(texture0, fragTexCoord);   \n"
        -: 4064:    "    finalColor = texelColor*colDiffuse*fragColor;        \n"
        -: 4065:    "}                                  \n";
        -: 4066:#endif
        -: 4067:#if defined(GRAPHICS_API_OPENGL_ES2)
        -: 4068:    "#version 100                       \n"
        -: 4069:    "precision mediump float;           \n"     // Precision required for OpenGL ES2 (WebGL)
        -: 4070:    "varying vec2 fragTexCoord;         \n"
        -: 4071:    "varying vec4 fragColor;            \n"
        -: 4072:    "uniform sampler2D texture0;        \n"
        -: 4073:    "uniform vec4 colDiffuse;           \n"
        -: 4074:    "void main()                        \n"
        -: 4075:    "{                                  \n"
        -: 4076:    "    vec4 texelColor = texture2D(texture0, fragTexCoord); \n"
        -: 4077:    "    gl_FragColor = texelColor*colDiffuse*fragColor;      \n"
        -: 4078:    "}                                  \n";
        -: 4079:#endif
        -: 4080:
        -: 4081:    // NOTE: Compiled vertex/fragment shaders are kept for re-use
        1: 4082:    RLGL.State.defaultVShaderId = rlCompileShader(defaultVShaderCode, GL_VERTEX_SHADER);     // Compile default vertex shader
        1: 4082-block  0
call    0 returned 1
        1: 4083:    RLGL.State.defaultFShaderId = rlCompileShader(defaultFShaderCode, GL_FRAGMENT_SHADER);   // Compile default fragment shader
call    0 returned 1
        -: 4084:
        1: 4085:    RLGL.State.defaultShaderId = rlLoadShaderProgram(RLGL.State.defaultVShaderId, RLGL.State.defaultFShaderId);
call    0 returned 1
        -: 4086:
        1: 4087:    if (RLGL.State.defaultShaderId > 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4088:    {
        1: 4089:        TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Default shader loaded successfully", RLGL.State.defaultShaderId);
        1: 4089-block  0
call    0 returned 1
        -: 4090:
        -: 4091:        // Set default shader locations: attributes locations
        1: 4092:        RLGL.State.defaultShaderLocs[RL_SHADER_LOC_VERTEX_POSITION] = glGetAttribLocation(RLGL.State.defaultShaderId, "vertexPosition");
call    0 returned 1
        1: 4093:        RLGL.State.defaultShaderLocs[RL_SHADER_LOC_VERTEX_TEXCOORD01] = glGetAttribLocation(RLGL.State.defaultShaderId, "vertexTexCoord");
call    0 returned 1
        1: 4094:        RLGL.State.defaultShaderLocs[RL_SHADER_LOC_VERTEX_COLOR] = glGetAttribLocation(RLGL.State.defaultShaderId, "vertexColor");
call    0 returned 1
        -: 4095:
        -: 4096:        // Set default shader locations: uniform locations
        1: 4097:        RLGL.State.defaultShaderLocs[RL_SHADER_LOC_MATRIX_MVP]  = glGetUniformLocation(RLGL.State.defaultShaderId, "mvp");
call    0 returned 1
        1: 4098:        RLGL.State.defaultShaderLocs[RL_SHADER_LOC_COLOR_DIFFUSE] = glGetUniformLocation(RLGL.State.defaultShaderId, "colDiffuse");
call    0 returned 1
        1: 4099:        RLGL.State.defaultShaderLocs[RL_SHADER_LOC_MAP_DIFFUSE] = glGetUniformLocation(RLGL.State.defaultShaderId, "texture0");
call    0 returned 1
        -: 4100:    }
    #####: 4101:    else TRACELOG(RL_LOG_WARNING, "SHADER: [ID %i] Failed to load default shader", RLGL.State.defaultShaderId);
    %%%%%: 4101-block  0
call    0 never executed
        1: 4102:}
        -: 4103:
        -: 4104:// Unload default shader
        -: 4105:// NOTE: Unloads: RLGL.State.defaultShaderId, RLGL.State.defaultShaderLocs
function rlUnloadShaderDefault called 1 returned 100% blocks executed 100%
        1: 4106:static void rlUnloadShaderDefault(void)
        -: 4107:{
        1: 4108:    glUseProgram(0);
        1: 4108-block  0
call    0 returned 1
        -: 4109:
        1: 4110:    glDetachShader(RLGL.State.defaultShaderId, RLGL.State.defaultVShaderId);
call    0 returned 1
        1: 4111:    glDetachShader(RLGL.State.defaultShaderId, RLGL.State.defaultFShaderId);
call    0 returned 1
        1: 4112:    glDeleteShader(RLGL.State.defaultVShaderId);
call    0 returned 1
        1: 4113:    glDeleteShader(RLGL.State.defaultFShaderId);
call    0 returned 1
        -: 4114:
        1: 4115:    glDeleteProgram(RLGL.State.defaultShaderId);
call    0 returned 1
        -: 4116:
        1: 4117:    RL_FREE(RLGL.State.defaultShaderLocs);
        -: 4118:
        1: 4119:    TRACELOG(RL_LOG_INFO, "SHADER: [ID %i] Default shader unloaded successfully", RLGL.State.defaultShaderId);
call    0 returned 1
        1: 4120:}
        -: 4121:
        -: 4122:#if defined(SUPPORT_GL_DETAILS_INFO)
        -: 4123:// Get compressed format official GL identifier name
        -: 4124:static char *rlGetCompressedFormatName(int format)
        -: 4125:{
        -: 4126:    static char compName[64] = { 0 };
        -: 4127:    memset(compName, 0, 64);
        -: 4128:
        -: 4129:    switch (format)
        -: 4130:    {
        -: 4131:        // GL_EXT_texture_compression_s3tc
        -: 4132:        case 0x83F0: strcpy(compName, "GL_COMPRESSED_RGB_S3TC_DXT1_EXT"); break;
        -: 4133:        case 0x83F1: strcpy(compName, "GL_COMPRESSED_RGBA_S3TC_DXT1_EXT"); break;
        -: 4134:        case 0x83F2: strcpy(compName, "GL_COMPRESSED_RGBA_S3TC_DXT3_EXT"); break;
        -: 4135:        case 0x83F3: strcpy(compName, "GL_COMPRESSED_RGBA_S3TC_DXT5_EXT"); break;
        -: 4136:        // GL_3DFX_texture_compression_FXT1
        -: 4137:        case 0x86B0: strcpy(compName, "GL_COMPRESSED_RGB_FXT1_3DFX"); break;
        -: 4138:        case 0x86B1: strcpy(compName, "GL_COMPRESSED_RGBA_FXT1_3DFX"); break;
        -: 4139:        // GL_IMG_texture_compression_pvrtc
        -: 4140:        case 0x8C00: strcpy(compName, "GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG"); break;
        -: 4141:        case 0x8C01: strcpy(compName, "GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG"); break;
        -: 4142:        case 0x8C02: strcpy(compName, "GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"); break;
        -: 4143:        case 0x8C03: strcpy(compName, "GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"); break;
        -: 4144:        // GL_OES_compressed_ETC1_RGB8_texture
        -: 4145:        case 0x8D64: strcpy(compName, "GL_ETC1_RGB8_OES"); break;
        -: 4146:        // GL_ARB_texture_compression_rgtc
        -: 4147:        case 0x8DBB: strcpy(compName, "GL_COMPRESSED_RED_RGTC1"); break;
        -: 4148:        case 0x8DBC: strcpy(compName, "GL_COMPRESSED_SIGNED_RED_RGTC1"); break;
        -: 4149:        case 0x8DBD: strcpy(compName, "GL_COMPRESSED_RG_RGTC2"); break;
        -: 4150:        case 0x8DBE: strcpy(compName, "GL_COMPRESSED_SIGNED_RG_RGTC2"); break;
        -: 4151:        // GL_ARB_texture_compression_bptc
        -: 4152:        case 0x8E8C: strcpy(compName, "GL_COMPRESSED_RGBA_BPTC_UNORM_ARB"); break;
        -: 4153:        case 0x8E8D: strcpy(compName, "GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB"); break;
        -: 4154:        case 0x8E8E: strcpy(compName, "GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB"); break;
        -: 4155:        case 0x8E8F: strcpy(compName, "GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB"); break;
        -: 4156:        // GL_ARB_ES3_compatibility
        -: 4157:        case 0x9274: strcpy(compName, "GL_COMPRESSED_RGB8_ETC2"); break;
        -: 4158:        case 0x9275: strcpy(compName, "GL_COMPRESSED_SRGB8_ETC2"); break;
        -: 4159:        case 0x9276: strcpy(compName, "GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"); break;
        -: 4160:        case 0x9277: strcpy(compName, "GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"); break;
        -: 4161:        case 0x9278: strcpy(compName, "GL_COMPRESSED_RGBA8_ETC2_EAC"); break;
        -: 4162:        case 0x9279: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"); break;
        -: 4163:        case 0x9270: strcpy(compName, "GL_COMPRESSED_R11_EAC"); break;
        -: 4164:        case 0x9271: strcpy(compName, "GL_COMPRESSED_SIGNED_R11_EAC"); break;
        -: 4165:        case 0x9272: strcpy(compName, "GL_COMPRESSED_RG11_EAC"); break;
        -: 4166:        case 0x9273: strcpy(compName, "GL_COMPRESSED_SIGNED_RG11_EAC"); break;
        -: 4167:        // GL_KHR_texture_compression_astc_hdr
        -: 4168:        case 0x93B0: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_4x4_KHR"); break;
        -: 4169:        case 0x93B1: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_5x4_KHR"); break;
        -: 4170:        case 0x93B2: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_5x5_KHR"); break;
        -: 4171:        case 0x93B3: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_6x5_KHR"); break;
        -: 4172:        case 0x93B4: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_6x6_KHR"); break;
        -: 4173:        case 0x93B5: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_8x5_KHR"); break;
        -: 4174:        case 0x93B6: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_8x6_KHR"); break;
        -: 4175:        case 0x93B7: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_8x8_KHR"); break;
        -: 4176:        case 0x93B8: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_10x5_KHR"); break;
        -: 4177:        case 0x93B9: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_10x6_KHR"); break;
        -: 4178:        case 0x93BA: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_10x8_KHR"); break;
        -: 4179:        case 0x93BB: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_10x10_KHR"); break;
        -: 4180:        case 0x93BC: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_12x10_KHR"); break;
        -: 4181:        case 0x93BD: strcpy(compName, "GL_COMPRESSED_RGBA_ASTC_12x12_KHR"); break;
        -: 4182:        case 0x93D0: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"); break;
        -: 4183:        case 0x93D1: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"); break;
        -: 4184:        case 0x93D2: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"); break;
        -: 4185:        case 0x93D3: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"); break;
        -: 4186:        case 0x93D4: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"); break;
        -: 4187:        case 0x93D5: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"); break;
        -: 4188:        case 0x93D6: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"); break;
        -: 4189:        case 0x93D7: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"); break;
        -: 4190:        case 0x93D8: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"); break;
        -: 4191:        case 0x93D9: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"); break;
        -: 4192:        case 0x93DA: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"); break;
        -: 4193:        case 0x93DB: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"); break;
        -: 4194:        case 0x93DC: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"); break;
        -: 4195:        case 0x93DD: strcpy(compName, "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"); break;
        -: 4196:        default: strcpy(compName, "GL_COMPRESSED_UNKNOWN"); break;
        -: 4197:    }
        -: 4198:
        -: 4199:    return compName;
        -: 4200:}
        -: 4201:#endif  // SUPPORT_GL_DETAILS_INFO
        -: 4202:
        -: 4203:#endif  // GRAPHICS_API_OPENGL_33 || GRAPHICS_API_OPENGL_ES2
        -: 4204:
        -: 4205:#if defined(GRAPHICS_API_OPENGL_11)
        -: 4206:// Mipmaps data is generated after image data
        -: 4207:// NOTE: Only works with RGBA (4 bytes) data!
        -: 4208:static int rlGenTextureMipmapsData(unsigned char *data, int baseWidth, int baseHeight)
        -: 4209:{
        -: 4210:    int mipmapCount = 1;                // Required mipmap levels count (including base level)
        -: 4211:    int width = baseWidth;
        -: 4212:    int height = baseHeight;
        -: 4213:    int size = baseWidth*baseHeight*4;  // Size in bytes (will include mipmaps...), RGBA only
        -: 4214:
        -: 4215:    // Count mipmap levels required
        -: 4216:    while ((width != 1) && (height != 1))
        -: 4217:    {
        -: 4218:        width /= 2;
        -: 4219:        height /= 2;
        -: 4220:
        -: 4221:        TRACELOGD("TEXTURE: Next mipmap size: %i x %i", width, height);
        -: 4222:
        -: 4223:        mipmapCount++;
        -: 4224:
        -: 4225:        size += (width*height*4);       // Add mipmap size (in bytes)
        -: 4226:    }
        -: 4227:
        -: 4228:    TRACELOGD("TEXTURE: Total mipmaps required: %i", mipmapCount);
        -: 4229:    TRACELOGD("TEXTURE: Total size of data required: %i", size);
        -: 4230:
        -: 4231:    unsigned char *temp = RL_REALLOC(data, size);
        -: 4232:
        -: 4233:    if (temp != NULL) data = temp;
        -: 4234:    else TRACELOG(RL_LOG_WARNING, "TEXTURE: Failed to re-allocate required mipmaps memory");
        -: 4235:
        -: 4236:    width = baseWidth;
        -: 4237:    height = baseHeight;
        -: 4238:    size = (width*height*4);    // RGBA: 4 bytes
        -: 4239:
        -: 4240:    // Generate mipmaps
        -: 4241:    // NOTE: Every mipmap data is stored after data (RGBA - 4 bytes)
        -: 4242:    unsigned char *image = (unsigned char *)RL_MALLOC(width*height*4);
        -: 4243:    unsigned char *mipmap = NULL;
        -: 4244:    int offset = 0;
        -: 4245:
        -: 4246:    for (int i = 0; i < size; i += 4)
        -: 4247:    {
        -: 4248:        image[i] = data[i];
        -: 4249:        image[i + 1] = data[i + 1];
        -: 4250:        image[i + 2] = data[i + 2];
        -: 4251:        image[i + 3] = data[i + 3];
        -: 4252:    }
        -: 4253:
        -: 4254:    TRACELOGD("TEXTURE: Mipmap base size (%ix%i)", width, height);
        -: 4255:
        -: 4256:    for (int mip = 1; mip < mipmapCount; mip++)
        -: 4257:    {
        -: 4258:        mipmap = rlGenNextMipmapData(image, width, height);
        -: 4259:
        -: 4260:        offset += (width*height*4); // Size of last mipmap
        -: 4261:
        -: 4262:        width /= 2;
        -: 4263:        height /= 2;
        -: 4264:        size = (width*height*4);    // Mipmap size to store after offset
        -: 4265:
        -: 4266:        // Add mipmap to data
        -: 4267:        for (int i = 0; i < size; i += 4)
        -: 4268:        {
        -: 4269:            data[offset + i] = mipmap[i];
        -: 4270:            data[offset + i + 1] = mipmap[i + 1];
        -: 4271:            data[offset + i + 2] = mipmap[i + 2];
        -: 4272:            data[offset + i + 3] = mipmap[i + 3];
        -: 4273:        }
        -: 4274:
        -: 4275:        RL_FREE(image);
        -: 4276:
        -: 4277:        image = mipmap;
        -: 4278:        mipmap = NULL;
        -: 4279:    }
        -: 4280:
        -: 4281:    RL_FREE(mipmap);       // free mipmap data
        -: 4282:
        -: 4283:    return mipmapCount;
        -: 4284:}
        -: 4285:
        -: 4286:// Manual mipmap generation (basic scaling algorithm)
        -: 4287:static unsigned char *rlGenNextMipmapData(unsigned char *srcData, int srcWidth, int srcHeight)
        -: 4288:{
        -: 4289:    int x2 = 0;
        -: 4290:    int y2 = 0;
        -: 4291:    unsigned char prow[4];
        -: 4292:    unsigned char pcol[4];
        -: 4293:
        -: 4294:    int width = srcWidth/2;
        -: 4295:    int height = srcHeight/2;
        -: 4296:
        -: 4297:    unsigned char *mipmap = (unsigned char *)RL_MALLOC(width*height*4);
        -: 4298:
        -: 4299:    // Scaling algorithm works perfectly (box-filter)
        -: 4300:    for (int y = 0; y < height; y++)
        -: 4301:    {
        -: 4302:        y2 = 2*y;
        -: 4303:
        -: 4304:        for (int x = 0; x < width; x++)
        -: 4305:        {
        -: 4306:            x2 = 2*x;
        -: 4307:
        -: 4308:            prow[0] = (srcData[(y2*srcWidth + x2)*4 + 0] + srcData[(y2*srcWidth + x2 + 1)*4 + 0])/2;
        -: 4309:            prow[1] = (srcData[(y2*srcWidth + x2)*4 + 1] + srcData[(y2*srcWidth + x2 + 1)*4 + 1])/2;
        -: 4310:            prow[2] = (srcData[(y2*srcWidth + x2)*4 + 2] + srcData[(y2*srcWidth + x2 + 1)*4 + 2])/2;
        -: 4311:            prow[3] = (srcData[(y2*srcWidth + x2)*4 + 3] + srcData[(y2*srcWidth + x2 + 1)*4 + 3])/2;
        -: 4312:
        -: 4313:            pcol[0] = (srcData[((y2 + 1)*srcWidth + x2)*4 + 0] + srcData[((y2 + 1)*srcWidth + x2 + 1)*4 + 0])/2;
        -: 4314:            pcol[1] = (srcData[((y2 + 1)*srcWidth + x2)*4 + 1] + srcData[((y2 + 1)*srcWidth + x2 + 1)*4 + 1])/2;
        -: 4315:            pcol[2] = (srcData[((y2 + 1)*srcWidth + x2)*4 + 2] + srcData[((y2 + 1)*srcWidth + x2 + 1)*4 + 2])/2;
        -: 4316:            pcol[3] = (srcData[((y2 + 1)*srcWidth + x2)*4 + 3] + srcData[((y2 + 1)*srcWidth + x2 + 1)*4 + 3])/2;
        -: 4317:
        -: 4318:            mipmap[(y*width + x)*4 + 0] = (prow[0] + pcol[0])/2;
        -: 4319:            mipmap[(y*width + x)*4 + 1] = (prow[1] + pcol[1])/2;
        -: 4320:            mipmap[(y*width + x)*4 + 2] = (prow[2] + pcol[2])/2;
        -: 4321:            mipmap[(y*width + x)*4 + 3] = (prow[3] + pcol[3])/2;
        -: 4322:        }
        -: 4323:    }
        -: 4324:
        -: 4325:    TRACELOGD("TEXTURE: Mipmap generated successfully (%ix%i)", width, height);
        -: 4326:
        -: 4327:    return mipmap;
        -: 4328:}
        -: 4329:#endif  // GRAPHICS_API_OPENGL_11
        -: 4330:
        -: 4331:// Get pixel data size in bytes (image or texture)
        -: 4332:// NOTE: Size depends on pixel format
function rlGetPixelDataSize called 2 returned 100% blocks executed 41%
        2: 4333:static int rlGetPixelDataSize(int width, int height, int format)
        -: 4334:{
        2: 4335:    int dataSize = 0;       // Size in bytes
        2: 4336:    int bpp = 0;            // Bits per pixel
        -: 4337:
        2: 4338:    switch (format)
        2: 4338-block  0
branch  0 taken 0
branch  1 taken 1
branch  2 taken 1
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
        -: 4339:    {
    #####: 4340:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: bpp = 8; break;
    %%%%%: 4340-block  0
        1: 4341:        case RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 4342:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 4343:        case RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        1: 4344:        case RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: bpp = 16; break;
        1: 4344-block  0
        1: 4345:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: bpp = 32; break;
        1: 4345-block  0
    #####: 4346:        case RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8: bpp = 24; break;
    %%%%%: 4346-block  0
    #####: 4347:        case RL_PIXELFORMAT_UNCOMPRESSED_R32: bpp = 32; break;
    %%%%%: 4347-block  0
    #####: 4348:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32: bpp = 32*3; break;
    %%%%%: 4348-block  0
    #####: 4349:        case RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: bpp = 32*4; break;
    %%%%%: 4349-block  0
    #####: 4350:        case RL_PIXELFORMAT_COMPRESSED_DXT1_RGB:
        -: 4351:        case RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA:
        -: 4352:        case RL_PIXELFORMAT_COMPRESSED_ETC1_RGB:
        -: 4353:        case RL_PIXELFORMAT_COMPRESSED_ETC2_RGB:
        -: 4354:        case RL_PIXELFORMAT_COMPRESSED_PVRT_RGB:
    #####: 4355:        case RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA: bpp = 4; break;
    %%%%%: 4355-block  0
    #####: 4356:        case RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA:
        -: 4357:        case RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA:
        -: 4358:        case RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA:
    #####: 4359:        case RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: bpp = 8; break;
    %%%%%: 4359-block  0
    #####: 4360:        case RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: bpp = 2; break;
    %%%%%: 4360-block  0
    #####: 4361:        default: break;
    %%%%%: 4361-block  0
        -: 4362:    }
        -: 4363:
        2: 4364:    dataSize = width*height*bpp/8;  // Total data size in bytes
        -: 4365:
        -: 4366:    // Most compressed formats works on 4x4 blocks,
        -: 4367:    // if texture is smaller, minimum dataSize is 8 or 16
        2: 4368:    if ((width < 4) && (height < 4))
        2: 4368-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 4368-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 4369:    {
       1*: 4370:        if ((format >= RL_PIXELFORMAT_COMPRESSED_DXT1_RGB) && (format < RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA)) dataSize = 8;
        1: 4370-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4370-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 4370-block  2
       1*: 4371:        else if ((format >= RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA) && (format < RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA)) dataSize = 16;
        1: 4371-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4371-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 4371-block  2
        -: 4372:    }
        -: 4373:
        2: 4374:    return dataSize;
        2: 4374-block  0
        -: 4375:}
        -: 4376:
        -: 4377:// Auxiliar math functions
        -: 4378:
        -: 4379:// Get identity matrix
function rlMatrixIdentity called 141 returned 100% blocks executed 100%
      141: 4380:static Matrix rlMatrixIdentity(void)
        -: 4381:{
      141: 4382:    Matrix result = {
        -: 4383:        1.0f, 0.0f, 0.0f, 0.0f,
        -: 4384:        0.0f, 1.0f, 0.0f, 0.0f,
        -: 4385:        0.0f, 0.0f, 1.0f, 0.0f,
        -: 4386:        0.0f, 0.0f, 0.0f, 1.0f
        -: 4387:    };
        -: 4388:
      141: 4389:    return result;
      141: 4389-block  0
        -: 4390:}
        -: 4391:
        -: 4392:// Get two matrix multiplication
        -: 4393:// NOTE: When multiplying matrices... the order matters!
function rlMatrixMultiply called 209 returned 100% blocks executed 100%
      209: 4394:static Matrix rlMatrixMultiply(Matrix left, Matrix right)
        -: 4395:{
      209: 4396:    Matrix result = { 0 };
        -: 4397:
      209: 4398:    result.m0 = left.m0*right.m0 + left.m1*right.m4 + left.m2*right.m8 + left.m3*right.m12;
      209: 4399:    result.m1 = left.m0*right.m1 + left.m1*right.m5 + left.m2*right.m9 + left.m3*right.m13;
      209: 4400:    result.m2 = left.m0*right.m2 + left.m1*right.m6 + left.m2*right.m10 + left.m3*right.m14;
      209: 4401:    result.m3 = left.m0*right.m3 + left.m1*right.m7 + left.m2*right.m11 + left.m3*right.m15;
      209: 4402:    result.m4 = left.m4*right.m0 + left.m5*right.m4 + left.m6*right.m8 + left.m7*right.m12;
      209: 4403:    result.m5 = left.m4*right.m1 + left.m5*right.m5 + left.m6*right.m9 + left.m7*right.m13;
      209: 4404:    result.m6 = left.m4*right.m2 + left.m5*right.m6 + left.m6*right.m10 + left.m7*right.m14;
      209: 4405:    result.m7 = left.m4*right.m3 + left.m5*right.m7 + left.m6*right.m11 + left.m7*right.m15;
      209: 4406:    result.m8 = left.m8*right.m0 + left.m9*right.m4 + left.m10*right.m8 + left.m11*right.m12;
      209: 4407:    result.m9 = left.m8*right.m1 + left.m9*right.m5 + left.m10*right.m9 + left.m11*right.m13;
      209: 4408:    result.m10 = left.m8*right.m2 + left.m9*right.m6 + left.m10*right.m10 + left.m11*right.m14;
      209: 4409:    result.m11 = left.m8*right.m3 + left.m9*right.m7 + left.m10*right.m11 + left.m11*right.m15;
      209: 4410:    result.m12 = left.m12*right.m0 + left.m13*right.m4 + left.m14*right.m8 + left.m15*right.m12;
      209: 4411:    result.m13 = left.m12*right.m1 + left.m13*right.m5 + left.m14*right.m9 + left.m15*right.m13;
      209: 4412:    result.m14 = left.m12*right.m2 + left.m13*right.m6 + left.m14*right.m10 + left.m15*right.m14;
      209: 4413:    result.m15 = left.m12*right.m3 + left.m13*right.m7 + left.m14*right.m11 + left.m15*right.m15;
        -: 4414:
      209: 4415:    return result;
      209: 4415-block  0
        -: 4416:}
        -: 4417:
        -: 4418:#endif  // RLGL_IMPLEMENTATION
