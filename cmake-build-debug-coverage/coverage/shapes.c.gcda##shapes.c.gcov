        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/shapes.c
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\shapes.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\shapes.c.gcda
        -:    0:Runs:1
        -:    1:/**********************************************************************************************
        -:    2:*
        -:    3:*   raylib.shapes - Basic functions to draw 2d Shapes and check collisions
        -:    4:*
        -:    5:*   CONFIGURATION:
        -:    6:*
        -:    7:*   #define SUPPORT_QUADS_DRAW_MODE
        -:    8:*       Use QUADS instead of TRIANGLES for drawing when possible.
        -:    9:*       Some lines-based shapes could still use lines
        -:   10:*
        -:   11:*   LICENSE: zlib/libpng
        -:   12:*
        -:   13:*   Copyright (c) 2013-2021 Ramon Santamaria (@raysan5)
        -:   14:*
        -:   15:*   This software is provided "as-is", without any express or implied warranty. In no event
        -:   16:*   will the authors be held liable for any damages arising from the use of this software.
        -:   17:*
        -:   18:*   Permission is granted to anyone to use this software for any purpose, including commercial
        -:   19:*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
        -:   20:*
        -:   21:*     1. The origin of this software must not be misrepresented; you must not claim that you
        -:   22:*     wrote the original software. If you use this software in a product, an acknowledgment
        -:   23:*     in the product documentation would be appreciated but is not required.
        -:   24:*
        -:   25:*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
        -:   26:*     as being the original software.
        -:   27:*
        -:   28:*     3. This notice may not be removed or altered from any source distribution.
        -:   29:*
        -:   30:**********************************************************************************************/
        -:   31:
        -:   32:#include "raylib.h"     // Declares module functions
        -:   33:
        -:   34:// Check if config flags have been externally provided on compilation line
        -:   35:#if !defined(EXTERNAL_CONFIG_FLAGS)
        -:   36:    #include "config.h"         // Defines module configuration flags
        -:   37:#endif
        -:   38:
        -:   39:#include "rlgl.h"       // OpenGL abstraction layer to OpenGL 1.1, 2.1, 3.3+ or ES2
        -:   40:
        -:   41:#include <math.h>       // Required for: sinf(), asinf(), cosf(), acosf(), sqrtf(), fabsf()
        -:   42:
        -:   43://----------------------------------------------------------------------------------
        -:   44:// Defines and Macros
        -:   45://----------------------------------------------------------------------------------
        -:   46:
        -:   47:// Error rate to calculate how many segments we need to draw a smooth circle,
        -:   48:// taken from https://stackoverflow.com/a/2244088
        -:   49:#ifndef SMOOTH_CIRCLE_ERROR_RATE
        -:   50:    #define SMOOTH_CIRCLE_ERROR_RATE  0.5f
        -:   51:#endif
        -:   52:
        -:   53://----------------------------------------------------------------------------------
        -:   54:// Types and Structures Definition
        -:   55://----------------------------------------------------------------------------------
        -:   56:// Not here...
        -:   57:
        -:   58://----------------------------------------------------------------------------------
        -:   59:// Global Variables Definition
        -:   60://----------------------------------------------------------------------------------
        -:   61:Texture2D texShapes = { 1, 1, 1, 1, 7 };        // Texture used on shapes drawing (usually a white pixel)
        -:   62:Rectangle texShapesRec = { 0, 0, 1, 1 };        // Texture source rectangle used on shapes drawing
        -:   63:
        -:   64://----------------------------------------------------------------------------------
        -:   65:// Module specific Functions Declaration
        -:   66://----------------------------------------------------------------------------------
        -:   67:static float EaseCubicInOut(float t, float b, float c, float d);    // Cubic easing
        -:   68:
        -:   69://----------------------------------------------------------------------------------
        -:   70:// Module Functions Definition
        -:   71://----------------------------------------------------------------------------------
        -:   72:
        -:   73:// Set texture and rectangle to be used on shapes drawing
        -:   74:// NOTE: It can be useful when using basic shapes and one single font,
        -:   75:// defining a font char white rectangle would allow drawing everything in a single draw call
function SetShapesTexture called 1 returned 100% blocks executed 100%
        1:   76:void SetShapesTexture(Texture2D texture, Rectangle source)
        -:   77:{
        1:   78:    texShapes = texture;
        1:   79:    texShapesRec = source;
        1:   80:}
        -:   81:
        -:   82:// Draw a pixel
function DrawPixel called 0 returned 0% blocks executed 0%
    #####:   83:void DrawPixel(int posX, int posY, Color color)
        -:   84:{
    #####:   85:    rlBegin(RL_LINES);
    %%%%%:   85-block  0
call    0 never executed
    #####:   86:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:   87:        rlVertex2i(posX, posY);
call    0 never executed
    #####:   88:        rlVertex2i(posX + 1, posY + 1);
call    0 never executed
    #####:   89:    rlEnd();
call    0 never executed
    #####:   90:}
        -:   91:
        -:   92:// Draw a pixel (Vector version)
function DrawPixelV called 0 returned 0% blocks executed 0%
    #####:   93:void DrawPixelV(Vector2 position, Color color)
        -:   94:{
    #####:   95:    rlBegin(RL_LINES);
    %%%%%:   95-block  0
call    0 never executed
    #####:   96:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:   97:        rlVertex2f(position.x, position.y);
call    0 never executed
    #####:   98:        rlVertex2f(position.x + 1.0f, position.y + 1.0f);
call    0 never executed
    #####:   99:    rlEnd();
call    0 never executed
    #####:  100:}
        -:  101:
        -:  102:// Draw a line
function DrawLine called 0 returned 0% blocks executed 0%
    #####:  103:void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color)
        -:  104:{
    #####:  105:    rlBegin(RL_LINES);
    %%%%%:  105-block  0
call    0 never executed
    #####:  106:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:  107:        rlVertex2i(startPosX, startPosY);
call    0 never executed
    #####:  108:        rlVertex2i(endPosX, endPosY);
call    0 never executed
    #####:  109:    rlEnd();
call    0 never executed
    #####:  110:}
        -:  111:
        -:  112:// Draw a line  (Vector version)
function DrawLineV called 0 returned 0% blocks executed 0%
    #####:  113:void DrawLineV(Vector2 startPos, Vector2 endPos, Color color)
        -:  114:{
    #####:  115:    rlBegin(RL_LINES);
    %%%%%:  115-block  0
call    0 never executed
    #####:  116:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:  117:        rlVertex2f(startPos.x, startPos.y);
call    0 never executed
    #####:  118:        rlVertex2f(endPos.x, endPos.y);
call    0 never executed
    #####:  119:    rlEnd();
call    0 never executed
    #####:  120:}
        -:  121:
        -:  122:// Draw a line defining thickness
function DrawLineEx called 0 returned 0% blocks executed 0%
    #####:  123:void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color)
        -:  124:{
    #####:  125:    Vector2 delta = { endPos.x - startPos.x, endPos.y - startPos.y };
    #####:  126:    float length = sqrtf(delta.x*delta.x + delta.y*delta.y);
        -:  127:
    #####:  128:    if ((length > 0) && (thick > 0))
    %%%%%:  128-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  128-block  1
branch  2 never executed
branch  3 never executed
        -:  129:    {
    #####:  130:        float scale = thick/(2*length);
    #####:  131:        Vector2 radius = { -scale*delta.y, scale*delta.x };
    #####:  132:        Vector2 strip[4] = {
    #####:  133:            { startPos.x - radius.x, startPos.y - radius.y },
    #####:  134:            { startPos.x + radius.x, startPos.y + radius.y },
    #####:  135:            { endPos.x - radius.x, endPos.y - radius.y },
    #####:  136:            { endPos.x + radius.x, endPos.y + radius.y }
        -:  137:        };
        -:  138:
    #####:  139:        DrawTriangleStrip(strip, 4, color);
    %%%%%:  139-block  0
call    0 never executed
        -:  140:    }
    #####:  141:}
        -:  142:
        -:  143:// Draw line using cubic-bezier curves in-out
function DrawLineBezier called 0 returned 0% blocks executed 0%
    #####:  144:void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color)
        -:  145:{
        -:  146:#ifndef BEZIER_LINE_DIVISIONS
        -:  147:    #define BEZIER_LINE_DIVISIONS         24   // Bezier line divisions
        -:  148:#endif
        -:  149:
    #####:  150:    Vector2 previous = startPos;
    #####:  151:    Vector2 current = { 0 };
        -:  152:
    #####:  153:    for (int i = 1; i <= BEZIER_LINE_DIVISIONS; i++)
    %%%%%:  153-block  0
    %%%%%:  153-block  1
branch  0 never executed
branch  1 never executed
        -:  154:    {
        -:  155:        // Cubic easing in-out
        -:  156:        // NOTE: Easing is calculated only for y position value
    #####:  157:        current.y = EaseCubicInOut((float)i, startPos.y, endPos.y - startPos.y, (float)BEZIER_LINE_DIVISIONS);
    %%%%%:  157-block  0
call    0 never executed
    #####:  158:        current.x = previous.x + (endPos.x - startPos.x)/ (float)BEZIER_LINE_DIVISIONS;
        -:  159:
    #####:  160:        DrawLineEx(previous, current, thick, color);
call    0 never executed
        -:  161:
    #####:  162:        previous = current;
        -:  163:    }
    #####:  164:}
        -:  165:
        -:  166:// Draw line using quadratic bezier curves with a control point
function DrawLineBezierQuad called 0 returned 0% blocks executed 0%
    #####:  167:void DrawLineBezierQuad(Vector2 startPos, Vector2 endPos, Vector2 controlPos, float thick, Color color)
        -:  168:{
    #####:  169:    const float step = 1.0f/BEZIER_LINE_DIVISIONS;
        -:  170:
    #####:  171:    Vector2 previous = startPos;
    #####:  172:    Vector2 current = { 0 };
    #####:  173:    float t = 0.0f;
        -:  174:
    #####:  175:    for (int i = 0; i <= BEZIER_LINE_DIVISIONS; i++)
    %%%%%:  175-block  0
    %%%%%:  175-block  1
branch  0 never executed
branch  1 never executed
        -:  176:    {
    #####:  177:        t = step*i;
    #####:  178:        float a = powf(1 - t, 2);
    #####:  179:        float b = 2*(1 - t)*t;
    #####:  180:        float c = powf(t, 2);
        -:  181:
        -:  182:        // NOTE: The easing functions aren't suitable here because they don't take a control point
    #####:  183:        current.y = a*startPos.y + b*controlPos.y + c*endPos.y;
    #####:  184:        current.x = a*startPos.x + b*controlPos.x + c*endPos.x;
        -:  185:
    #####:  186:        DrawLineEx(previous, current, thick, color);
    %%%%%:  186-block  0
call    0 never executed
        -:  187:
    #####:  188:        previous = current;
        -:  189:    }
    #####:  190:}
        -:  191:
        -:  192:// Draw lines sequence
function DrawLineStrip called 0 returned 0% blocks executed 0%
    #####:  193:void DrawLineStrip(Vector2 *points, int pointCount, Color color)
        -:  194:{
    #####:  195:    if (pointCount >= 2)
    %%%%%:  195-block  0
branch  0 never executed
branch  1 never executed
        -:  196:    {
    #####:  197:        rlCheckRenderBatchLimit(pointCount);
    %%%%%:  197-block  0
call    0 never executed
        -:  198:
    #####:  199:        rlBegin(RL_LINES);
call    0 never executed
    #####:  200:            rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
        -:  201:
    #####:  202:            for (int i = 0; i < pointCount - 1; i++)
    %%%%%:  202-block  0
branch  0 never executed
branch  1 never executed
        -:  203:            {
    #####:  204:                rlVertex2f(points[i].x, points[i].y);
    %%%%%:  204-block  0
call    0 never executed
    #####:  205:                rlVertex2f(points[i + 1].x, points[i + 1].y);
call    0 never executed
        -:  206:            }
    #####:  207:        rlEnd();
    %%%%%:  207-block  0
call    0 never executed
        -:  208:    }
    #####:  209:}
        -:  210:
        -:  211:// Draw a color-filled circle
function DrawCircle called 0 returned 0% blocks executed 0%
    #####:  212:void DrawCircle(int centerX, int centerY, float radius, Color color)
        -:  213:{
    #####:  214:    DrawCircleV((Vector2){ (float)centerX, (float)centerY }, radius, color);
    %%%%%:  214-block  0
call    0 never executed
    #####:  215:}
        -:  216:
        -:  217:// Draw a piece of a circle
function DrawCircleSector called 0 returned 0% blocks executed 0%
    #####:  218:void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
        -:  219:{
    #####:  220:    if (radius <= 0.0f) radius = 0.1f;  // Avoid div by zero
    %%%%%:  220-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  220-block  1
        -:  221:
        -:  222:    // Function expects (endAngle > startAngle)
    #####:  223:    if (endAngle < startAngle)
    %%%%%:  223-block  0
branch  0 never executed
branch  1 never executed
        -:  224:    {
        -:  225:        // Swap values
    #####:  226:        float tmp = startAngle;
    #####:  227:        startAngle = endAngle;
    #####:  228:        endAngle = tmp;
    %%%%%:  228-block  0
        -:  229:    }
        -:  230:
    #####:  231:    int minSegments = (int)ceilf((endAngle - startAngle)/90);
        -:  232:
    #####:  233:    if (segments < minSegments)
    %%%%%:  233-block  0
branch  0 never executed
branch  1 never executed
        -:  234:    {
        -:  235:        // Calculate the maximum angle between segments based on the error rate (usually 0.5f)
    #####:  236:        float th = acosf(2*powf(1 - SMOOTH_CIRCLE_ERROR_RATE/radius, 2) - 1);
    #####:  237:        segments = (int)((endAngle - startAngle)*ceilf(2*PI/th)/360);
        -:  238:
    #####:  239:        if (segments <= 0) segments = minSegments;
    %%%%%:  239-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  239-block  1
        -:  240:    }
        -:  241:
    #####:  242:    float stepLength = (endAngle - startAngle)/(float)segments;
    #####:  243:    float angle = startAngle;
        -:  244:
        -:  245:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####:  246:    rlCheckRenderBatchLimit(4*segments/2);
    %%%%%:  246-block  0
call    0 never executed
        -:  247:
    #####:  248:    rlSetTexture(texShapes.id);
call    0 never executed
        -:  249:
    #####:  250:    rlBegin(RL_QUADS);
call    0 never executed
        -:  251:        // NOTE: Every QUAD actually represents two segments
    #####:  252:        for (int i = 0; i < segments/2; i++)
    %%%%%:  252-block  0
branch  0 never executed
branch  1 never executed
        -:  253:        {
    #####:  254:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  254-block  0
call    0 never executed
        -:  255:
    #####:  256:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  257:            rlVertex2f(center.x, center.y);
call    0 never executed
        -:  258:
    #####:  259:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  260:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
call    0 never executed
        -:  261:
    #####:  262:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  263:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius);
call    0 never executed
        -:  264:
    #####:  265:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  266:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength*2))*radius, center.y + cosf(DEG2RAD*(angle + stepLength*2))*radius);
call    0 never executed
        -:  267:
    #####:  268:            angle += (stepLength*2);
        -:  269:        }
        -:  270:
        -:  271:        // NOTE: In case number of segments is odd, we add one last piece to the cake
    #####:  272:        if (segments%2)
    %%%%%:  272-block  0
branch  0 never executed
branch  1 never executed
        -:  273:        {
    #####:  274:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  274-block  0
call    0 never executed
        -:  275:
    #####:  276:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  277:            rlVertex2f(center.x, center.y);
call    0 never executed
        -:  278:
    #####:  279:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  280:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
call    0 never executed
        -:  281:
    #####:  282:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  283:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius);
call    0 never executed
        -:  284:
    #####:  285:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  286:            rlVertex2f(center.x, center.y);
call    0 never executed
        -:  287:        }
    #####:  288:    rlEnd();
    %%%%%:  288-block  0
call    0 never executed
        -:  289:
    #####:  290:    rlSetTexture(0);
call    0 never executed
        -:  291:#else
        -:  292:    rlCheckRenderBatchLimit(3*segments);
        -:  293:
        -:  294:    rlBegin(RL_TRIANGLES);
        -:  295:        for (int i = 0; i < segments; i++)
        -:  296:        {
        -:  297:            rlColor4ub(color.r, color.g, color.b, color.a);
        -:  298:
        -:  299:            rlVertex2f(center.x, center.y);
        -:  300:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
        -:  301:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius);
        -:  302:
        -:  303:            angle += stepLength;
        -:  304:        }
        -:  305:    rlEnd();
        -:  306:#endif
    #####:  307:}
        -:  308:
function DrawCircleSectorLines called 0 returned 0% blocks executed 0%
    #####:  309:void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
        -:  310:{
    #####:  311:    if (radius <= 0.0f) radius = 0.1f;  // Avoid div by zero issue
    %%%%%:  311-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  311-block  1
        -:  312:
        -:  313:    // Function expects (endAngle > startAngle)
    #####:  314:    if (endAngle < startAngle)
    %%%%%:  314-block  0
branch  0 never executed
branch  1 never executed
        -:  315:    {
        -:  316:        // Swap values
    #####:  317:        float tmp = startAngle;
    #####:  318:        startAngle = endAngle;
    #####:  319:        endAngle = tmp;
    %%%%%:  319-block  0
        -:  320:    }
        -:  321:
    #####:  322:    int minSegments = (int)ceilf((endAngle - startAngle)/90);
        -:  323:
    #####:  324:    if (segments < minSegments)
    %%%%%:  324-block  0
branch  0 never executed
branch  1 never executed
        -:  325:    {
        -:  326:        // Calculate the maximum angle between segments based on the error rate (usually 0.5f)
    #####:  327:        float th = acosf(2*powf(1 - SMOOTH_CIRCLE_ERROR_RATE/radius, 2) - 1);
    #####:  328:        segments = (int)((endAngle - startAngle)*ceilf(2*PI/th)/360);
        -:  329:
    #####:  330:        if (segments <= 0) segments = minSegments;
    %%%%%:  330-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  330-block  1
        -:  331:    }
        -:  332:
    #####:  333:    float stepLength = (endAngle - startAngle)/(float)segments;
    #####:  334:    float angle = startAngle;
        -:  335:
        -:  336:    // Hide the cap lines when the circle is full
    #####:  337:    bool showCapLines = true;
    #####:  338:    int limit = 2*(segments + 2);
    #####:  339:    if ((int)(endAngle - startAngle)%360 == 0) { limit = 2*segments; showCapLines = false; }
    %%%%%:  339-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  339-block  1
        -:  340:
    #####:  341:    rlCheckRenderBatchLimit(limit);
    %%%%%:  341-block  0
call    0 never executed
        -:  342:
    #####:  343:    rlBegin(RL_LINES);
call    0 never executed
    #####:  344:        if (showCapLines)
branch  0 never executed
branch  1 never executed
        -:  345:        {
    #####:  346:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  346-block  0
call    0 never executed
    #####:  347:            rlVertex2f(center.x, center.y);
call    0 never executed
    #####:  348:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
call    0 never executed
        -:  349:        }
        -:  350:
    #####:  351:        for (int i = 0; i < segments; i++)
    %%%%%:  351-block  0
    %%%%%:  351-block  1
branch  0 never executed
branch  1 never executed
        -:  352:        {
    #####:  353:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  353-block  0
call    0 never executed
        -:  354:
    #####:  355:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
call    0 never executed
    #####:  356:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius);
call    0 never executed
        -:  357:
    #####:  358:            angle += stepLength;
        -:  359:        }
        -:  360:
    #####:  361:        if (showCapLines)
    %%%%%:  361-block  0
branch  0 never executed
branch  1 never executed
        -:  362:        {
    #####:  363:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  363-block  0
call    0 never executed
    #####:  364:            rlVertex2f(center.x, center.y);
call    0 never executed
    #####:  365:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
call    0 never executed
        -:  366:        }
    #####:  367:    rlEnd();
    %%%%%:  367-block  0
call    0 never executed
    #####:  368:}
        -:  369:
        -:  370:// Draw a gradient-filled circle
        -:  371:// NOTE: Gradient goes from center (color1) to border (color2)
function DrawCircleGradient called 0 returned 0% blocks executed 0%
    #####:  372:void DrawCircleGradient(int centerX, int centerY, float radius, Color color1, Color color2)
        -:  373:{
    #####:  374:    rlCheckRenderBatchLimit(3*36);
    %%%%%:  374-block  0
call    0 never executed
        -:  375:
    #####:  376:    rlBegin(RL_TRIANGLES);
call    0 never executed
    #####:  377:        for (int i = 0; i < 360; i += 10)
    %%%%%:  377-block  0
branch  0 never executed
branch  1 never executed
        -:  378:        {
    #####:  379:            rlColor4ub(color1.r, color1.g, color1.b, color1.a);
    %%%%%:  379-block  0
call    0 never executed
    #####:  380:            rlVertex2f((float)centerX, (float)centerY);
call    0 never executed
    #####:  381:            rlColor4ub(color2.r, color2.g, color2.b, color2.a);
call    0 never executed
    #####:  382:            rlVertex2f((float)centerX + sinf(DEG2RAD*i)*radius, (float)centerY + cosf(DEG2RAD*i)*radius);
call    0 never executed
    #####:  383:            rlColor4ub(color2.r, color2.g, color2.b, color2.a);
call    0 never executed
    #####:  384:            rlVertex2f((float)centerX + sinf(DEG2RAD*(i + 10))*radius, (float)centerY + cosf(DEG2RAD*(i + 10))*radius);
call    0 never executed
        -:  385:        }
    #####:  386:    rlEnd();
    %%%%%:  386-block  0
call    0 never executed
    #####:  387:}
        -:  388:
        -:  389:// Draw a color-filled circle (Vector version)
        -:  390:// NOTE: On OpenGL 3.3 and ES2 we use QUADS to avoid drawing order issues
function DrawCircleV called 0 returned 0% blocks executed 0%
    #####:  391:void DrawCircleV(Vector2 center, float radius, Color color)
        -:  392:{
    #####:  393:    DrawCircleSector(center, radius, 0, 360, 36, color);
    %%%%%:  393-block  0
call    0 never executed
    #####:  394:}
        -:  395:
        -:  396:// Draw circle outline
function DrawCircleLines called 0 returned 0% blocks executed 0%
    #####:  397:void DrawCircleLines(int centerX, int centerY, float radius, Color color)
        -:  398:{
    #####:  399:    rlCheckRenderBatchLimit(2*36);
    %%%%%:  399-block  0
call    0 never executed
        -:  400:
    #####:  401:    rlBegin(RL_LINES);
call    0 never executed
    #####:  402:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
        -:  403:
        -:  404:        // NOTE: Circle outline is drawn pixel by pixel every degree (0 to 360)
    #####:  405:        for (int i = 0; i < 360; i += 10)
    %%%%%:  405-block  0
branch  0 never executed
branch  1 never executed
        -:  406:        {
    #####:  407:            rlVertex2f(centerX + sinf(DEG2RAD*i)*radius, centerY + cosf(DEG2RAD*i)*radius);
    %%%%%:  407-block  0
call    0 never executed
    #####:  408:            rlVertex2f(centerX + sinf(DEG2RAD*(i + 10))*radius, centerY + cosf(DEG2RAD*(i + 10))*radius);
call    0 never executed
        -:  409:        }
    #####:  410:    rlEnd();
    %%%%%:  410-block  0
call    0 never executed
    #####:  411:}
        -:  412:
        -:  413:// Draw ellipse
function DrawEllipse called 0 returned 0% blocks executed 0%
    #####:  414:void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color)
        -:  415:{
    #####:  416:    rlCheckRenderBatchLimit(3*36);
    %%%%%:  416-block  0
call    0 never executed
        -:  417:
    #####:  418:    rlBegin(RL_TRIANGLES);
call    0 never executed
    #####:  419:        for (int i = 0; i < 360; i += 10)
    %%%%%:  419-block  0
branch  0 never executed
branch  1 never executed
        -:  420:        {
    #####:  421:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  421-block  0
call    0 never executed
    #####:  422:            rlVertex2f((float)centerX, (float)centerY);
call    0 never executed
    #####:  423:            rlVertex2f((float)centerX + sinf(DEG2RAD*i)*radiusH, (float)centerY + cosf(DEG2RAD*i)*radiusV);
call    0 never executed
    #####:  424:            rlVertex2f((float)centerX + sinf(DEG2RAD*(i + 10))*radiusH, (float)centerY + cosf(DEG2RAD*(i + 10))*radiusV);
call    0 never executed
        -:  425:        }
    #####:  426:    rlEnd();
    %%%%%:  426-block  0
call    0 never executed
    #####:  427:}
        -:  428:
        -:  429:// Draw ellipse outline
function DrawEllipseLines called 0 returned 0% blocks executed 0%
    #####:  430:void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color)
        -:  431:{
    #####:  432:    rlCheckRenderBatchLimit(2*36);
    %%%%%:  432-block  0
call    0 never executed
        -:  433:
    #####:  434:    rlBegin(RL_LINES);
call    0 never executed
    #####:  435:        for (int i = 0; i < 360; i += 10)
    %%%%%:  435-block  0
branch  0 never executed
branch  1 never executed
        -:  436:        {
    #####:  437:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  437-block  0
call    0 never executed
    #####:  438:            rlVertex2f(centerX + sinf(DEG2RAD*i)*radiusH, centerY + cosf(DEG2RAD*i)*radiusV);
call    0 never executed
    #####:  439:            rlVertex2f(centerX + sinf(DEG2RAD*(i + 10))*radiusH, centerY + cosf(DEG2RAD*(i + 10))*radiusV);
call    0 never executed
        -:  440:        }
    #####:  441:    rlEnd();
    %%%%%:  441-block  0
call    0 never executed
    #####:  442:}
        -:  443:
function DrawRing called 0 returned 0% blocks executed 0%
    #####:  444:void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
        -:  445:{
    #####:  446:    if (startAngle == endAngle) return;
    %%%%%:  446-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  446-block  1
        -:  447:
        -:  448:    // Function expects (outerRadius > innerRadius)
    #####:  449:    if (outerRadius < innerRadius)
    %%%%%:  449-block  0
branch  0 never executed
branch  1 never executed
        -:  450:    {
    #####:  451:        float tmp = outerRadius;
    #####:  452:        outerRadius = innerRadius;
    #####:  453:        innerRadius = tmp;
        -:  454:
    #####:  455:        if (outerRadius <= 0.0f) outerRadius = 0.1f;
    %%%%%:  455-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  455-block  1
        -:  456:    }
        -:  457:
        -:  458:    // Function expects (endAngle > startAngle)
    #####:  459:    if (endAngle < startAngle)
    %%%%%:  459-block  0
branch  0 never executed
branch  1 never executed
        -:  460:    {
        -:  461:        // Swap values
    #####:  462:        float tmp = startAngle;
    #####:  463:        startAngle = endAngle;
    #####:  464:        endAngle = tmp;
    %%%%%:  464-block  0
        -:  465:    }
        -:  466:
    #####:  467:    int minSegments = (int)ceilf((endAngle - startAngle)/90);
        -:  468:
    #####:  469:    if (segments < minSegments)
    %%%%%:  469-block  0
branch  0 never executed
branch  1 never executed
        -:  470:    {
        -:  471:        // Calculate the maximum angle between segments based on the error rate (usually 0.5f)
    #####:  472:        float th = acosf(2*powf(1 - SMOOTH_CIRCLE_ERROR_RATE/outerRadius, 2) - 1);
    #####:  473:        segments = (int)((endAngle - startAngle)*ceilf(2*PI/th)/360);
        -:  474:
    #####:  475:        if (segments <= 0) segments = minSegments;
    %%%%%:  475-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  475-block  1
        -:  476:    }
        -:  477:
        -:  478:    // Not a ring
    #####:  479:    if (innerRadius <= 0.0f)
    %%%%%:  479-block  0
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:        DrawCircleSector(center, outerRadius, startAngle, endAngle, segments, color);
    %%%%%:  481-block  0
call    0 never executed
    #####:  482:        return;
        -:  483:    }
        -:  484:
    #####:  485:    float stepLength = (endAngle - startAngle)/(float)segments;
    #####:  486:    float angle = startAngle;
        -:  487:
        -:  488:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####:  489:    rlCheckRenderBatchLimit(4*segments);
    %%%%%:  489-block  0
call    0 never executed
        -:  490:
    #####:  491:    rlSetTexture(texShapes.id);
call    0 never executed
        -:  492:
    #####:  493:    rlBegin(RL_QUADS);
call    0 never executed
    #####:  494:        for (int i = 0; i < segments; i++)
    %%%%%:  494-block  0
branch  0 never executed
branch  1 never executed
        -:  495:        {
    #####:  496:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  496-block  0
call    0 never executed
        -:  497:
    #####:  498:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  499:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*innerRadius, center.y + cosf(DEG2RAD*angle)*innerRadius);
call    0 never executed
        -:  500:
    #####:  501:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  502:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
call    0 never executed
        -:  503:
    #####:  504:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  505:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*outerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*outerRadius);
call    0 never executed
        -:  506:
    #####:  507:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  508:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*innerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*innerRadius);
call    0 never executed
        -:  509:
    #####:  510:            angle += stepLength;
        -:  511:        }
    #####:  512:    rlEnd();
    %%%%%:  512-block  0
call    0 never executed
        -:  513:
    #####:  514:    rlSetTexture(0);
call    0 never executed
        -:  515:#else
        -:  516:    rlCheckRenderBatchLimit(6*segments);
        -:  517:
        -:  518:    rlBegin(RL_TRIANGLES);
        -:  519:        for (int i = 0; i < segments; i++)
        -:  520:        {
        -:  521:            rlColor4ub(color.r, color.g, color.b, color.a);
        -:  522:
        -:  523:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*innerRadius, center.y + cosf(DEG2RAD*angle)*innerRadius);
        -:  524:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
        -:  525:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*innerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*innerRadius);
        -:  526:
        -:  527:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*innerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*innerRadius);
        -:  528:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
        -:  529:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*outerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*outerRadius);
        -:  530:
        -:  531:            angle += stepLength;
        -:  532:        }
        -:  533:    rlEnd();
        -:  534:#endif
        -:  535:}
        -:  536:
function DrawRingLines called 0 returned 0% blocks executed 0%
    #####:  537:void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
        -:  538:{
    #####:  539:    if (startAngle == endAngle) return;
    %%%%%:  539-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  539-block  1
        -:  540:
        -:  541:    // Function expects (outerRadius > innerRadius)
    #####:  542:    if (outerRadius < innerRadius)
    %%%%%:  542-block  0
branch  0 never executed
branch  1 never executed
        -:  543:    {
    #####:  544:        float tmp = outerRadius;
    #####:  545:        outerRadius = innerRadius;
    #####:  546:        innerRadius = tmp;
        -:  547:
    #####:  548:        if (outerRadius <= 0.0f) outerRadius = 0.1f;
    %%%%%:  548-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  548-block  1
        -:  549:    }
        -:  550:
        -:  551:    // Function expects (endAngle > startAngle)
    #####:  552:    if (endAngle < startAngle)
    %%%%%:  552-block  0
branch  0 never executed
branch  1 never executed
        -:  553:    {
        -:  554:        // Swap values
    #####:  555:        float tmp = startAngle;
    #####:  556:        startAngle = endAngle;
    #####:  557:        endAngle = tmp;
    %%%%%:  557-block  0
        -:  558:    }
        -:  559:
    #####:  560:    int minSegments = (int)ceilf((endAngle - startAngle)/90);
        -:  561:
    #####:  562:    if (segments < minSegments)
    %%%%%:  562-block  0
branch  0 never executed
branch  1 never executed
        -:  563:    {
        -:  564:        // Calculate the maximum angle between segments based on the error rate (usually 0.5f)
    #####:  565:        float th = acosf(2*powf(1 - SMOOTH_CIRCLE_ERROR_RATE/outerRadius, 2) - 1);
    #####:  566:        segments = (int)((endAngle - startAngle)*ceilf(2*PI/th)/360);
        -:  567:
    #####:  568:        if (segments <= 0) segments = minSegments;
    %%%%%:  568-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  568-block  1
        -:  569:    }
        -:  570:
    #####:  571:    if (innerRadius <= 0.0f)
    %%%%%:  571-block  0
branch  0 never executed
branch  1 never executed
        -:  572:    {
    #####:  573:        DrawCircleSectorLines(center, outerRadius, startAngle, endAngle, segments, color);
    %%%%%:  573-block  0
call    0 never executed
    #####:  574:        return;
        -:  575:    }
        -:  576:
    #####:  577:    float stepLength = (endAngle - startAngle)/(float)segments;
    #####:  578:    float angle = startAngle;
        -:  579:
    #####:  580:    bool showCapLines = true;
    #####:  581:    int limit = 4*(segments + 1);
    #####:  582:    if ((int)(endAngle - startAngle)%360 == 0) { limit = 4*segments; showCapLines = false; }
    %%%%%:  582-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  582-block  1
        -:  583:
    #####:  584:    rlCheckRenderBatchLimit(limit);
    %%%%%:  584-block  0
call    0 never executed
        -:  585:
    #####:  586:    rlBegin(RL_LINES);
call    0 never executed
    #####:  587:        if (showCapLines)
branch  0 never executed
branch  1 never executed
        -:  588:        {
    #####:  589:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  589-block  0
call    0 never executed
    #####:  590:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
call    0 never executed
    #####:  591:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*innerRadius, center.y + cosf(DEG2RAD*angle)*innerRadius);
call    0 never executed
        -:  592:        }
        -:  593:
    #####:  594:        for (int i = 0; i < segments; i++)
    %%%%%:  594-block  0
    %%%%%:  594-block  1
branch  0 never executed
branch  1 never executed
        -:  595:        {
    #####:  596:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  596-block  0
call    0 never executed
        -:  597:
    #####:  598:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
call    0 never executed
    #####:  599:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*outerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*outerRadius);
call    0 never executed
        -:  600:
    #####:  601:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*innerRadius, center.y + cosf(DEG2RAD*angle)*innerRadius);
call    0 never executed
    #####:  602:            rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*innerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*innerRadius);
call    0 never executed
        -:  603:
    #####:  604:            angle += stepLength;
        -:  605:        }
        -:  606:
    #####:  607:        if (showCapLines)
    %%%%%:  607-block  0
branch  0 never executed
branch  1 never executed
        -:  608:        {
    #####:  609:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  609-block  0
call    0 never executed
    #####:  610:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
call    0 never executed
    #####:  611:            rlVertex2f(center.x + sinf(DEG2RAD*angle)*innerRadius, center.y + cosf(DEG2RAD*angle)*innerRadius);
call    0 never executed
        -:  612:        }
    #####:  613:    rlEnd();
    %%%%%:  613-block  0
call    0 never executed
        -:  614:}
        -:  615:
        -:  616:// Draw a color-filled rectangle
function DrawRectangle called 728 returned 100% blocks executed 100%
      728:  617:void DrawRectangle(int posX, int posY, int width, int height, Color color)
        -:  618:{
      728:  619:    DrawRectangleV((Vector2){ (float)posX, (float)posY }, (Vector2){ (float)width, (float)height }, color);
      728:  619-block  0
call    0 returned 728
      728:  620:}
        -:  621:
        -:  622:// Draw a color-filled rectangle (Vector version)
        -:  623:// NOTE: On OpenGL 3.3 and ES2 we use QUADS to avoid drawing order issues
function DrawRectangleV called 728 returned 100% blocks executed 100%
      728:  624:void DrawRectangleV(Vector2 position, Vector2 size, Color color)
        -:  625:{
      728:  626:    DrawRectanglePro((Rectangle){ position.x, position.y, size.x, size.y }, (Vector2){ 0.0f, 0.0f }, 0.0f, color);
      728:  626-block  0
call    0 returned 728
      728:  627:}
        -:  628:
        -:  629:// Draw a color-filled rectangle
function DrawRectangleRec called 0 returned 0% blocks executed 0%
    #####:  630:void DrawRectangleRec(Rectangle rec, Color color)
        -:  631:{
    #####:  632:    DrawRectanglePro(rec, (Vector2){ 0.0f, 0.0f }, 0.0f, color);
    %%%%%:  632-block  0
call    0 never executed
    #####:  633:}
        -:  634:
        -:  635:// Draw a color-filled rectangle with pro parameters
function DrawRectanglePro called 728 returned 100% blocks executed 95%
      728:  636:void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color)
        -:  637:{
      728:  638:    rlCheckRenderBatchLimit(4);
      728:  638-block  0
call    0 returned 728
        -:  639:
      728:  640:    Vector2 topLeft = { 0 };
      728:  641:    Vector2 topRight = { 0 };
      728:  642:    Vector2 bottomLeft = { 0 };
      728:  643:    Vector2 bottomRight = { 0 };
        -:  644:
        -:  645:    // Only calculate rotation if needed
      728:  646:    if (rotation == 0.0f)
branch  0 taken 728 (fallthrough)
branch  1 taken 0
        -:  647:    {
      728:  648:        float x = rec.x - origin.x;
      728:  649:        float y = rec.y - origin.y;
      728:  650:        topLeft = (Vector2){ x, y };
      728:  651:        topRight = (Vector2){ x + rec.width, y };
      728:  652:        bottomLeft = (Vector2){ x, y + rec.height };
      728:  653:        bottomRight = (Vector2){ x + rec.width, y + rec.height };
      728:  653-block  0
        -:  654:    }
        -:  655:    else
        -:  656:    {
    #####:  657:        float sinRotation = sinf(rotation*DEG2RAD);
    #####:  658:        float cosRotation = cosf(rotation*DEG2RAD);
    #####:  659:        float x = rec.x;
    #####:  660:        float y = rec.y;
    #####:  661:        float dx = -origin.x;
    #####:  662:        float dy = -origin.y;
        -:  663:
    #####:  664:        topLeft.x = x + dx*cosRotation - dy*sinRotation;
    #####:  665:        topLeft.y = y + dx*sinRotation + dy*cosRotation;
        -:  666:
    #####:  667:        topRight.x = x + (dx + rec.width)*cosRotation - dy*sinRotation;
    #####:  668:        topRight.y = y + (dx + rec.width)*sinRotation + dy*cosRotation;
        -:  669:
    #####:  670:        bottomLeft.x = x + dx*cosRotation - (dy + rec.height)*sinRotation;
    #####:  671:        bottomLeft.y = y + dx*sinRotation + (dy + rec.height)*cosRotation;
        -:  672:
    #####:  673:        bottomRight.x = x + (dx + rec.width)*cosRotation - (dy + rec.height)*sinRotation;
    #####:  674:        bottomRight.y = y + (dx + rec.width)*sinRotation + (dy + rec.height)*cosRotation;
    %%%%%:  674-block  0
        -:  675:    }
        -:  676:
      728:  677:    rlSetTexture(texShapes.id);
      728:  677-block  0
call    0 returned 728
      728:  678:    rlBegin(RL_QUADS);
call    0 returned 728
        -:  679:
      728:  680:        rlNormal3f(0.0f, 0.0f, 1.0f);
call    0 returned 728
      728:  681:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 returned 728
        -:  682:
      728:  683:        rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 returned 728
      728:  684:        rlVertex2f(topLeft.x, topLeft.y);
call    0 returned 728
        -:  685:
      728:  686:        rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 returned 728
      728:  687:        rlVertex2f(bottomLeft.x, bottomLeft.y);
call    0 returned 728
        -:  688:
      728:  689:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 returned 728
      728:  690:        rlVertex2f(bottomRight.x, bottomRight.y);
call    0 returned 728
        -:  691:
      728:  692:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 returned 728
      728:  693:        rlVertex2f(topRight.x, topRight.y);
call    0 returned 728
        -:  694:
      728:  695:    rlEnd();
call    0 returned 728
      728:  696:    rlSetTexture(0);
call    0 returned 728
      728:  697:}
        -:  698:
        -:  699:// Draw a vertical-gradient-filled rectangle
        -:  700:// NOTE: Gradient goes from bottom (color1) to top (color2)
function DrawRectangleGradientV called 0 returned 0% blocks executed 0%
    #####:  701:void DrawRectangleGradientV(int posX, int posY, int width, int height, Color color1, Color color2)
        -:  702:{
    #####:  703:    DrawRectangleGradientEx((Rectangle){ (float)posX, (float)posY, (float)width, (float)height }, color1, color2, color2, color1);
    %%%%%:  703-block  0
call    0 never executed
    #####:  704:}
        -:  705:
        -:  706:// Draw a horizontal-gradient-filled rectangle
        -:  707:// NOTE: Gradient goes from bottom (color1) to top (color2)
function DrawRectangleGradientH called 0 returned 0% blocks executed 0%
    #####:  708:void DrawRectangleGradientH(int posX, int posY, int width, int height, Color color1, Color color2)
        -:  709:{
    #####:  710:    DrawRectangleGradientEx((Rectangle){ (float)posX, (float)posY, (float)width, (float)height }, color1, color1, color2, color2);
    %%%%%:  710-block  0
call    0 never executed
    #####:  711:}
        -:  712:
        -:  713:// Draw a gradient-filled rectangle
        -:  714:// NOTE: Colors refer to corners, starting at top-lef corner and counter-clockwise
function DrawRectangleGradientEx called 0 returned 0% blocks executed 0%
    #####:  715:void DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4)
        -:  716:{
    #####:  717:    rlSetTexture(texShapes.id);
    %%%%%:  717-block  0
call    0 never executed
        -:  718:
    #####:  719:    rlPushMatrix();
call    0 never executed
    #####:  720:        rlBegin(RL_QUADS);
call    0 never executed
    #####:  721:            rlNormal3f(0.0f, 0.0f, 1.0f);
call    0 never executed
        -:  722:
        -:  723:            // NOTE: Default raylib font character 95 is a white square
    #####:  724:            rlColor4ub(col1.r, col1.g, col1.b, col1.a);
call    0 never executed
    #####:  725:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  726:            rlVertex2f(rec.x, rec.y);
call    0 never executed
        -:  727:
    #####:  728:            rlColor4ub(col2.r, col2.g, col2.b, col2.a);
call    0 never executed
    #####:  729:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  730:            rlVertex2f(rec.x, rec.y + rec.height);
call    0 never executed
        -:  731:
    #####:  732:            rlColor4ub(col3.r, col3.g, col3.b, col3.a);
call    0 never executed
    #####:  733:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  734:            rlVertex2f(rec.x + rec.width, rec.y + rec.height);
call    0 never executed
        -:  735:
    #####:  736:            rlColor4ub(col4.r, col4.g, col4.b, col4.a);
call    0 never executed
    #####:  737:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  738:            rlVertex2f(rec.x + rec.width, rec.y);
call    0 never executed
    #####:  739:        rlEnd();
call    0 never executed
    #####:  740:    rlPopMatrix();
call    0 never executed
        -:  741:
    #####:  742:    rlSetTexture(0);
call    0 never executed
    #####:  743:}
        -:  744:
        -:  745:// Draw rectangle outline
        -:  746:// NOTE: On OpenGL 3.3 and ES2 we use QUADS to avoid drawing order issues
function DrawRectangleLines called 0 returned 0% blocks executed 0%
    #####:  747:void DrawRectangleLines(int posX, int posY, int width, int height, Color color)
        -:  748:{
        -:  749:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####:  750:    DrawRectangle(posX, posY, width, 1, color);
    %%%%%:  750-block  0
call    0 never executed
    #####:  751:    DrawRectangle(posX + width - 1, posY + 1, 1, height - 2, color);
call    0 never executed
    #####:  752:    DrawRectangle(posX, posY + height - 1, width, 1, color);
call    0 never executed
    #####:  753:    DrawRectangle(posX, posY + 1, 1, height - 2, color);
call    0 never executed
        -:  754:#else
        -:  755:    rlBegin(RL_LINES);
        -:  756:        rlColor4ub(color.r, color.g, color.b, color.a);
        -:  757:        rlVertex2i(posX + 1, posY + 1);
        -:  758:        rlVertex2i(posX + width, posY + 1);
        -:  759:
        -:  760:        rlVertex2i(posX + width, posY + 1);
        -:  761:        rlVertex2i(posX + width, posY + height);
        -:  762:
        -:  763:        rlVertex2i(posX + width, posY + height);
        -:  764:        rlVertex2i(posX + 1, posY + height);
        -:  765:
        -:  766:        rlVertex2i(posX + 1, posY + height);
        -:  767:        rlVertex2i(posX + 1, posY + 1);
        -:  768:    rlEnd();
        -:  769:#endif
    #####:  770:}
        -:  771:
        -:  772:// Draw rectangle outline with extended parameters
function DrawRectangleLinesEx called 0 returned 0% blocks executed 0%
    #####:  773:void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color)
        -:  774:{
    #####:  775:    if ((lineThick > rec.width) || (lineThick > rec.height))
    %%%%%:  775-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  775-block  1
branch  2 never executed
branch  3 never executed
        -:  776:    {
    #####:  777:        if (rec.width > rec.height) lineThick = rec.height/2;
    %%%%%:  777-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  777-block  1
    #####:  778:        else if (rec.width < rec.height) lineThick = rec.width/2;
    %%%%%:  778-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  778-block  1
        -:  779:    }
        -:  780:
        -:  781:    // When rec = { x, y, 8.0f, 6.0f } and lineThick = 2, the following
        -:  782:    // four rectangles are drawn ([T]op, [B]ottom, [L]eft, [R]ight):
        -:  783:    //
        -:  784:    //   TTTTTTTT
        -:  785:    //   TTTTTTTT
        -:  786:    //   LL    RR
        -:  787:    //   LL    RR
        -:  788:    //   BBBBBBBB
        -:  789:    //   BBBBBBBB
        -:  790:    //
        -:  791:
    #####:  792:    Rectangle top = { rec.x, rec.y, rec.width, lineThick };
    #####:  793:    Rectangle bottom = { rec.x, rec.y - lineThick + rec.height, rec.width, lineThick };
    #####:  794:    Rectangle left = { rec.x, rec.y + lineThick, lineThick, rec.height - lineThick*2.0f };
    #####:  795:    Rectangle right = { rec.x - lineThick + rec.width, rec.y + lineThick, lineThick, rec.height - lineThick*2.0f };
        -:  796:
    #####:  797:    DrawRectangleRec(top, color);
    %%%%%:  797-block  0
call    0 never executed
    #####:  798:    DrawRectangleRec(bottom, color);
call    0 never executed
    #####:  799:    DrawRectangleRec(left, color);
call    0 never executed
    #####:  800:    DrawRectangleRec(right, color);
call    0 never executed
    #####:  801:}
        -:  802:
        -:  803:// Draw rectangle with rounded edges
function DrawRectangleRounded called 0 returned 0% blocks executed 0%
    #####:  804:void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
        -:  805:{
        -:  806:    // Not a rounded rectangle
    #####:  807:    if ((roundness <= 0.0f) || (rec.width < 1) || (rec.height < 1 ))
    %%%%%:  807-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  807-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  807-block  2
branch  4 never executed
branch  5 never executed
        -:  808:    {
    #####:  809:        DrawRectangleRec(rec, color);
    %%%%%:  809-block  0
call    0 never executed
    #####:  810:        return;
    %%%%%:  810-block  0
        -:  811:    }
        -:  812:
    #####:  813:    if (roundness >= 1.0f) roundness = 1.0f;
    %%%%%:  813-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  813-block  1
        -:  814:
        -:  815:    // Calculate corner radius
    #####:  816:    float radius = (rec.width > rec.height)? (rec.height*roundness)/2 : (rec.width*roundness)/2;
    %%%%%:  816-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  816-block  1
    %%%%%:  816-block  2
    #####:  817:    if (radius <= 0.0f) return;
    %%%%%:  817-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  817-block  1
        -:  818:
        -:  819:    // Calculate number of segments to use for the corners
    #####:  820:    if (segments < 4)
    %%%%%:  820-block  0
branch  0 never executed
branch  1 never executed
        -:  821:    {
        -:  822:        // Calculate the maximum angle between segments based on the error rate (usually 0.5f)
    #####:  823:        float th = acosf(2*powf(1 - SMOOTH_CIRCLE_ERROR_RATE/radius, 2) - 1);
    #####:  824:        segments = (int)(ceilf(2*PI/th)/4.0f);
    #####:  825:        if (segments <= 0) segments = 4;
    %%%%%:  825-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  825-block  1
        -:  826:    }
        -:  827:
    #####:  828:    float stepLength = 90.0f/(float)segments;
        -:  829:
        -:  830:    /*
        -:  831:    Quick sketch to make sense of all of this,
        -:  832:    there are 9 parts to draw, also mark the 12 points we'll use
        -:  833:
        -:  834:          P0____________________P1
        -:  835:          /|                    |\
        -:  836:         /1|          2         |3\
        -:  837:     P7 /__|____________________|__\ P2
        -:  838:       |   |P8                P9|   |
        -:  839:       | 8 |          9         | 4 |
        -:  840:       | __|____________________|__ |
        -:  841:     P6 \  |P11              P10|  / P3
        -:  842:         \7|          6         |5/
        -:  843:          \|____________________|/
        -:  844:          P5                    P4
        -:  845:    */
        -:  846:    // Coordinates of the 12 points that define the rounded rect
    #####:  847:    const Vector2 point[12] = {
    #####:  848:        {(float)rec.x + radius, rec.y}, {(float)(rec.x + rec.width) - radius, rec.y}, { rec.x + rec.width, (float)rec.y + radius },     // PO, P1, P2
    #####:  849:        {rec.x + rec.width, (float)(rec.y + rec.height) - radius}, {(float)(rec.x + rec.width) - radius, rec.y + rec.height},           // P3, P4
    #####:  850:        {(float)rec.x + radius, rec.y + rec.height}, { rec.x, (float)(rec.y + rec.height) - radius}, {rec.x, (float)rec.y + radius},    // P5, P6, P7
    #####:  851:        {(float)rec.x + radius, (float)rec.y + radius}, {(float)(rec.x + rec.width) - radius, (float)rec.y + radius},                   // P8, P9
    #####:  852:        {(float)(rec.x + rec.width) - radius, (float)(rec.y + rec.height) - radius}, {(float)rec.x + radius, (float)(rec.y + rec.height) - radius} // P10, P11
        -:  853:    };
        -:  854:
    #####:  855:    const Vector2 centers[4] = { point[8], point[9], point[10], point[11] };
    #####:  856:    const float angles[4] = { 180.0f, 90.0f, 0.0f, 270.0f };
        -:  857:
        -:  858:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####:  859:    rlCheckRenderBatchLimit(16*segments/2 + 5*4);
    %%%%%:  859-block  0
call    0 never executed
        -:  860:
    #####:  861:    rlSetTexture(texShapes.id);
call    0 never executed
        -:  862:
    #####:  863:    rlBegin(RL_QUADS);
call    0 never executed
        -:  864:        // Draw all of the 4 corners: [1] Upper Left Corner, [3] Upper Right Corner, [5] Lower Right Corner, [7] Lower Left Corner
    #####:  865:        for (int k = 0; k < 4; ++k) // Hope the compiler is smart enough to unroll this loop
    %%%%%:  865-block  0
    %%%%%:  865-block  1
branch  0 never executed
branch  1 never executed
        -:  866:        {
    #####:  867:            float angle = angles[k];
    #####:  868:            const Vector2 center = centers[k];
        -:  869:
        -:  870:            // NOTE: Every QUAD actually represents two segments
    #####:  871:            for (int i = 0; i < segments/2; i++)
    %%%%%:  871-block  0
    %%%%%:  871-block  1
branch  0 never executed
branch  1 never executed
        -:  872:            {
    #####:  873:                rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  873-block  0
call    0 never executed
    #####:  874:                rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  875:                rlVertex2f(center.x, center.y);
call    0 never executed
    #####:  876:                rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  877:                rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
call    0 never executed
    #####:  878:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  879:                rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius);
call    0 never executed
    #####:  880:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  881:                rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength*2))*radius, center.y + cosf(DEG2RAD*(angle + stepLength*2))*radius);
call    0 never executed
    #####:  882:                angle += (stepLength*2);
        -:  883:            }
        -:  884:
        -:  885:            // NOTE: In case number of segments is odd, we add one last piece to the cake
    #####:  886:            if (segments%2)
    %%%%%:  886-block  0
branch  0 never executed
branch  1 never executed
        -:  887:            {
    #####:  888:                rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  888-block  0
call    0 never executed
    #####:  889:                rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  890:                rlVertex2f(center.x, center.y);
call    0 never executed
    #####:  891:                rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  892:                rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
call    0 never executed
    #####:  893:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  894:                rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius);
call    0 never executed
    #####:  895:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  896:                rlVertex2f(center.x, center.y);
call    0 never executed
        -:  897:            }
        -:  898:        }
        -:  899:
        -:  900:        // [2] Upper Rectangle
    #####:  901:        rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%:  901-block  0
call    0 never executed
    #####:  902:        rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  903:        rlVertex2f(point[0].x, point[0].y);
call    0 never executed
    #####:  904:        rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  905:        rlVertex2f(point[8].x, point[8].y);
call    0 never executed
    #####:  906:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  907:        rlVertex2f(point[9].x, point[9].y);
call    0 never executed
    #####:  908:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  909:        rlVertex2f(point[1].x, point[1].y);
call    0 never executed
        -:  910:
        -:  911:        // [4] Right Rectangle
    #####:  912:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:  913:        rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  914:        rlVertex2f(point[2].x, point[2].y);
call    0 never executed
    #####:  915:        rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  916:        rlVertex2f(point[9].x, point[9].y);
call    0 never executed
    #####:  917:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  918:        rlVertex2f(point[10].x, point[10].y);
call    0 never executed
    #####:  919:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  920:        rlVertex2f(point[3].x, point[3].y);
call    0 never executed
        -:  921:
        -:  922:        // [6] Bottom Rectangle
    #####:  923:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:  924:        rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  925:        rlVertex2f(point[11].x, point[11].y);
call    0 never executed
    #####:  926:        rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  927:        rlVertex2f(point[5].x, point[5].y);
call    0 never executed
    #####:  928:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  929:        rlVertex2f(point[4].x, point[4].y);
call    0 never executed
    #####:  930:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  931:        rlVertex2f(point[10].x, point[10].y);
call    0 never executed
        -:  932:
        -:  933:        // [8] Left Rectangle
    #####:  934:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:  935:        rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  936:        rlVertex2f(point[7].x, point[7].y);
call    0 never executed
    #####:  937:        rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  938:        rlVertex2f(point[6].x, point[6].y);
call    0 never executed
    #####:  939:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  940:        rlVertex2f(point[11].x, point[11].y);
call    0 never executed
    #####:  941:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  942:        rlVertex2f(point[8].x, point[8].y);
call    0 never executed
        -:  943:
        -:  944:        // [9] Middle Rectangle
    #####:  945:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####:  946:        rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  947:        rlVertex2f(point[8].x, point[8].y);
call    0 never executed
    #####:  948:        rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  949:        rlVertex2f(point[11].x, point[11].y);
call    0 never executed
    #####:  950:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####:  951:        rlVertex2f(point[10].x, point[10].y);
call    0 never executed
    #####:  952:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####:  953:        rlVertex2f(point[9].x, point[9].y);
call    0 never executed
        -:  954:
    #####:  955:    rlEnd();
call    0 never executed
    #####:  956:    rlSetTexture(0);
call    0 never executed
        -:  957:#else
        -:  958:    rlCheckRenderBatchLimit(12*segments + 5*6); // 4 corners with 3 vertices per segment + 5 rectangles with 6 vertices each
        -:  959:
        -:  960:    rlBegin(RL_TRIANGLES);
        -:  961:
        -:  962:        // Draw all of the 4 corners: [1] Upper Left Corner, [3] Upper Right Corner, [5] Lower Right Corner, [7] Lower Left Corner
        -:  963:        for (int k = 0; k < 4; ++k) // Hope the compiler is smart enough to unroll this loop
        -:  964:        {
        -:  965:            float angle = angles[k];
        -:  966:            const Vector2 center = centers[k];
        -:  967:            for (int i = 0; i < segments; i++)
        -:  968:            {
        -:  969:                rlColor4ub(color.r, color.g, color.b, color.a);
        -:  970:                rlVertex2f(center.x, center.y);
        -:  971:                rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius);
        -:  972:                rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius);
        -:  973:                angle += stepLength;
        -:  974:            }
        -:  975:        }
        -:  976:
        -:  977:        // [2] Upper Rectangle
        -:  978:        rlColor4ub(color.r, color.g, color.b, color.a);
        -:  979:        rlVertex2f(point[0].x, point[0].y);
        -:  980:        rlVertex2f(point[8].x, point[8].y);
        -:  981:        rlVertex2f(point[9].x, point[9].y);
        -:  982:        rlVertex2f(point[1].x, point[1].y);
        -:  983:        rlVertex2f(point[0].x, point[0].y);
        -:  984:        rlVertex2f(point[9].x, point[9].y);
        -:  985:
        -:  986:        // [4] Right Rectangle
        -:  987:        rlColor4ub(color.r, color.g, color.b, color.a);
        -:  988:        rlVertex2f(point[9].x, point[9].y);
        -:  989:        rlVertex2f(point[10].x, point[10].y);
        -:  990:        rlVertex2f(point[3].x, point[3].y);
        -:  991:        rlVertex2f(point[2].x, point[2].y);
        -:  992:        rlVertex2f(point[9].x, point[9].y);
        -:  993:        rlVertex2f(point[3].x, point[3].y);
        -:  994:
        -:  995:        // [6] Bottom Rectangle
        -:  996:        rlColor4ub(color.r, color.g, color.b, color.a);
        -:  997:        rlVertex2f(point[11].x, point[11].y);
        -:  998:        rlVertex2f(point[5].x, point[5].y);
        -:  999:        rlVertex2f(point[4].x, point[4].y);
        -: 1000:        rlVertex2f(point[10].x, point[10].y);
        -: 1001:        rlVertex2f(point[11].x, point[11].y);
        -: 1002:        rlVertex2f(point[4].x, point[4].y);
        -: 1003:
        -: 1004:        // [8] Left Rectangle
        -: 1005:        rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1006:        rlVertex2f(point[7].x, point[7].y);
        -: 1007:        rlVertex2f(point[6].x, point[6].y);
        -: 1008:        rlVertex2f(point[11].x, point[11].y);
        -: 1009:        rlVertex2f(point[8].x, point[8].y);
        -: 1010:        rlVertex2f(point[7].x, point[7].y);
        -: 1011:        rlVertex2f(point[11].x, point[11].y);
        -: 1012:
        -: 1013:        // [9] Middle Rectangle
        -: 1014:        rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1015:        rlVertex2f(point[8].x, point[8].y);
        -: 1016:        rlVertex2f(point[11].x, point[11].y);
        -: 1017:        rlVertex2f(point[10].x, point[10].y);
        -: 1018:        rlVertex2f(point[9].x, point[9].y);
        -: 1019:        rlVertex2f(point[8].x, point[8].y);
        -: 1020:        rlVertex2f(point[10].x, point[10].y);
        -: 1021:    rlEnd();
        -: 1022:#endif
        -: 1023:}
        -: 1024:
        -: 1025:// Draw rectangle with rounded edges outline
function DrawRectangleRoundedLines called 0 returned 0% blocks executed 0%
    #####: 1026:void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, float lineThick, Color color)
        -: 1027:{
    #####: 1028:    if (lineThick < 0) lineThick = 0;
    %%%%%: 1028-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1028-block  1
        -: 1029:
        -: 1030:    // Not a rounded rectangle
    #####: 1031:    if (roundness <= 0.0f)
    %%%%%: 1031-block  0
branch  0 never executed
branch  1 never executed
        -: 1032:    {
    #####: 1033:        DrawRectangleLinesEx((Rectangle){rec.x-lineThick, rec.y-lineThick, rec.width+2*lineThick, rec.height+2*lineThick}, lineThick, color);
    %%%%%: 1033-block  0
call    0 never executed
    #####: 1034:        return;
        -: 1035:    }
        -: 1036:
    #####: 1037:    if (roundness >= 1.0f) roundness = 1.0f;
    %%%%%: 1037-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1037-block  1
        -: 1038:
        -: 1039:    // Calculate corner radius
    #####: 1040:    float radius = (rec.width > rec.height)? (rec.height*roundness)/2 : (rec.width*roundness)/2;
    %%%%%: 1040-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1040-block  1
    %%%%%: 1040-block  2
    #####: 1041:    if (radius <= 0.0f) return;
    %%%%%: 1041-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1041-block  1
        -: 1042:
        -: 1043:    // Calculate number of segments to use for the corners
    #####: 1044:    if (segments < 4)
    %%%%%: 1044-block  0
branch  0 never executed
branch  1 never executed
        -: 1045:    {
        -: 1046:        // Calculate the maximum angle between segments based on the error rate (usually 0.5f)
    #####: 1047:        float th = acosf(2*powf(1 - SMOOTH_CIRCLE_ERROR_RATE/radius, 2) - 1);
    #####: 1048:        segments = (int)(ceilf(2*PI/th)/2.0f);
    #####: 1049:        if (segments <= 0) segments = 4;
    %%%%%: 1049-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1049-block  1
        -: 1050:    }
        -: 1051:
    #####: 1052:    float stepLength = 90.0f/(float)segments;
    #####: 1053:    const float outerRadius = radius + lineThick, innerRadius = radius;
        -: 1054:
        -: 1055:    /*
        -: 1056:    Quick sketch to make sense of all of this,
        -: 1057:    marks the 16 + 4(corner centers P16-19) points we'll use
        -: 1058:
        -: 1059:           P0 ================== P1
        -: 1060:          // P8                P9 \\
        -: 1061:         //                        \\
        -: 1062:     P7 // P15                  P10 \\ P2
        -: 1063:       ||   *P16             P17*    ||
        -: 1064:       ||                            ||
        -: 1065:       || P14                   P11  ||
        -: 1066:     P6 \\  *P19             P18*   // P3
        -: 1067:         \\                        //
        -: 1068:          \\ P13              P12 //
        -: 1069:           P5 ================== P4
        -: 1070:    */
    #####: 1071:    const Vector2 point[16] = {
    #####: 1072:        {(float)rec.x + innerRadius, rec.y - lineThick}, {(float)(rec.x + rec.width) - innerRadius, rec.y - lineThick}, { rec.x + rec.width + lineThick, (float)rec.y + innerRadius }, // PO, P1, P2
    #####: 1073:        {rec.x + rec.width + lineThick, (float)(rec.y + rec.height) - innerRadius}, {(float)(rec.x + rec.width) - innerRadius, rec.y + rec.height + lineThick}, // P3, P4
    #####: 1074:        {(float)rec.x + innerRadius, rec.y + rec.height + lineThick}, { rec.x - lineThick, (float)(rec.y + rec.height) - innerRadius}, {rec.x - lineThick, (float)rec.y + innerRadius}, // P5, P6, P7
    #####: 1075:        {(float)rec.x + innerRadius, rec.y}, {(float)(rec.x + rec.width) - innerRadius, rec.y}, // P8, P9
    #####: 1076:        { rec.x + rec.width, (float)rec.y + innerRadius }, {rec.x + rec.width, (float)(rec.y + rec.height) - innerRadius}, // P10, P11
    #####: 1077:        {(float)(rec.x + rec.width) - innerRadius, rec.y + rec.height}, {(float)rec.x + innerRadius, rec.y + rec.height}, // P12, P13
    #####: 1078:        { rec.x, (float)(rec.y + rec.height) - innerRadius}, {rec.x, (float)rec.y + innerRadius} // P14, P15
        -: 1079:    };
        -: 1080:
    #####: 1081:    const Vector2 centers[4] = {
    #####: 1082:        {(float)rec.x + innerRadius, (float)rec.y + innerRadius}, {(float)(rec.x + rec.width) - innerRadius, (float)rec.y + innerRadius}, // P16, P17
    #####: 1083:        {(float)(rec.x + rec.width) - innerRadius, (float)(rec.y + rec.height) - innerRadius}, {(float)rec.x + innerRadius, (float)(rec.y + rec.height) - innerRadius} // P18, P19
        -: 1084:    };
        -: 1085:
    #####: 1086:    const float angles[4] = { 180.0f, 90.0f, 0.0f, 270.0f };
        -: 1087:
    #####: 1088:    if (lineThick > 1)
    %%%%%: 1088-block  0
branch  0 never executed
branch  1 never executed
        -: 1089:    {
        -: 1090:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####: 1091:        rlCheckRenderBatchLimit(4*4*segments + 4*4); // 4 corners with 4 vertices for each segment + 4 rectangles with 4 vertices each
    %%%%%: 1091-block  0
call    0 never executed
        -: 1092:
    #####: 1093:        rlSetTexture(texShapes.id);
call    0 never executed
        -: 1094:
    #####: 1095:        rlBegin(RL_QUADS);
call    0 never executed
        -: 1096:
        -: 1097:            // Draw all of the 4 corners first: Upper Left Corner, Upper Right Corner, Lower Right Corner, Lower Left Corner
    #####: 1098:            for (int k = 0; k < 4; ++k) // Hope the compiler is smart enough to unroll this loop
    %%%%%: 1098-block  0
    %%%%%: 1098-block  1
branch  0 never executed
branch  1 never executed
        -: 1099:            {
    #####: 1100:                float angle = angles[k];
    #####: 1101:                const Vector2 center = centers[k];
    #####: 1102:                for (int i = 0; i < segments; i++)
    %%%%%: 1102-block  0
    %%%%%: 1102-block  1
branch  0 never executed
branch  1 never executed
        -: 1103:                {
    #####: 1104:                    rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%: 1104-block  0
call    0 never executed
    #####: 1105:                    rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1106:                    rlVertex2f(center.x + sinf(DEG2RAD*angle)*innerRadius, center.y + cosf(DEG2RAD*angle)*innerRadius);
call    0 never executed
    #####: 1107:                    rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1108:                    rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
call    0 never executed
    #####: 1109:                    rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1110:                    rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*outerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*outerRadius);
call    0 never executed
    #####: 1111:                    rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1112:                    rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*innerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*innerRadius);
call    0 never executed
        -: 1113:
    #####: 1114:                    angle += stepLength;
        -: 1115:                }
        -: 1116:            }
        -: 1117:
        -: 1118:            // Upper rectangle
    #####: 1119:            rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%: 1119-block  0
call    0 never executed
    #####: 1120:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1121:            rlVertex2f(point[0].x, point[0].y);
call    0 never executed
    #####: 1122:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1123:            rlVertex2f(point[8].x, point[8].y);
call    0 never executed
    #####: 1124:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1125:            rlVertex2f(point[9].x, point[9].y);
call    0 never executed
    #####: 1126:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1127:            rlVertex2f(point[1].x, point[1].y);
call    0 never executed
        -: 1128:
        -: 1129:            // Right rectangle
    #####: 1130:            rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####: 1131:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1132:            rlVertex2f(point[2].x, point[2].y);
call    0 never executed
    #####: 1133:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1134:            rlVertex2f(point[10].x, point[10].y);
call    0 never executed
    #####: 1135:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1136:            rlVertex2f(point[11].x, point[11].y);
call    0 never executed
    #####: 1137:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1138:            rlVertex2f(point[3].x, point[3].y);
call    0 never executed
        -: 1139:
        -: 1140:            // Lower rectangle
    #####: 1141:            rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####: 1142:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1143:            rlVertex2f(point[13].x, point[13].y);
call    0 never executed
    #####: 1144:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1145:            rlVertex2f(point[5].x, point[5].y);
call    0 never executed
    #####: 1146:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1147:            rlVertex2f(point[4].x, point[4].y);
call    0 never executed
    #####: 1148:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1149:            rlVertex2f(point[12].x, point[12].y);
call    0 never executed
        -: 1150:
        -: 1151:            // Left rectangle
    #####: 1152:            rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####: 1153:            rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1154:            rlVertex2f(point[15].x, point[15].y);
call    0 never executed
    #####: 1155:            rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1156:            rlVertex2f(point[7].x, point[7].y);
call    0 never executed
    #####: 1157:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1158:            rlVertex2f(point[6].x, point[6].y);
call    0 never executed
    #####: 1159:            rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1160:            rlVertex2f(point[14].x, point[14].y);
call    0 never executed
        -: 1161:
    #####: 1162:        rlEnd();
call    0 never executed
    #####: 1163:        rlSetTexture(0);
call    0 never executed
        -: 1164:#else
        -: 1165:        rlCheckRenderBatchLimit(4*6*segments + 4*6); // 4 corners with 6(2*3) vertices for each segment + 4 rectangles with 6 vertices each
        -: 1166:
        -: 1167:        rlBegin(RL_TRIANGLES);
        -: 1168:
        -: 1169:            // Draw all of the 4 corners first: Upper Left Corner, Upper Right Corner, Lower Right Corner, Lower Left Corner
        -: 1170:            for (int k = 0; k < 4; ++k) // Hope the compiler is smart enough to unroll this loop
        -: 1171:            {
        -: 1172:                float angle = angles[k];
        -: 1173:                const Vector2 center = centers[k];
        -: 1174:
        -: 1175:                for (int i = 0; i < segments; i++)
        -: 1176:                {
        -: 1177:                    rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1178:
        -: 1179:                    rlVertex2f(center.x + sinf(DEG2RAD*angle)*innerRadius, center.y + cosf(DEG2RAD*angle)*innerRadius);
        -: 1180:                    rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
        -: 1181:                    rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*innerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*innerRadius);
        -: 1182:
        -: 1183:                    rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*innerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*innerRadius);
        -: 1184:                    rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
        -: 1185:                    rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*outerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*outerRadius);
        -: 1186:
        -: 1187:                    angle += stepLength;
        -: 1188:                }
        -: 1189:            }
        -: 1190:
        -: 1191:            // Upper rectangle
        -: 1192:            rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1193:            rlVertex2f(point[0].x, point[0].y);
        -: 1194:            rlVertex2f(point[8].x, point[8].y);
        -: 1195:            rlVertex2f(point[9].x, point[9].y);
        -: 1196:            rlVertex2f(point[1].x, point[1].y);
        -: 1197:            rlVertex2f(point[0].x, point[0].y);
        -: 1198:            rlVertex2f(point[9].x, point[9].y);
        -: 1199:
        -: 1200:            // Right rectangle
        -: 1201:            rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1202:            rlVertex2f(point[10].x, point[10].y);
        -: 1203:            rlVertex2f(point[11].x, point[11].y);
        -: 1204:            rlVertex2f(point[3].x, point[3].y);
        -: 1205:            rlVertex2f(point[2].x, point[2].y);
        -: 1206:            rlVertex2f(point[10].x, point[10].y);
        -: 1207:            rlVertex2f(point[3].x, point[3].y);
        -: 1208:
        -: 1209:            // Lower rectangle
        -: 1210:            rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1211:            rlVertex2f(point[13].x, point[13].y);
        -: 1212:            rlVertex2f(point[5].x, point[5].y);
        -: 1213:            rlVertex2f(point[4].x, point[4].y);
        -: 1214:            rlVertex2f(point[12].x, point[12].y);
        -: 1215:            rlVertex2f(point[13].x, point[13].y);
        -: 1216:            rlVertex2f(point[4].x, point[4].y);
        -: 1217:
        -: 1218:            // Left rectangle
        -: 1219:            rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1220:            rlVertex2f(point[7].x, point[7].y);
        -: 1221:            rlVertex2f(point[6].x, point[6].y);
        -: 1222:            rlVertex2f(point[14].x, point[14].y);
        -: 1223:            rlVertex2f(point[15].x, point[15].y);
        -: 1224:            rlVertex2f(point[7].x, point[7].y);
        -: 1225:            rlVertex2f(point[14].x, point[14].y);
        -: 1226:        rlEnd();
        -: 1227:#endif
        -: 1228:    }
        -: 1229:    else
        -: 1230:    {
        -: 1231:        // Use LINES to draw the outline
    #####: 1232:        rlCheckRenderBatchLimit(8*segments + 4*2); // 4 corners with 2 vertices for each segment + 4 rectangles with 2 vertices each
    %%%%%: 1232-block  0
call    0 never executed
        -: 1233:
    #####: 1234:        rlBegin(RL_LINES);
call    0 never executed
        -: 1235:
        -: 1236:            // Draw all of the 4 corners first: Upper Left Corner, Upper Right Corner, Lower Right Corner, Lower Left Corner
    #####: 1237:            for (int k = 0; k < 4; ++k) // Hope the compiler is smart enough to unroll this loop
    %%%%%: 1237-block  0
    %%%%%: 1237-block  1
branch  0 never executed
branch  1 never executed
        -: 1238:            {
    #####: 1239:                float angle = angles[k];
    #####: 1240:                const Vector2 center = centers[k];
        -: 1241:
    #####: 1242:                for (int i = 0; i < segments; i++)
    %%%%%: 1242-block  0
    %%%%%: 1242-block  1
branch  0 never executed
branch  1 never executed
        -: 1243:                {
    #####: 1244:                    rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%: 1244-block  0
call    0 never executed
    #####: 1245:                    rlVertex2f(center.x + sinf(DEG2RAD*angle)*outerRadius, center.y + cosf(DEG2RAD*angle)*outerRadius);
call    0 never executed
    #####: 1246:                    rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*outerRadius, center.y + cosf(DEG2RAD*(angle + stepLength))*outerRadius);
call    0 never executed
    #####: 1247:                    angle += stepLength;
        -: 1248:                }
        -: 1249:            }
        -: 1250:
        -: 1251:            // And now the remaining 4 lines
    #####: 1252:            for (int i = 0; i < 8; i += 2)
    %%%%%: 1252-block  0
    %%%%%: 1252-block  1
branch  0 never executed
branch  1 never executed
        -: 1253:            {
    #####: 1254:                rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%: 1254-block  0
call    0 never executed
    #####: 1255:                rlVertex2f(point[i].x, point[i].y);
call    0 never executed
    #####: 1256:                rlVertex2f(point[i + 1].x, point[i + 1].y);
call    0 never executed
        -: 1257:            }
        -: 1258:
    #####: 1259:        rlEnd();
    %%%%%: 1259-block  0
call    0 never executed
        -: 1260:    }
        -: 1261:}
        -: 1262:
        -: 1263:// Draw a triangle
        -: 1264:// NOTE: Vertex must be provided in counter-clockwise order
function DrawTriangle called 0 returned 0% blocks executed 0%
    #####: 1265:void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
        -: 1266:{
    #####: 1267:    rlCheckRenderBatchLimit(4);
    %%%%%: 1267-block  0
call    0 never executed
        -: 1268:
        -: 1269:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####: 1270:    rlSetTexture(texShapes.id);
call    0 never executed
        -: 1271:
    #####: 1272:    rlBegin(RL_QUADS);
call    0 never executed
    #####: 1273:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
        -: 1274:
    #####: 1275:        rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1276:        rlVertex2f(v1.x, v1.y);
call    0 never executed
        -: 1277:
    #####: 1278:        rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1279:        rlVertex2f(v2.x, v2.y);
call    0 never executed
        -: 1280:
    #####: 1281:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1282:        rlVertex2f(v2.x, v2.y);
call    0 never executed
        -: 1283:
    #####: 1284:        rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1285:        rlVertex2f(v3.x, v3.y);
call    0 never executed
    #####: 1286:    rlEnd();
call    0 never executed
        -: 1287:
    #####: 1288:    rlSetTexture(0);
call    0 never executed
        -: 1289:#else
        -: 1290:    rlBegin(RL_TRIANGLES);
        -: 1291:        rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1292:        rlVertex2f(v1.x, v1.y);
        -: 1293:        rlVertex2f(v2.x, v2.y);
        -: 1294:        rlVertex2f(v3.x, v3.y);
        -: 1295:    rlEnd();
        -: 1296:#endif
    #####: 1297:}
        -: 1298:
        -: 1299:// Draw a triangle using lines
        -: 1300:// NOTE: Vertex must be provided in counter-clockwise order
function DrawTriangleLines called 0 returned 0% blocks executed 0%
    #####: 1301:void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
        -: 1302:{
    #####: 1303:    rlCheckRenderBatchLimit(6);
    %%%%%: 1303-block  0
call    0 never executed
        -: 1304:
    #####: 1305:    rlBegin(RL_LINES);
call    0 never executed
    #####: 1306:        rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
    #####: 1307:        rlVertex2f(v1.x, v1.y);
call    0 never executed
    #####: 1308:        rlVertex2f(v2.x, v2.y);
call    0 never executed
        -: 1309:
    #####: 1310:        rlVertex2f(v2.x, v2.y);
call    0 never executed
    #####: 1311:        rlVertex2f(v3.x, v3.y);
call    0 never executed
        -: 1312:
    #####: 1313:        rlVertex2f(v3.x, v3.y);
call    0 never executed
    #####: 1314:        rlVertex2f(v1.x, v1.y);
call    0 never executed
    #####: 1315:    rlEnd();
call    0 never executed
    #####: 1316:}
        -: 1317:
        -: 1318:// Draw a triangle fan defined by points
        -: 1319:// NOTE: First vertex provided is the center, shared by all triangles
        -: 1320:// By default, following vertex should be provided in counter-clockwise order
function DrawTriangleFan called 0 returned 0% blocks executed 0%
    #####: 1321:void DrawTriangleFan(Vector2 *points, int pointCount, Color color)
        -: 1322:{
    #####: 1323:    if (pointCount >= 3)
    %%%%%: 1323-block  0
branch  0 never executed
branch  1 never executed
        -: 1324:    {
    #####: 1325:        rlCheckRenderBatchLimit((pointCount - 2)*4);
    %%%%%: 1325-block  0
call    0 never executed
        -: 1326:
    #####: 1327:        rlSetTexture(texShapes.id);
call    0 never executed
    #####: 1328:        rlBegin(RL_QUADS);
call    0 never executed
    #####: 1329:            rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
        -: 1330:
    #####: 1331:            for (int i = 1; i < pointCount - 1; i++)
    %%%%%: 1331-block  0
branch  0 never executed
branch  1 never executed
        -: 1332:            {
    #####: 1333:                rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
    %%%%%: 1333-block  0
call    0 never executed
    #####: 1334:                rlVertex2f(points[0].x, points[0].y);
call    0 never executed
        -: 1335:
    #####: 1336:                rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1337:                rlVertex2f(points[i].x, points[i].y);
call    0 never executed
        -: 1338:
    #####: 1339:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1340:                rlVertex2f(points[i + 1].x, points[i + 1].y);
call    0 never executed
        -: 1341:
    #####: 1342:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1343:                rlVertex2f(points[i + 1].x, points[i + 1].y);
call    0 never executed
        -: 1344:            }
    #####: 1345:        rlEnd();
    %%%%%: 1345-block  0
call    0 never executed
    #####: 1346:        rlSetTexture(0);
call    0 never executed
        -: 1347:    }
    #####: 1348:}
        -: 1349:
        -: 1350:// Draw a triangle strip defined by points
        -: 1351:// NOTE: Every new vertex connects with previous two
function DrawTriangleStrip called 0 returned 0% blocks executed 0%
    #####: 1352:void DrawTriangleStrip(Vector2 *points, int pointCount, Color color)
        -: 1353:{
    #####: 1354:    if (pointCount >= 3)
    %%%%%: 1354-block  0
branch  0 never executed
branch  1 never executed
        -: 1355:    {
    #####: 1356:        rlCheckRenderBatchLimit(3*(pointCount - 2));
    %%%%%: 1356-block  0
call    0 never executed
        -: 1357:
    #####: 1358:        rlBegin(RL_TRIANGLES);
call    0 never executed
    #####: 1359:            rlColor4ub(color.r, color.g, color.b, color.a);
call    0 never executed
        -: 1360:
    #####: 1361:            for (int i = 2; i < pointCount; i++)
    %%%%%: 1361-block  0
    %%%%%: 1361-block  1
branch  0 never executed
branch  1 never executed
        -: 1362:            {
    #####: 1363:                if ((i%2) == 0)
    %%%%%: 1363-block  0
branch  0 never executed
branch  1 never executed
        -: 1364:                {
    #####: 1365:                    rlVertex2f(points[i].x, points[i].y);
    %%%%%: 1365-block  0
call    0 never executed
    #####: 1366:                    rlVertex2f(points[i - 2].x, points[i - 2].y);
call    0 never executed
    #####: 1367:                    rlVertex2f(points[i - 1].x, points[i - 1].y);
call    0 never executed
        -: 1368:                }
        -: 1369:                else
        -: 1370:                {
    #####: 1371:                    rlVertex2f(points[i].x, points[i].y);
    %%%%%: 1371-block  0
call    0 never executed
    #####: 1372:                    rlVertex2f(points[i - 1].x, points[i - 1].y);
call    0 never executed
    #####: 1373:                    rlVertex2f(points[i - 2].x, points[i - 2].y);
call    0 never executed
        -: 1374:                }
        -: 1375:            }
    #####: 1376:        rlEnd();
    %%%%%: 1376-block  0
call    0 never executed
        -: 1377:    }
    #####: 1378:}
        -: 1379:
        -: 1380:// Draw a regular polygon of n sides (Vector version)
function DrawPoly called 0 returned 0% blocks executed 0%
    #####: 1381:void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color)
        -: 1382:{
    #####: 1383:    if (sides < 3) sides = 3;
    %%%%%: 1383-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1383-block  1
    #####: 1384:    float centralAngle = 0.0f;
        -: 1385:
        -: 1386:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####: 1387:    rlCheckRenderBatchLimit(4*sides); // Each side is a quad
    %%%%%: 1387-block  0
call    0 never executed
        -: 1388:#else
        -: 1389:    rlCheckRenderBatchLimit(3*sides);
        -: 1390:#endif
        -: 1391:
    #####: 1392:    rlPushMatrix();
call    0 never executed
    #####: 1393:        rlTranslatef(center.x, center.y, 0.0f);
call    0 never executed
    #####: 1394:        rlRotatef(rotation, 0.0f, 0.0f, 1.0f);
call    0 never executed
        -: 1395:
        -: 1396:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####: 1397:        rlSetTexture(texShapes.id);
call    0 never executed
        -: 1398:
    #####: 1399:        rlBegin(RL_QUADS);
call    0 never executed
    #####: 1400:            for (int i = 0; i < sides; i++)
    %%%%%: 1400-block  0
branch  0 never executed
branch  1 never executed
        -: 1401:            {
    #####: 1402:                rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%: 1402-block  0
call    0 never executed
        -: 1403:
    #####: 1404:                rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1405:                rlVertex2f(0, 0);
call    0 never executed
        -: 1406:
    #####: 1407:                rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1408:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
call    0 never executed
        -: 1409:
    #####: 1410:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1411:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
call    0 never executed
        -: 1412:
    #####: 1413:                centralAngle += 360.0f/(float)sides;
    #####: 1414:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1415:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
call    0 never executed
        -: 1416:            }
    #####: 1417:        rlEnd();
    %%%%%: 1417-block  0
call    0 never executed
    #####: 1418:        rlSetTexture(0);
call    0 never executed
        -: 1419:#else
        -: 1420:        rlBegin(RL_TRIANGLES);
        -: 1421:            for (int i = 0; i < sides; i++)
        -: 1422:            {
        -: 1423:                rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1424:
        -: 1425:                rlVertex2f(0, 0);
        -: 1426:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
        -: 1427:
        -: 1428:                centralAngle += 360.0f/(float)sides;
        -: 1429:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
        -: 1430:            }
        -: 1431:        rlEnd();
        -: 1432:#endif
    #####: 1433:    rlPopMatrix();
call    0 never executed
    #####: 1434:}
        -: 1435:
        -: 1436:// Draw a polygon outline of n sides
function DrawPolyLines called 0 returned 0% blocks executed 0%
    #####: 1437:void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color)
        -: 1438:{
    #####: 1439:    if (sides < 3) sides = 3;
    %%%%%: 1439-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1439-block  1
    #####: 1440:    float centralAngle = 0.0f;
        -: 1441:
    #####: 1442:    rlCheckRenderBatchLimit(2*sides);
    %%%%%: 1442-block  0
call    0 never executed
        -: 1443:
    #####: 1444:    rlPushMatrix();
call    0 never executed
    #####: 1445:        rlTranslatef(center.x, center.y, 0.0f);
call    0 never executed
    #####: 1446:        rlRotatef(rotation, 0.0f, 0.0f, 1.0f);
call    0 never executed
        -: 1447:
    #####: 1448:        rlBegin(RL_LINES);
call    0 never executed
    #####: 1449:            for (int i = 0; i < sides; i++)
    %%%%%: 1449-block  0
branch  0 never executed
branch  1 never executed
        -: 1450:            {
    #####: 1451:                rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%: 1451-block  0
call    0 never executed
        -: 1452:
    #####: 1453:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
call    0 never executed
    #####: 1454:                centralAngle += 360.0f/(float)sides;
    #####: 1455:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
call    0 never executed
        -: 1456:            }
    #####: 1457:        rlEnd();
    %%%%%: 1457-block  0
call    0 never executed
    #####: 1458:    rlPopMatrix();
call    0 never executed
    #####: 1459:}
        -: 1460:
function DrawPolyLinesEx called 0 returned 0% blocks executed 0%
    #####: 1461:void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color)
        -: 1462:{
    #####: 1463:    if (sides < 3) sides = 3;
    %%%%%: 1463-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1463-block  1
    #####: 1464:    float centralAngle = 0.0f;
    #####: 1465:    float exteriorAngle = 360.0f/(float)sides;
    #####: 1466:    float innerRadius = radius - (lineThick*cosf(DEG2RAD*exteriorAngle/2.0f));
        -: 1467:
        -: 1468:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####: 1469:    rlCheckRenderBatchLimit(4*sides);
    %%%%%: 1469-block  0
call    0 never executed
        -: 1470:#else
        -: 1471:    rlCheckRenderBatchLimit(6*sides);
        -: 1472:#endif
        -: 1473:
    #####: 1474:    rlPushMatrix();
call    0 never executed
    #####: 1475:        rlTranslatef(center.x, center.y, 0.0f);
call    0 never executed
    #####: 1476:        rlRotatef(rotation, 0.0f, 0.0f, 1.0f);
call    0 never executed
        -: 1477:
        -: 1478:#if defined(SUPPORT_QUADS_DRAW_MODE)
    #####: 1479:        rlSetTexture(texShapes.id);
call    0 never executed
        -: 1480:
    #####: 1481:        rlBegin(RL_QUADS);
call    0 never executed
    #####: 1482:            for (int i = 0; i < sides; i++)
    %%%%%: 1482-block  0
branch  0 never executed
branch  1 never executed
        -: 1483:            {
    #####: 1484:                rlColor4ub(color.r, color.g, color.b, color.a);
    %%%%%: 1484-block  0
call    0 never executed
        -: 1485:
    #####: 1486:                rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1487:                rlVertex2f(sinf(DEG2RAD*centralAngle)*innerRadius, cosf(DEG2RAD*centralAngle)*innerRadius);
call    0 never executed
        -: 1488:
    #####: 1489:                rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1490:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
call    0 never executed
        -: 1491:
    #####: 1492:                centralAngle += exteriorAngle;
    #####: 1493:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height);
call    0 never executed
    #####: 1494:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
call    0 never executed
        -: 1495:
    #####: 1496:                rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height);
call    0 never executed
    #####: 1497:                rlVertex2f(sinf(DEG2RAD*centralAngle)*innerRadius, cosf(DEG2RAD*centralAngle)*innerRadius);
call    0 never executed
        -: 1498:            }
    #####: 1499:        rlEnd();
    %%%%%: 1499-block  0
call    0 never executed
    #####: 1500:        rlSetTexture(0);
call    0 never executed
        -: 1501:#else
        -: 1502:        rlBegin(RL_TRIANGLES);
        -: 1503:            for (int i = 0; i < sides; i++)
        -: 1504:            {
        -: 1505:                rlColor4ub(color.r, color.g, color.b, color.a);
        -: 1506:                float nextAngle = centralAngle + exteriorAngle;
        -: 1507:
        -: 1508:                rlVertex2f(sinf(DEG2RAD*centralAngle)*radius, cosf(DEG2RAD*centralAngle)*radius);
        -: 1509:                rlVertex2f(sinf(DEG2RAD*centralAngle)*innerRadius, cosf(DEG2RAD*centralAngle)*innerRadius);
        -: 1510:                rlVertex2f(sinf(DEG2RAD*nextAngle)*radius, cosf(DEG2RAD*nextAngle)*radius);
        -: 1511:
        -: 1512:                rlVertex2f(sinf(DEG2RAD*centralAngle)*innerRadius, cosf(DEG2RAD*centralAngle)*innerRadius);
        -: 1513:                rlVertex2f(sinf(DEG2RAD*nextAngle)*radius, cosf(DEG2RAD*nextAngle)*radius);
        -: 1514:                rlVertex2f(sinf(DEG2RAD*nextAngle)*innerRadius, cosf(DEG2RAD*nextAngle)*innerRadius);
        -: 1515:
        -: 1516:                centralAngle = nextAngle;
        -: 1517:            }
        -: 1518:        rlEnd();
        -: 1519:#endif
    #####: 1520:    rlPopMatrix();
call    0 never executed
    #####: 1521:}
        -: 1522:
        -: 1523://----------------------------------------------------------------------------------
        -: 1524:// Module Functions Definition - Collision Detection functions
        -: 1525://----------------------------------------------------------------------------------
        -: 1526:
        -: 1527:// Check if point is inside rectangle
function CheckCollisionPointRec called 0 returned 0% blocks executed 0%
    #####: 1528:bool CheckCollisionPointRec(Vector2 point, Rectangle rec)
        -: 1529:{
    #####: 1530:    bool collision = false;
        -: 1531:
    #####: 1532:    if ((point.x >= rec.x) && (point.x <= (rec.x + rec.width)) && (point.y >= rec.y) && (point.y <= (rec.y + rec.height))) collision = true;
    %%%%%: 1532-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1532-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1532-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1532-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1532-block  4
        -: 1533:
    #####: 1534:    return collision;
    %%%%%: 1534-block  0
        -: 1535:}
        -: 1536:
        -: 1537:// Check if point is inside circle
function CheckCollisionPointCircle called 0 returned 0% blocks executed 0%
    #####: 1538:bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius)
        -: 1539:{
    #####: 1540:    return CheckCollisionCircles(point, 0, center, radius);
    %%%%%: 1540-block  0
call    0 never executed
        -: 1541:}
        -: 1542:
        -: 1543:// Check if point is inside a triangle defined by three points (p1, p2, p3)
function CheckCollisionPointTriangle called 0 returned 0% blocks executed 0%
    #####: 1544:bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3)
        -: 1545:{
    #####: 1546:    bool collision = false;
        -: 1547:
    #####: 1548:    float alpha = ((p2.y - p3.y)*(point.x - p3.x) + (p3.x - p2.x)*(point.y - p3.y)) /
    #####: 1549:                  ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));
        -: 1550:
    #####: 1551:    float beta = ((p3.y - p1.y)*(point.x - p3.x) + (p1.x - p3.x)*(point.y - p3.y)) /
    #####: 1552:                 ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));
        -: 1553:
    #####: 1554:    float gamma = 1.0f - alpha - beta;
        -: 1555:
    #####: 1556:    if ((alpha > 0) && (beta > 0) && (gamma > 0)) collision = true;
    %%%%%: 1556-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1556-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1556-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1556-block  3
        -: 1557:
    #####: 1558:    return collision;
    %%%%%: 1558-block  0
        -: 1559:}
        -: 1560:
        -: 1561:// Check collision between two rectangles
function CheckCollisionRecs called 624 returned 100% blocks executed 86%
      624: 1562:bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2)
        -: 1563:{
      624: 1564:    bool collision = false;
        -: 1565:
      624: 1566:    if ((rec1.x < (rec2.x + rec2.width) && (rec1.x + rec1.width) > rec2.x) &&
      624: 1566-block  0
branch  0 taken 495 (fallthrough)
branch  1 taken 129
      495: 1566-block  1
branch  2 taken 6 (fallthrough)
branch  3 taken 489
       6*: 1567:        (rec1.y < (rec2.y + rec2.height) && (rec1.y + rec1.height) > rec2.y)) collision = true;
        6: 1567-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 1567-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 6
    %%%%%: 1567-block  2
        -: 1568:
      624: 1569:    return collision;
      624: 1569-block  0
        -: 1570:}
        -: 1571:
        -: 1572:// Check collision between two circles
function CheckCollisionCircles called 0 returned 0% blocks executed 0%
    #####: 1573:bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2)
        -: 1574:{
    #####: 1575:    bool collision = false;
        -: 1576:
    #####: 1577:    float dx = center2.x - center1.x;      // X distance between centers
    #####: 1578:    float dy = center2.y - center1.y;      // Y distance between centers
        -: 1579:
    #####: 1580:    float distance = sqrtf(dx*dx + dy*dy); // Distance between centers
        -: 1581:
    #####: 1582:    if (distance <= (radius1 + radius2)) collision = true;
    %%%%%: 1582-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1582-block  1
        -: 1583:
    #####: 1584:    return collision;
    %%%%%: 1584-block  0
        -: 1585:}
        -: 1586:
        -: 1587:// Check collision between circle and rectangle
        -: 1588:// NOTE: Reviewed version to take into account corner limit case
function CheckCollisionCircleRec called 0 returned 0% blocks executed 0%
    #####: 1589:bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec)
        -: 1590:{
    #####: 1591:    int recCenterX = (int)(rec.x + rec.width/2.0f);
    #####: 1592:    int recCenterY = (int)(rec.y + rec.height/2.0f);
        -: 1593:
    #####: 1594:    float dx = fabsf(center.x - (float)recCenterX);
    #####: 1595:    float dy = fabsf(center.y - (float)recCenterY);
        -: 1596:
    #####: 1597:    if (dx > (rec.width/2.0f + radius)) { return false; }
    %%%%%: 1597-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1597-block  1
    #####: 1598:    if (dy > (rec.height/2.0f + radius)) { return false; }
    %%%%%: 1598-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1598-block  1
        -: 1599:
    #####: 1600:    if (dx <= (rec.width/2.0f)) { return true; }
    %%%%%: 1600-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1600-block  1
    #####: 1601:    if (dy <= (rec.height/2.0f)) { return true; }
    %%%%%: 1601-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1601-block  1
        -: 1602:
    #####: 1603:    float cornerDistanceSq = (dx - rec.width/2.0f)*(dx - rec.width/2.0f) +
    #####: 1604:                             (dy - rec.height/2.0f)*(dy - rec.height/2.0f);
        -: 1605:
    #####: 1606:    return (cornerDistanceSq <= (radius*radius));
    %%%%%: 1606-block  0
        -: 1607:}
        -: 1608:
        -: 1609:// Check the collision between two lines defined by two points each, returns collision point by reference
function CheckCollisionLines called 0 returned 0% blocks executed 0%
    #####: 1610:bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint)
        -: 1611:{
    #####: 1612:    const float div = (endPos2.y - startPos2.y)*(endPos1.x - startPos1.x) - (endPos2.x - startPos2.x)*(endPos1.y - startPos1.y);
        -: 1613:
    #####: 1614:    if (div == 0.0f) return false;      // WARNING: This check could not work due to float precision rounding issues...
    %%%%%: 1614-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1614-block  1
        -: 1615:
    #####: 1616:    const float xi = ((startPos2.x - endPos2.x)*(startPos1.x*endPos1.y - startPos1.y*endPos1.x) - (startPos1.x - endPos1.x)*(startPos2.x*endPos2.y - startPos2.y*endPos2.x))/div;
    #####: 1617:    const float yi = ((startPos2.y - endPos2.y)*(startPos1.x*endPos1.y - startPos1.y*endPos1.x) - (startPos1.y - endPos1.y)*(startPos2.x*endPos2.y - startPos2.y*endPos2.x))/div;
        -: 1618:
    #####: 1619:    if (xi < fminf(startPos1.x, endPos1.x) || xi > fmaxf(startPos1.x, endPos1.x)) return false;
    %%%%%: 1619-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1619-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1619-block  2
    #####: 1620:    if (xi < fminf(startPos2.x, endPos2.x) || xi > fmaxf(startPos2.x, endPos2.x)) return false;
    %%%%%: 1620-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1620-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1620-block  2
    #####: 1621:    if (yi < fminf(startPos1.y, endPos1.y) || yi > fmaxf(startPos1.y, endPos1.y)) return false;
    %%%%%: 1621-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1621-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1621-block  2
    #####: 1622:    if (yi < fminf(startPos2.y, endPos2.y) || yi > fmaxf(startPos2.y, endPos2.y)) return false;
    %%%%%: 1622-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1622-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1622-block  2
        -: 1623:
    #####: 1624:    if (collisionPoint != 0)
    %%%%%: 1624-block  0
branch  0 never executed
branch  1 never executed
        -: 1625:    {
    #####: 1626:        collisionPoint->x = xi;
    #####: 1627:        collisionPoint->y = yi;
    %%%%%: 1627-block  0
        -: 1628:    }
        -: 1629:
    #####: 1630:    return true;
    %%%%%: 1630-block  0
        -: 1631:}
        -: 1632:
        -: 1633:// Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
function CheckCollisionPointLine called 0 returned 0% blocks executed 0%
    #####: 1634:bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold)
        -: 1635:{
    #####: 1636:    bool collision = false;
    #####: 1637:    float dxc = point.x - p1.x;
    #####: 1638:    float dyc = point.y - p1.y;
    #####: 1639:    float dxl = p2.x - p1.x;
    #####: 1640:    float dyl = p2.y - p1.y;
    #####: 1641:    float cross = dxc*dyl - dyc*dxl;
        -: 1642:
    #####: 1643:    if (fabsf(cross) < (threshold*fmaxf(fabsf(dxl), fabsf(dyl))))
    %%%%%: 1643-block  0
branch  0 never executed
branch  1 never executed
        -: 1644:    {
    #####: 1645:        if (fabsf(dxl) >= fabsf(dyl)) collision = (dxl > 0)? ((p1.x <= point.x) && (point.x <= p2.x)) : ((p2.x <= point.x) && (point.x <= p1.x));
    %%%%%: 1645-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1645-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1645-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1645-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1645-block  4
    %%%%%: 1645-block  5
    %%%%%: 1645-block  6
    %%%%%: 1645-block  7
branch  8 never executed
branch  9 never executed
    %%%%%: 1645-block  8
branch 10 never executed
branch 11 never executed
    %%%%%: 1645-block  9
    %%%%%: 1645-block 10
    %%%%%: 1645-block 11
    %%%%%: 1645-block 12
    #####: 1646:        else collision = (dyl > 0)? ((p1.y <= point.y) && (point.y <= p2.y)) : ((p2.y <= point.y) && (point.y <= p1.y));
    %%%%%: 1646-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1646-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1646-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1646-block  3
    %%%%%: 1646-block  4
    %%%%%: 1646-block  5
    %%%%%: 1646-block  6
branch  6 never executed
branch  7 never executed
    %%%%%: 1646-block  7
branch  8 never executed
branch  9 never executed
    %%%%%: 1646-block  8
    %%%%%: 1646-block  9
    %%%%%: 1646-block 10
    %%%%%: 1646-block 11
        -: 1647:    }
        -: 1648:
    #####: 1649:    return collision;
    %%%%%: 1649-block  0
        -: 1650:}
        -: 1651:
        -: 1652:// Get collision rectangle for two rectangles collision
function GetCollisionRec called 0 returned 0% blocks executed 0%
    #####: 1653:Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2)
        -: 1654:{
    #####: 1655:    Rectangle rec = { 0, 0, 0, 0 };
        -: 1656:
    #####: 1657:    if (CheckCollisionRecs(rec1, rec2))
    %%%%%: 1657-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1658:    {
    #####: 1659:        float dxx = fabsf(rec1.x - rec2.x);
    #####: 1660:        float dyy = fabsf(rec1.y - rec2.y);
        -: 1661:
    #####: 1662:        if (rec1.x <= rec2.x)
    %%%%%: 1662-block  0
branch  0 never executed
branch  1 never executed
        -: 1663:        {
    #####: 1664:            if (rec1.y <= rec2.y)
    %%%%%: 1664-block  0
branch  0 never executed
branch  1 never executed
        -: 1665:            {
    #####: 1666:                rec.x = rec2.x;
    #####: 1667:                rec.y = rec2.y;
    #####: 1668:                rec.width = rec1.width - dxx;
    #####: 1669:                rec.height = rec1.height - dyy;
    %%%%%: 1669-block  0
        -: 1670:            }
        -: 1671:            else
        -: 1672:            {
    #####: 1673:                rec.x = rec2.x;
    #####: 1674:                rec.y = rec1.y;
    #####: 1675:                rec.width = rec1.width - dxx;
    #####: 1676:                rec.height = rec2.height - dyy;
    %%%%%: 1676-block  0
        -: 1677:            }
        -: 1678:        }
        -: 1679:        else
        -: 1680:        {
    #####: 1681:            if (rec1.y <= rec2.y)
    %%%%%: 1681-block  0
branch  0 never executed
branch  1 never executed
        -: 1682:            {
    #####: 1683:                rec.x = rec1.x;
    #####: 1684:                rec.y = rec2.y;
    #####: 1685:                rec.width = rec2.width - dxx;
    #####: 1686:                rec.height = rec1.height - dyy;
    %%%%%: 1686-block  0
        -: 1687:            }
        -: 1688:            else
        -: 1689:            {
    #####: 1690:                rec.x = rec1.x;
    #####: 1691:                rec.y = rec1.y;
    #####: 1692:                rec.width = rec2.width - dxx;
    #####: 1693:                rec.height = rec2.height - dyy;
    %%%%%: 1693-block  0
        -: 1694:            }
        -: 1695:        }
        -: 1696:
    #####: 1697:        if (rec1.width > rec2.width)
    %%%%%: 1697-block  0
branch  0 never executed
branch  1 never executed
        -: 1698:        {
    #####: 1699:            if (rec.width >= rec2.width) rec.width = rec2.width;
    %%%%%: 1699-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1699-block  1
        -: 1700:        }
        -: 1701:        else
        -: 1702:        {
    #####: 1703:            if (rec.width >= rec1.width) rec.width = rec1.width;
    %%%%%: 1703-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1703-block  1
        -: 1704:        }
        -: 1705:
    #####: 1706:        if (rec1.height > rec2.height)
    %%%%%: 1706-block  0
branch  0 never executed
branch  1 never executed
        -: 1707:        {
    #####: 1708:            if (rec.height >= rec2.height) rec.height = rec2.height;
    %%%%%: 1708-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1708-block  1
        -: 1709:        }
        -: 1710:        else
        -: 1711:        {
    #####: 1712:           if (rec.height >= rec1.height) rec.height = rec1.height;
    %%%%%: 1712-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1712-block  1
        -: 1713:        }
        -: 1714:    }
        -: 1715:
    #####: 1716:    return rec;
    %%%%%: 1716-block  0
        -: 1717:}
        -: 1718:
        -: 1719://----------------------------------------------------------------------------------
        -: 1720:// Module specific Functions Definition
        -: 1721://----------------------------------------------------------------------------------
        -: 1722:
        -: 1723:// Cubic easing in-out
        -: 1724:// NOTE: Used by DrawLineBezier() only
function EaseCubicInOut called 0 returned 0% blocks executed 0%
    #####: 1725:static float EaseCubicInOut(float t, float b, float c, float d)
        -: 1726:{
    #####: 1727:    if ((t /= 0.5f*d) < 1) return 0.5f*c*t*t*t + b;
    %%%%%: 1727-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1727-block  1
        -: 1728:
    #####: 1729:    t -= 2;
        -: 1730:
    #####: 1731:    return 0.5f*c*(t*t*t + 2.0f) + b;
    %%%%%: 1731-block  0
        -: 1732:}
