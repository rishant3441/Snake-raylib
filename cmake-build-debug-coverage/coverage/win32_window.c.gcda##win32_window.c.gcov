        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/external/glfw/src/win32_window.c
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\external\glfw\src\CMakeFiles\glfw.dir\win32_window.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\external\glfw\src\CMakeFiles\glfw.dir\win32_window.c.gcda
        -:    0:Runs:1
        -:    1://========================================================================
        -:    2:// GLFW 3.4 Win32 - www.glfw.org
        -:    3://------------------------------------------------------------------------
        -:    4:// Copyright (c) 2002-2006 Marcus Geelnard
        -:    5:// Copyright (c) 2006-2019 Camilla LÃ¶wy <elmindreda@glfw.org>
        -:    6://
        -:    7:// This software is provided 'as-is', without any express or implied
        -:    8:// warranty. In no event will the authors be held liable for any damages
        -:    9:// arising from the use of this software.
        -:   10://
        -:   11:// Permission is granted to anyone to use this software for any purpose,
        -:   12:// including commercial applications, and to alter it and redistribute it
        -:   13:// freely, subject to the following restrictions:
        -:   14://
        -:   15:// 1. The origin of this software must not be misrepresented; you must not
        -:   16://    claim that you wrote the original software. If you use this software
        -:   17://    in a product, an acknowledgment in the product documentation would
        -:   18://    be appreciated but is not required.
        -:   19://
        -:   20:// 2. Altered source versions must be plainly marked as such, and must not
        -:   21://    be misrepresented as being the original software.
        -:   22://
        -:   23:// 3. This notice may not be removed or altered from any source
        -:   24://    distribution.
        -:   25://
        -:   26://========================================================================
        -:   27:// Please use C89 style variable declarations in this file because VS 2010
        -:   28://========================================================================
        -:   29:
        -:   30:#include "internal.h"
        -:   31:
        -:   32:#include <limits.h>
        -:   33:#include <stdlib.h>
        -:   34:#include <malloc.h>
        -:   35:#include <string.h>
        -:   36:#include <windowsx.h>
        -:   37:#include <shellapi.h>
        -:   38:
        -:   39:// Returns the window style for the specified window
        -:   40://
function getWindowStyle called 3 returned 100% blocks executed 62%
        3:   41:static DWORD getWindowStyle(const _GLFWwindow* window)
        -:   42:{
        3:   43:    DWORD style = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
        -:   44:
        3:   45:    if (window->monitor)
        3:   45-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   46:        style |= WS_POPUP;
    %%%%%:   46-block  0
        -:   47:    else
        -:   48:    {
        3:   49:        style |= WS_SYSMENU | WS_MINIMIZEBOX;
        -:   50:
        3:   51:        if (window->decorated)
        3:   51-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -:   52:        {
        3:   53:            style |= WS_CAPTION;
        -:   54:
        3:   55:            if (window->resizable)
        3:   55-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   56:                style |= WS_MAXIMIZEBOX | WS_THICKFRAME;
    %%%%%:   56-block  0
        -:   57:        }
        -:   58:        else
    #####:   59:            style |= WS_POPUP;
    %%%%%:   59-block  0
        -:   60:    }
        -:   61:
        3:   62:    return style;
        3:   62-block  0
        -:   63:}
        -:   64:
        -:   65:// Returns the extended window style for the specified window
        -:   66://
function getWindowExStyle called 3 returned 100% blocks executed 80%
        3:   67:static DWORD getWindowExStyle(const _GLFWwindow* window)
        -:   68:{
        3:   69:    DWORD style = WS_EX_APPWINDOW;
        -:   70:
        3:   71:    if (window->monitor || window->floating)
        3:   71-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:   71-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    #####:   72:        style |= WS_EX_TOPMOST;
    %%%%%:   72-block  0
        -:   73:
        3:   74:    return style;
        3:   74-block  0
        -:   75:}
        -:   76:
        -:   77:// Returns the image whose area most closely matches the desired one
        -:   78://
function chooseImage called 0 returned 0% blocks executed 0%
    #####:   79:static const GLFWimage* chooseImage(int count, const GLFWimage* images,
        -:   80:                                    int width, int height)
        -:   81:{
    #####:   82:    int i, leastDiff = INT_MAX;
    #####:   83:    const GLFWimage* closest = NULL;
        -:   84:
    #####:   85:    for (i = 0;  i < count;  i++)
    %%%%%:   85-block  0
    %%%%%:   85-block  1
    %%%%%:   85-block  2
branch  0 never executed
branch  1 never executed
        -:   86:    {
    #####:   87:        const int currDiff = abs(images[i].width * images[i].height -
    #####:   88:                                 width * height);
    #####:   89:        if (currDiff < leastDiff)
    %%%%%:   89-block  0
branch  0 never executed
branch  1 never executed
        -:   90:        {
    #####:   91:            closest = images + i;
    #####:   92:            leastDiff = currDiff;
    %%%%%:   92-block  0
        -:   93:        }
        -:   94:    }
        -:   95:
    #####:   96:    return closest;
    %%%%%:   96-block  0
        -:   97:}
        -:   98:
        -:   99:// Creates an RGBA icon or cursor
        -:  100://
function createIcon called 0 returned 0% blocks executed 0%
    #####:  101:static HICON createIcon(const GLFWimage* image,
        -:  102:                        int xhot, int yhot, GLFWbool icon)
        -:  103:{
        -:  104:    int i;
        -:  105:    HDC dc;
        -:  106:    HICON handle;
        -:  107:    HBITMAP color, mask;
        -:  108:    BITMAPV5HEADER bi;
        -:  109:    ICONINFO ii;
    #####:  110:    unsigned char* target = NULL;
    #####:  111:    unsigned char* source = image->pixels;
        -:  112:
    #####:  113:    ZeroMemory(&bi, sizeof(bi));
    #####:  114:    bi.bV5Size        = sizeof(bi);
    #####:  115:    bi.bV5Width       = image->width;
    #####:  116:    bi.bV5Height      = -image->height;
    #####:  117:    bi.bV5Planes      = 1;
    #####:  118:    bi.bV5BitCount    = 32;
    #####:  119:    bi.bV5Compression = BI_BITFIELDS;
    #####:  120:    bi.bV5RedMask     = 0x00ff0000;
    #####:  121:    bi.bV5GreenMask   = 0x0000ff00;
    #####:  122:    bi.bV5BlueMask    = 0x000000ff;
    #####:  123:    bi.bV5AlphaMask   = 0xff000000;
        -:  124:
    #####:  125:    dc = GetDC(NULL);
    %%%%%:  125-block  0
call    0 never executed
    #####:  126:    color = CreateDIBSection(dc,
call    0 never executed
        -:  127:                             (BITMAPINFO*) &bi,
        -:  128:                             DIB_RGB_COLORS,
        -:  129:                             (void**) &target,
        -:  130:                             NULL,
        -:  131:                             (DWORD) 0);
    #####:  132:    ReleaseDC(NULL, dc);
call    0 never executed
        -:  133:
    #####:  134:    if (!color)
branch  0 never executed
branch  1 never executed
        -:  135:    {
    #####:  136:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  136-block  0
call    0 never executed
        -:  137:                             "Win32: Failed to create RGBA bitmap");
    #####:  138:        return NULL;
        -:  139:    }
        -:  140:
    #####:  141:    mask = CreateBitmap(image->width, image->height, 1, 1, NULL);
    %%%%%:  141-block  0
call    0 never executed
    #####:  142:    if (!mask)
branch  0 never executed
branch  1 never executed
        -:  143:    {
    #####:  144:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  144-block  0
call    0 never executed
        -:  145:                             "Win32: Failed to create mask bitmap");
    #####:  146:        DeleteObject(color);
call    0 never executed
    #####:  147:        return NULL;
        -:  148:    }
        -:  149:
    #####:  150:    for (i = 0;  i < image->width * image->height;  i++)
    %%%%%:  150-block  0
    %%%%%:  150-block  1
branch  0 never executed
branch  1 never executed
        -:  151:    {
    #####:  152:        target[0] = source[2];
    #####:  153:        target[1] = source[1];
    #####:  154:        target[2] = source[0];
    #####:  155:        target[3] = source[3];
    #####:  156:        target += 4;
    #####:  157:        source += 4;
    %%%%%:  157-block  0
        -:  158:    }
        -:  159:
    #####:  160:    ZeroMemory(&ii, sizeof(ii));
    #####:  161:    ii.fIcon    = icon;
    #####:  162:    ii.xHotspot = xhot;
    #####:  163:    ii.yHotspot = yhot;
    #####:  164:    ii.hbmMask  = mask;
    #####:  165:    ii.hbmColor = color;
        -:  166:
    #####:  167:    handle = CreateIconIndirect(&ii);
    %%%%%:  167-block  0
call    0 never executed
        -:  168:
    #####:  169:    DeleteObject(color);
call    0 never executed
    #####:  170:    DeleteObject(mask);
call    0 never executed
        -:  171:
    #####:  172:    if (!handle)
branch  0 never executed
branch  1 never executed
        -:  173:    {
    #####:  174:        if (icon)
    %%%%%:  174-block  0
branch  0 never executed
branch  1 never executed
        -:  175:        {
    #####:  176:            _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  176-block  0
call    0 never executed
        -:  177:                                 "Win32: Failed to create icon");
        -:  178:        }
        -:  179:        else
        -:  180:        {
    #####:  181:            _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  181-block  0
call    0 never executed
        -:  182:                                 "Win32: Failed to create cursor");
        -:  183:        }
        -:  184:    }
        -:  185:
    #####:  186:    return handle;
    %%%%%:  186-block  0
        -:  187:}
        -:  188:
        -:  189:// Translate content area size to full window size according to styles and DPI
        -:  190://
function getFullWindowSize called 2 returned 100% blocks executed 80%
        2:  191:static void getFullWindowSize(DWORD style, DWORD exStyle,
        -:  192:                              int contentWidth, int contentHeight,
        -:  193:                              int* fullWidth, int* fullHeight,
        -:  194:                              UINT dpi)
        -:  195:{
        2:  196:    RECT rect = { 0, 0, contentWidth, contentHeight };
        -:  197:
        2:  198:    if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
        2:  198-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2:  199:        AdjustWindowRectExForDpi(&rect, style, FALSE, exStyle, dpi);
        2:  199-block  0
call    0 returned 2
        -:  200:    else
    #####:  201:        AdjustWindowRectEx(&rect, style, FALSE, exStyle);
    %%%%%:  201-block  0
call    0 never executed
        -:  202:
        2:  203:    *fullWidth = rect.right - rect.left;
        2:  204:    *fullHeight = rect.bottom - rect.top;
        2:  205:}
        -:  206:
        -:  207:// Enforce the content area aspect ratio based on which edge is being dragged
        -:  208://
function applyAspectRatio called 0 returned 0% blocks executed 0%
    #####:  209:static void applyAspectRatio(_GLFWwindow* window, int edge, RECT* area)
        -:  210:{
        -:  211:    int xoff, yoff;
    #####:  212:    UINT dpi = USER_DEFAULT_SCREEN_DPI;
    #####:  213:    const float ratio = (float) window->numer / (float) window->denom;
        -:  214:
    #####:  215:    if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
    %%%%%:  215-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  216:        dpi = GetDpiForWindow(window->win32.handle);
    %%%%%:  216-block  0
call    0 never executed
        -:  217:
    #####:  218:    getFullWindowSize(getWindowStyle(window), getWindowExStyle(window),
    %%%%%:  218-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -:  219:                      0, 0, &xoff, &yoff, dpi);
        -:  220:
    #####:  221:    if (edge == WMSZ_LEFT  || edge == WMSZ_BOTTOMLEFT ||
branch  0 never executed
branch  1 never executed
    %%%%%:  221-block  0
branch  2 never executed
branch  3 never executed
    %%%%%:  221-block  1
branch  4 never executed
branch  5 never executed
    #####:  222:        edge == WMSZ_RIGHT || edge == WMSZ_BOTTOMRIGHT)
    %%%%%:  222-block  0
branch  0 never executed
branch  1 never executed
        -:  223:    {
    #####:  224:        area->bottom = area->top + yoff +
    #####:  225:            (int) ((area->right - area->left - xoff) / ratio);
    %%%%%:  225-block  0
        -:  226:    }
    #####:  227:    else if (edge == WMSZ_TOPLEFT || edge == WMSZ_TOPRIGHT)
    %%%%%:  227-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  227-block  1
branch  2 never executed
branch  3 never executed
        -:  228:    {
    #####:  229:        area->top = area->bottom - yoff -
    #####:  230:            (int) ((area->right - area->left - xoff) / ratio);
    %%%%%:  230-block  0
        -:  231:    }
    #####:  232:    else if (edge == WMSZ_TOP || edge == WMSZ_BOTTOM)
    %%%%%:  232-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  232-block  1
branch  2 never executed
branch  3 never executed
        -:  233:    {
    #####:  234:        area->right = area->left + xoff +
    #####:  235:            (int) ((area->bottom - area->top - yoff) * ratio);
    %%%%%:  235-block  0
        -:  236:    }
    #####:  237:}
        -:  238:
        -:  239:// Updates the cursor image according to its cursor mode
        -:  240://
function updateCursorImage called 16 returned 100% blocks executed 71%
       16:  241:static void updateCursorImage(_GLFWwindow* window)
        -:  242:{
       16:  243:    if (window->cursorMode == GLFW_CURSOR_NORMAL)
       16:  243-block  0
branch  0 taken 16 (fallthrough)
branch  1 taken 0
        -:  244:    {
       16:  245:        if (window->cursor)
       16:  245-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    #####:  246:            SetCursor(window->cursor->win32.handle);
    %%%%%:  246-block  0
call    0 never executed
        -:  247:        else
       16:  248:            SetCursor(LoadCursorW(NULL, IDC_ARROW));
       16:  248-block  0
call    0 returned 16
call    1 returned 16
        -:  249:    }
        -:  250:    else
    #####:  251:        SetCursor(NULL);
    %%%%%:  251-block  0
call    0 never executed
       16:  252:}
        -:  253:
        -:  254:// Updates the cursor clip rect
        -:  255://
function updateClipRect called 0 returned 0% blocks executed 0%
    #####:  256:static void updateClipRect(_GLFWwindow* window)
        -:  257:{
    #####:  258:    if (window)
    %%%%%:  258-block  0
branch  0 never executed
branch  1 never executed
        -:  259:    {
        -:  260:        RECT clipRect;
    #####:  261:        GetClientRect(window->win32.handle, &clipRect);
    %%%%%:  261-block  0
call    0 never executed
    #####:  262:        ClientToScreen(window->win32.handle, (POINT*) &clipRect.left);
call    0 never executed
    #####:  263:        ClientToScreen(window->win32.handle, (POINT*) &clipRect.right);
call    0 never executed
    #####:  264:        ClipCursor(&clipRect);
call    0 never executed
        -:  265:    }
        -:  266:    else
    #####:  267:        ClipCursor(NULL);
    %%%%%:  267-block  0
call    0 never executed
    #####:  268:}
        -:  269:
        -:  270:// Enables WM_INPUT messages for the mouse for the specified window
        -:  271://
function enableRawMouseMotion called 0 returned 0% blocks executed 0%
    #####:  272:static void enableRawMouseMotion(_GLFWwindow* window)
        -:  273:{
    #####:  274:    const RAWINPUTDEVICE rid = { 0x01, 0x02, 0, window->win32.handle };
        -:  275:
    #####:  276:    if (!RegisterRawInputDevices(&rid, 1, sizeof(rid)))
    %%%%%:  276-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  277:    {
    #####:  278:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  278-block  0
call    0 never executed
        -:  279:                             "Win32: Failed to register raw input device");
        -:  280:    }
    #####:  281:}
        -:  282:
        -:  283:// Disables WM_INPUT messages for the mouse
        -:  284://
function disableRawMouseMotion called 0 returned 0% blocks executed 0%
    #####:  285:static void disableRawMouseMotion(_GLFWwindow* window)
        -:  286:{
    #####:  287:    const RAWINPUTDEVICE rid = { 0x01, 0x02, RIDEV_REMOVE, NULL };
        -:  288:
    #####:  289:    if (!RegisterRawInputDevices(&rid, 1, sizeof(rid)))
    %%%%%:  289-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  290:    {
    #####:  291:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%:  291-block  0
call    0 never executed
        -:  292:                             "Win32: Failed to remove raw input device");
        -:  293:    }
    #####:  294:}
        -:  295:
        -:  296:// Apply disabled cursor mode to a focused window
        -:  297://
function disableCursor called 0 returned 0% blocks executed 0%
    #####:  298:static void disableCursor(_GLFWwindow* window)
        -:  299:{
    #####:  300:    _glfw.win32.disabledCursorWindow = window;
    #####:  301:    _glfwPlatformGetCursorPos(window,
    %%%%%:  301-block  0
call    0 never executed
        -:  302:                              &_glfw.win32.restoreCursorPosX,
        -:  303:                              &_glfw.win32.restoreCursorPosY);
    #####:  304:    updateCursorImage(window);
call    0 never executed
    #####:  305:    _glfwCenterCursorInContentArea(window);
call    0 never executed
    #####:  306:    updateClipRect(window);
call    0 never executed
        -:  307:
    #####:  308:    if (window->rawMouseMotion)
branch  0 never executed
branch  1 never executed
    #####:  309:        enableRawMouseMotion(window);
    %%%%%:  309-block  0
call    0 never executed
    #####:  310:}
        -:  311:
        -:  312:// Exit disabled cursor mode for the specified window
        -:  313://
function enableCursor called 0 returned 0% blocks executed 0%
    #####:  314:static void enableCursor(_GLFWwindow* window)
        -:  315:{
    #####:  316:    if (window->rawMouseMotion)
    %%%%%:  316-block  0
branch  0 never executed
branch  1 never executed
    #####:  317:        disableRawMouseMotion(window);
    %%%%%:  317-block  0
call    0 never executed
        -:  318:
    #####:  319:    _glfw.win32.disabledCursorWindow = NULL;
    #####:  320:    updateClipRect(NULL);
    %%%%%:  320-block  0
call    0 never executed
    #####:  321:    _glfwPlatformSetCursorPos(window,
call    0 never executed
        -:  322:                              _glfw.win32.restoreCursorPosX,
        -:  323:                              _glfw.win32.restoreCursorPosY);
    #####:  324:    updateCursorImage(window);
call    0 never executed
    #####:  325:}
        -:  326:
        -:  327:// Returns whether the cursor is in the content area of the specified window
        -:  328://
function cursorInContentArea called 0 returned 0% blocks executed 0%
    #####:  329:static GLFWbool cursorInContentArea(_GLFWwindow* window)
        -:  330:{
        -:  331:    RECT area;
        -:  332:    POINT pos;
        -:  333:
    #####:  334:    if (!GetCursorPos(&pos))
    %%%%%:  334-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  335:        return GLFW_FALSE;
    %%%%%:  335-block  0
        -:  336:
    #####:  337:    if (WindowFromPoint(pos) != window->win32.handle)
    %%%%%:  337-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  338:        return GLFW_FALSE;
    %%%%%:  338-block  0
        -:  339:
    #####:  340:    GetClientRect(window->win32.handle, &area);
    %%%%%:  340-block  0
call    0 never executed
    #####:  341:    ClientToScreen(window->win32.handle, (POINT*) &area.left);
call    0 never executed
    #####:  342:    ClientToScreen(window->win32.handle, (POINT*) &area.right);
call    0 never executed
        -:  343:
    #####:  344:    return PtInRect(&area, pos);
call    0 never executed
        -:  345:}
        -:  346:
        -:  347:// Update native window styles to match attributes
        -:  348://
function updateWindowStyles called 0 returned 0% blocks executed 0%
    #####:  349:static void updateWindowStyles(const _GLFWwindow* window)
        -:  350:{
        -:  351:    RECT rect;
    #####:  352:    DWORD style = GetWindowLongW(window->win32.handle, GWL_STYLE);
    %%%%%:  352-block  0
call    0 never executed
    #####:  353:    style &= ~(WS_OVERLAPPEDWINDOW | WS_POPUP);
    #####:  354:    style |= getWindowStyle(window);
call    0 never executed
        -:  355:
    #####:  356:    GetClientRect(window->win32.handle, &rect);
call    0 never executed
        -:  357:
    #####:  358:    if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  359:    {
    #####:  360:        AdjustWindowRectExForDpi(&rect, style, FALSE,
call    0 never executed
call    1 never executed
        -:  361:                                 getWindowExStyle(window),
    #####:  362:                                 GetDpiForWindow(window->win32.handle));
    %%%%%:  362-block  0
call    0 never executed
        -:  363:    }
        -:  364:    else
    #####:  365:        AdjustWindowRectEx(&rect, style, FALSE, getWindowExStyle(window));
    %%%%%:  365-block  0
call    0 never executed
call    1 never executed
        -:  366:
    #####:  367:    ClientToScreen(window->win32.handle, (POINT*) &rect.left);
    %%%%%:  367-block  0
call    0 never executed
    #####:  368:    ClientToScreen(window->win32.handle, (POINT*) &rect.right);
call    0 never executed
    #####:  369:    SetWindowLongW(window->win32.handle, GWL_STYLE, style);
call    0 never executed
    #####:  370:    SetWindowPos(window->win32.handle, HWND_TOP,
    #####:  371:                 rect.left, rect.top,
    #####:  372:                 rect.right - rect.left, rect.bottom - rect.top,
call    0 never executed
        -:  373:                 SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOZORDER);
    #####:  374:}
        -:  375:
        -:  376:// Update window framebuffer transparency
        -:  377://
function updateFramebufferTransparency called 0 returned 0% blocks executed 0%
    #####:  378:static void updateFramebufferTransparency(const _GLFWwindow* window)
        -:  379:{
        -:  380:    BOOL composition, opaque;
        -:  381:    DWORD color;
        -:  382:
    #####:  383:    if (!IsWindowsVistaOrGreater())
    %%%%%:  383-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  384:        return;
    %%%%%:  384-block  0
    %%%%%:  384-block  1
        -:  385:
    #####:  386:    if (FAILED(DwmIsCompositionEnabled(&composition)) || !composition)
    %%%%%:  386-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  386-block  1
branch  3 never executed
branch  4 never executed
    #####:  387:       return;
    %%%%%:  387-block  0
        -:  388:
    #####:  389:    if (IsWindows8OrGreater() ||
    %%%%%:  389-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  390:        (SUCCEEDED(DwmGetColorizationColor(&color, &opaque)) && !opaque))
    %%%%%:  390-block  0
call    0 never executed
    %%%%%:  390-block  1
branch  1 never executed
branch  2 never executed
    #####:  391:    {
    #####:  392:        HRGN region = CreateRectRgn(0, 0, -1, -1);
    %%%%%:  392-block  0
call    0 never executed
    #####:  393:        DWM_BLURBEHIND bb = {0};
    #####:  394:        bb.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
    #####:  395:        bb.hRgnBlur = region;
    #####:  396:        bb.fEnable = TRUE;
        -:  397:
    #####:  398:        DwmEnableBlurBehindWindow(window->win32.handle, &bb);
call    0 never executed
    #####:  399:        DeleteObject(region);
call    0 never executed
        -:  400:    }
        -:  401:    else
        -:  402:    {
        -:  403:        // HACK: Disable framebuffer transparency on Windows 7 when the
        -:  404:        //       colorization color is opaque, because otherwise the window
        -:  405:        //       contents is blended additively with the previous frame instead
        -:  406:        //       of replacing it
    #####:  407:        DWM_BLURBEHIND bb = {0};
    #####:  408:        bb.dwFlags = DWM_BB_ENABLE;
    #####:  409:        DwmEnableBlurBehindWindow(window->win32.handle, &bb);
    %%%%%:  409-block  0
call    0 never executed
        -:  410:    }
        -:  411:}
        -:  412:
        -:  413:// Retrieves and translates modifier keys
        -:  414://
function getKeyMods called 19 returned 100% blocks executed 71%
       19:  415:static int getKeyMods(void)
        -:  416:{
       19:  417:    int mods = 0;
        -:  418:
       19:  419:    if (GetKeyState(VK_SHIFT) & 0x8000)
       19:  419-block  0
call    0 returned 19
branch  1 taken 0 (fallthrough)
branch  2 taken 19
    #####:  420:        mods |= GLFW_MOD_SHIFT;
    %%%%%:  420-block  0
       19:  421:    if (GetKeyState(VK_CONTROL) & 0x8000)
       19:  421-block  0
call    0 returned 19
branch  1 taken 0 (fallthrough)
branch  2 taken 19
    #####:  422:        mods |= GLFW_MOD_CONTROL;
    %%%%%:  422-block  0
       19:  423:    if (GetKeyState(VK_MENU) & 0x8000)
       19:  423-block  0
call    0 returned 19
branch  1 taken 0 (fallthrough)
branch  2 taken 19
    #####:  424:        mods |= GLFW_MOD_ALT;
    %%%%%:  424-block  0
       19:  425:    if ((GetKeyState(VK_LWIN) | GetKeyState(VK_RWIN)) & 0x8000)
       19:  425-block  0
call    0 returned 19
call    1 returned 19
branch  2 taken 0 (fallthrough)
branch  3 taken 19
    #####:  426:        mods |= GLFW_MOD_SUPER;
    %%%%%:  426-block  0
       19:  427:    if (GetKeyState(VK_CAPITAL) & 1)
       19:  427-block  0
call    0 returned 19
branch  1 taken 0 (fallthrough)
branch  2 taken 19
    #####:  428:        mods |= GLFW_MOD_CAPS_LOCK;
    %%%%%:  428-block  0
       19:  429:    if (GetKeyState(VK_NUMLOCK) & 1)
       19:  429-block  0
call    0 returned 19
branch  1 taken 0 (fallthrough)
branch  2 taken 19
    #####:  430:        mods |= GLFW_MOD_NUM_LOCK;
    %%%%%:  430-block  0
        -:  431:
       19:  432:    return mods;
       19:  432-block  0
        -:  433:}
        -:  434:
function fitToMonitor called 0 returned 0% blocks executed 0%
    #####:  435:static void fitToMonitor(_GLFWwindow* window)
        -:  436:{
    #####:  437:    MONITORINFO mi = { sizeof(mi) };
    #####:  438:    GetMonitorInfo(window->monitor->win32.handle, &mi);
    %%%%%:  438-block  0
call    0 never executed
    #####:  439:    SetWindowPos(window->win32.handle, HWND_TOPMOST,
    #####:  440:                 mi.rcMonitor.left,
    #####:  441:                 mi.rcMonitor.top,
    #####:  442:                 mi.rcMonitor.right - mi.rcMonitor.left,
    #####:  443:                 mi.rcMonitor.bottom - mi.rcMonitor.top,
call    0 never executed
        -:  444:                 SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);
    #####:  445:}
        -:  446:
        -:  447:// Make the specified window and its video mode active on its monitor
        -:  448://
function acquireMonitor called 0 returned 0% blocks executed 0%
    #####:  449:static void acquireMonitor(_GLFWwindow* window)
        -:  450:{
    #####:  451:    if (!_glfw.win32.acquiredMonitorCount)
    %%%%%:  451-block  0
branch  0 never executed
branch  1 never executed
        -:  452:    {
    #####:  453:        SetThreadExecutionState(ES_CONTINUOUS | ES_DISPLAY_REQUIRED);
    %%%%%:  453-block  0
call    0 never executed
        -:  454:
        -:  455:        // HACK: When mouse trails are enabled the cursor becomes invisible when
        -:  456:        //       the OpenGL ICD switches to page flipping
    #####:  457:        SystemParametersInfo(SPI_GETMOUSETRAILS, 0, &_glfw.win32.mouseTrailSize, 0);
call    0 never executed
    #####:  458:        SystemParametersInfo(SPI_SETMOUSETRAILS, 0, 0, 0);
call    0 never executed
        -:  459:    }
        -:  460:
    #####:  461:    if (!window->monitor->window)
    %%%%%:  461-block  0
branch  0 never executed
branch  1 never executed
    #####:  462:        _glfw.win32.acquiredMonitorCount++;
    %%%%%:  462-block  0
        -:  463:
    #####:  464:    _glfwSetVideoModeWin32(window->monitor, &window->videoMode);
    %%%%%:  464-block  0
call    0 never executed
    #####:  465:    _glfwInputMonitorWindow(window->monitor, window);
call    0 never executed
    #####:  466:}
        -:  467:
        -:  468:// Remove the window and restore the original video mode
        -:  469://
function releaseMonitor called 0 returned 0% blocks executed 0%
    #####:  470:static void releaseMonitor(_GLFWwindow* window)
        -:  471:{
    #####:  472:    if (window->monitor->window != window)
    %%%%%:  472-block  0
branch  0 never executed
branch  1 never executed
    #####:  473:        return;
    %%%%%:  473-block  0
        -:  474:
    #####:  475:    _glfw.win32.acquiredMonitorCount--;
    #####:  476:    if (!_glfw.win32.acquiredMonitorCount)
    %%%%%:  476-block  0
branch  0 never executed
branch  1 never executed
        -:  477:    {
    #####:  478:        SetThreadExecutionState(ES_CONTINUOUS);
    %%%%%:  478-block  0
call    0 never executed
        -:  479:
        -:  480:        // HACK: Restore mouse trail length saved in acquireMonitor
    #####:  481:        SystemParametersInfo(SPI_SETMOUSETRAILS, _glfw.win32.mouseTrailSize, 0, 0);
call    0 never executed
        -:  482:    }
        -:  483:
    #####:  484:    _glfwInputMonitorWindow(window->monitor, NULL);
    %%%%%:  484-block  0
call    0 never executed
    #####:  485:    _glfwRestoreVideoModeWin32(window->monitor);
call    0 never executed
        -:  486:}
        -:  487:
        -:  488:// Window callback function (handles window messages)
        -:  489://
function windowProc called 161 returned 100% blocks executed 37%
      161:  490:static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg,
        -:  491:                                   WPARAM wParam, LPARAM lParam)
        -:  492:{
      161:  493:    _GLFWwindow* window = GetPropW(hWnd, L"GLFW");
      161:  493-block  0
call    0 returned 161
      161:  494:    if (!window)
branch  0 taken 26 (fallthrough)
branch  1 taken 135
        -:  495:    {
        -:  496:        // This is the message handling for the hidden helper window
        -:  497:        // and for a regular window during its initial creation
        -:  498:
       26:  499:        switch (uMsg)
       26:  499-block  0
branch  0 taken 2
branch  1 taken 0
branch  2 taken 0
branch  3 taken 24
        -:  500:        {
        2:  501:            case WM_NCCREATE:
        -:  502:            {
        2:  503:                if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
        2:  503-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -:  504:                {
        2:  505:                    const CREATESTRUCTW* cs = (const CREATESTRUCTW*) lParam;
        2:  506:                    const _GLFWwndconfig* wndconfig = cs->lpCreateParams;
        -:  507:
        -:  508:                    // On per-monitor DPI aware V1 systems, only enable
        -:  509:                    // non-client scaling for windows that scale the client area
        -:  510:                    // We need WM_GETDPISCALEDSIZE from V2 to keep the client
        -:  511:                    // area static when the non-client area is scaled
        2:  512:                    if (wndconfig && wndconfig->scaleToMonitor)
        2:  512-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  512-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:  513:                        EnableNonClientDpiScaling(hWnd);
    %%%%%:  513-block  0
call    0 never executed
        -:  514:                }
        -:  515:
        2:  516:                break;
        2:  516-block  0
        -:  517:            }
        -:  518:
    #####:  519:            case WM_DISPLAYCHANGE:
    #####:  520:                _glfwPollMonitorsWin32();
    %%%%%:  520-block  0
call    0 never executed
    #####:  521:                break;
        -:  522:
    #####:  523:            case WM_DEVICECHANGE:
        -:  524:            {
    #####:  525:                if (!_glfw.joysticksInitialized)
    %%%%%:  525-block  0
branch  0 never executed
branch  1 never executed
    #####:  526:                    break;
    %%%%%:  526-block  0
        -:  527:
    #####:  528:                if (wParam == DBT_DEVICEARRIVAL)
    %%%%%:  528-block  0
branch  0 never executed
branch  1 never executed
        -:  529:                {
    #####:  530:                    DEV_BROADCAST_HDR* dbh = (DEV_BROADCAST_HDR*) lParam;
    #####:  531:                    if (dbh && dbh->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
    %%%%%:  531-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  531-block  1
branch  2 never executed
branch  3 never executed
    #####:  532:                        _glfwDetectJoystickConnectionWin32();
    %%%%%:  532-block  0
call    0 never executed
        -:  533:                }
    #####:  534:                else if (wParam == DBT_DEVICEREMOVECOMPLETE)
    %%%%%:  534-block  0
branch  0 never executed
branch  1 never executed
        -:  535:                {
    #####:  536:                    DEV_BROADCAST_HDR* dbh = (DEV_BROADCAST_HDR*) lParam;
    #####:  537:                    if (dbh && dbh->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
    %%%%%:  537-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  537-block  1
branch  2 never executed
branch  3 never executed
    #####:  538:                        _glfwDetectJoystickDisconnectionWin32();
    %%%%%:  538-block  0
call    0 never executed
        -:  539:                }
        -:  540:
    #####:  541:                break;
    %%%%%:  541-block  0
        -:  542:            }
        -:  543:        }
        -:  544:
       26:  545:        return DefWindowProcW(hWnd, uMsg, wParam, lParam);
       26:  545-block  0
call    0 returned 26
        -:  546:    }
        -:  547:
      135:  548:    switch (uMsg)
      135:  548-block  0
branch  0 taken 0
branch  1 taken 3
branch  2 taken 1
branch  3 taken 0
branch  4 taken 1
branch  5 taken 1
branch  6 taken 0
branch  7 taken 5
branch  8 taken 0
branch  9 taken 10
branch 10 taken 4
branch 11 taken 15
branch 12 taken 0
branch 13 taken 1
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 1
branch 19 taken 2
branch 20 taken 0
branch 21 taken 1
branch 22 taken 2
branch 23 taken 3
branch 24 taken 6
branch 25 taken 0
branch 26 taken 0
branch 27 taken 0
branch 28 taken 22
branch 29 taken 0
branch 30 taken 57
        -:  549:    {
    #####:  550:        case WM_MOUSEACTIVATE:
        -:  551:        {
        -:  552:            // HACK: Postpone cursor disabling when the window was activated by
        -:  553:            //       clicking a caption button
    #####:  554:            if (HIWORD(lParam) == WM_LBUTTONDOWN)
    %%%%%:  554-block  0
branch  0 never executed
branch  1 never executed
        -:  555:            {
    #####:  556:                if (LOWORD(lParam) != HTCLIENT)
    %%%%%:  556-block  0
branch  0 never executed
branch  1 never executed
    #####:  557:                    window->win32.frameAction = GLFW_TRUE;
    %%%%%:  557-block  0
        -:  558:            }
        -:  559:
    #####:  560:            break;
    %%%%%:  560-block  0
        -:  561:        }
        -:  562:
        3:  563:        case WM_CAPTURECHANGED:
        -:  564:        {
        -:  565:            // HACK: Disable the cursor once the caption button action has been
        -:  566:            //       completed or cancelled
        3:  567:            if (lParam == 0 && window->win32.frameAction)
        3:  567-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  567-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 3
        -:  568:            {
    #####:  569:                if (window->cursorMode == GLFW_CURSOR_DISABLED)
    %%%%%:  569-block  0
branch  0 never executed
branch  1 never executed
    #####:  570:                    disableCursor(window);
    %%%%%:  570-block  0
call    0 never executed
        -:  571:
    #####:  572:                window->win32.frameAction = GLFW_FALSE;
    %%%%%:  572-block  0
        -:  573:            }
        -:  574:
        3:  575:            break;
        3:  575-block  0
        -:  576:        }
        -:  577:
        1:  578:        case WM_SETFOCUS:
        -:  579:        {
        1:  580:            _glfwInputWindowFocus(window, GLFW_TRUE);
        1:  580-block  0
call    0 returned 1
        -:  581:
        -:  582:            // HACK: Do not disable cursor while the user is interacting with
        -:  583:            //       a caption button
        1:  584:            if (window->win32.frameAction)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  585:                break;
    %%%%%:  585-block  0
        -:  586:
        1:  587:            if (window->cursorMode == GLFW_CURSOR_DISABLED)
        1:  587-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  588:                disableCursor(window);
    %%%%%:  588-block  0
call    0 never executed
        -:  589:
        1:  590:            return 0;
        1:  590-block  0
        -:  591:        }
        -:  592:
    #####:  593:        case WM_KILLFOCUS:
        -:  594:        {
    #####:  595:            if (window->cursorMode == GLFW_CURSOR_DISABLED)
    %%%%%:  595-block  0
branch  0 never executed
branch  1 never executed
    #####:  596:                enableCursor(window);
    %%%%%:  596-block  0
call    0 never executed
        -:  597:
    #####:  598:            if (window->monitor && window->autoIconify)
    %%%%%:  598-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  598-block  1
branch  2 never executed
branch  3 never executed
    #####:  599:                _glfwPlatformIconifyWindow(window);
    %%%%%:  599-block  0
call    0 never executed
        -:  600:
    #####:  601:            _glfwInputWindowFocus(window, GLFW_FALSE);
    %%%%%:  601-block  0
call    0 never executed
    #####:  602:            return 0;
        -:  603:        }
        -:  604:
        1:  605:        case WM_SYSCOMMAND:
        -:  606:        {
        1:  607:            switch (wParam & 0xfff0)
        1:  607-block  0
branch  0 taken 0
branch  1 taken 0
branch  2 taken 1
        -:  608:            {
    #####:  609:                case SC_SCREENSAVE:
        -:  610:                case SC_MONITORPOWER:
        -:  611:                {
    #####:  612:                    if (window->monitor)
    %%%%%:  612-block  0
branch  0 never executed
branch  1 never executed
        -:  613:                    {
        -:  614:                        // We are running in full screen mode, so disallow
        -:  615:                        // screen saver and screen blanking
    #####:  616:                        return 0;
    %%%%%:  616-block  0
        -:  617:                    }
        -:  618:                    else
    #####:  619:                        break;
    %%%%%:  619-block  0
        -:  620:                }
        -:  621:
        -:  622:                // User trying to access application menu using ALT?
    #####:  623:                case SC_KEYMENU:
        -:  624:                {
    #####:  625:                    if (!window->win32.keymenu)
    %%%%%:  625-block  0
branch  0 never executed
branch  1 never executed
    #####:  626:                        return 0;
    %%%%%:  626-block  0
        -:  627:
    #####:  628:                    break;
    %%%%%:  628-block  0
        -:  629:                }
        -:  630:            }
        1:  631:            break;
        1:  631-block  0
        -:  632:        }
        -:  633:
        1:  634:        case WM_CLOSE:
        -:  635:        {
        1:  636:            _glfwInputWindowCloseRequest(window);
        1:  636-block  0
call    0 returned 1
        1:  637:            return 0;
        -:  638:        }
        -:  639:
    #####:  640:        case WM_INPUTLANGCHANGE:
        -:  641:        {
    #####:  642:            _glfwUpdateKeyNamesWin32();
    %%%%%:  642-block  0
call    0 never executed
    #####:  643:            break;
        -:  644:        }
        -:  645:
        5:  646:        case WM_CHAR:
        -:  647:        case WM_SYSCHAR:
        -:  648:        {
       5*:  649:            if (wParam >= 0xd800 && wParam <= 0xdbff)
        5:  649-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:  649-block  1
branch  2 never executed
branch  3 never executed
    #####:  650:                window->win32.highSurrogate = (WCHAR) wParam;
    %%%%%:  650-block  0
        -:  651:            else
        -:  652:            {
        5:  653:                unsigned int codepoint = 0;
        -:  654:
       5*:  655:                if (wParam >= 0xdc00 && wParam <= 0xdfff)
        5:  655-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:  655-block  1
branch  2 never executed
branch  3 never executed
        -:  656:                {
    #####:  657:                    if (window->win32.highSurrogate)
    %%%%%:  657-block  0
branch  0 never executed
branch  1 never executed
        -:  658:                    {
    #####:  659:                        codepoint += (window->win32.highSurrogate - 0xd800) << 10;
    #####:  660:                        codepoint += (WCHAR) wParam - 0xdc00;
    #####:  661:                        codepoint += 0x10000;
    %%%%%:  661-block  0
        -:  662:                    }
        -:  663:                }
        -:  664:                else
        5:  665:                    codepoint = (WCHAR) wParam;
        5:  665-block  0
        -:  666:
        5:  667:                window->win32.highSurrogate = 0;
        5:  668:                _glfwInputChar(window, codepoint, getKeyMods(), uMsg != WM_SYSCHAR);
        5:  668-block  0
call    0 returned 5
call    1 returned 5
        -:  669:            }
        -:  670:
       5*:  671:            if (uMsg == WM_SYSCHAR && window->win32.keymenu)
        5:  671-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:  671-block  1
branch  2 never executed
branch  3 never executed
    #####:  672:                break;
    %%%%%:  672-block  0
        -:  673:
        5:  674:            return 0;
        5:  674-block  0
        -:  675:        }
        -:  676:
    #####:  677:        case WM_UNICHAR:
        -:  678:        {
    #####:  679:            if (wParam == UNICODE_NOCHAR)
    %%%%%:  679-block  0
branch  0 never executed
branch  1 never executed
        -:  680:            {
        -:  681:                // WM_UNICHAR is not sent by Windows, but is sent by some
        -:  682:                // third-party input method engine
        -:  683:                // Returning TRUE here announces support for this message
    #####:  684:                return TRUE;
    %%%%%:  684-block  0
        -:  685:            }
        -:  686:
    #####:  687:            _glfwInputChar(window, (unsigned int) wParam, getKeyMods(), GLFW_TRUE);
    %%%%%:  687-block  0
call    0 never executed
call    1 never executed
    #####:  688:            return 0;
        -:  689:        }
        -:  690:
       10:  691:        case WM_KEYDOWN:
        -:  692:        case WM_SYSKEYDOWN:
        -:  693:        case WM_KEYUP:
        -:  694:        case WM_SYSKEYUP:
        -:  695:        {
        -:  696:            int key, scancode;
       10:  697:            const int action = (HIWORD(lParam) & KF_UP) ? GLFW_RELEASE : GLFW_PRESS;
       10:  698:            const int mods = getKeyMods();
       10:  698-block  0
call    0 returned 10
        -:  699:
       10:  700:            scancode = (HIWORD(lParam) & (KF_EXTENDED | 0xff));
       10:  701:            if (!scancode)
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  702:            {
        -:  703:                // NOTE: Some synthetic key messages have a scancode of zero
        -:  704:                // HACK: Map the virtual key back to a usable scancode
    #####:  705:                scancode = MapVirtualKeyW((UINT) wParam, MAPVK_VK_TO_VSC);
    %%%%%:  705-block  0
call    0 never executed
        -:  706:            }
        -:  707:
       10:  708:            key = _glfw.win32.keycodes[scancode];
        -:  709:
        -:  710:            // The Ctrl keys require special handling
       10:  711:            if (wParam == VK_CONTROL)
       10:  711-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  712:            {
    #####:  713:                if (HIWORD(lParam) & KF_EXTENDED)
    %%%%%:  713-block  0
branch  0 never executed
branch  1 never executed
        -:  714:                {
        -:  715:                    // Right side keys have the extended key bit set
    #####:  716:                    key = GLFW_KEY_RIGHT_CONTROL;
    %%%%%:  716-block  0
        -:  717:                }
        -:  718:                else
        -:  719:                {
        -:  720:                    // NOTE: Alt Gr sends Left Ctrl followed by Right Alt
        -:  721:                    // HACK: We only want one event for Alt Gr, so if we detect
        -:  722:                    //       this sequence we discard this Left Ctrl message now
        -:  723:                    //       and later report Right Alt normally
        -:  724:                    MSG next;
    #####:  725:                    const DWORD time = GetMessageTime();
    %%%%%:  725-block  0
call    0 never executed
        -:  726:
    #####:  727:                    if (PeekMessageW(&next, NULL, 0, 0, PM_NOREMOVE))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  728:                    {
    #####:  729:                        if (next.message == WM_KEYDOWN ||
    %%%%%:  729-block  0
branch  0 never executed
branch  1 never executed
    #####:  730:                            next.message == WM_SYSKEYDOWN ||
    %%%%%:  730-block  0
branch  0 never executed
branch  1 never executed
    #####:  731:                            next.message == WM_KEYUP ||
    %%%%%:  731-block  0
branch  0 never executed
branch  1 never executed
    #####:  732:                            next.message == WM_SYSKEYUP)
    %%%%%:  732-block  0
branch  0 never executed
branch  1 never executed
        -:  733:                        {
    #####:  734:                            if (next.wParam == VK_MENU &&
    %%%%%:  734-block  0
branch  0 never executed
branch  1 never executed
    #####:  735:                                (HIWORD(next.lParam) & KF_EXTENDED) &&
    %%%%%:  735-block  0
branch  0 never executed
branch  1 never executed
    #####:  736:                                next.time == time)
    %%%%%:  736-block  0
branch  0 never executed
branch  1 never executed
        -:  737:                            {
        -:  738:                                // Next message is Right Alt down so discard this
    #####:  739:                                break;
    %%%%%:  739-block  0
        -:  740:                            }
        -:  741:                        }
        -:  742:                    }
        -:  743:
        -:  744:                    // This is a regular Left Ctrl message
    #####:  745:                    key = GLFW_KEY_LEFT_CONTROL;
    %%%%%:  745-block  0
        -:  746:                }
        -:  747:            }
       10:  748:            else if (wParam == VK_PROCESSKEY)
       10:  748-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  749:            {
        -:  750:                // IME notifies that keys have been filtered by setting the
        -:  751:                // virtual key-code to VK_PROCESSKEY
    #####:  752:                break;
    %%%%%:  752-block  0
        -:  753:            }
        -:  754:
       10:  755:            if (action == GLFW_RELEASE && wParam == VK_SHIFT)
       10:  755-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 5
        5:  755-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 5
        -:  756:            {
        -:  757:                // HACK: Release both Shift keys on Shift up event, as when both
        -:  758:                //       are pressed the first release does not emit any event
        -:  759:                // NOTE: The other half of this is in _glfwPlatformPollEvents
    #####:  760:                _glfwInputKey(window, GLFW_KEY_LEFT_SHIFT, scancode, action, mods);
    %%%%%:  760-block  0
call    0 never executed
    #####:  761:                _glfwInputKey(window, GLFW_KEY_RIGHT_SHIFT, scancode, action, mods);
call    0 never executed
        -:  762:            }
       10:  763:            else if (wParam == VK_SNAPSHOT)
       10:  763-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  764:            {
        -:  765:                // HACK: Key down is not reported for the Print Screen key
    #####:  766:                _glfwInputKey(window, key, scancode, GLFW_PRESS, mods);
    %%%%%:  766-block  0
call    0 never executed
    #####:  767:                _glfwInputKey(window, key, scancode, GLFW_RELEASE, mods);
call    0 never executed
        -:  768:            }
        -:  769:            else
       10:  770:                _glfwInputKey(window, key, scancode, action, mods);
       10:  770-block  0
call    0 returned 10
        -:  771:
       10:  772:            break;
       10:  772-block  0
        -:  773:        }
        -:  774:
        4:  775:        case WM_LBUTTONDOWN:
        -:  776:        case WM_RBUTTONDOWN:
        -:  777:        case WM_MBUTTONDOWN:
        -:  778:        case WM_XBUTTONDOWN:
        -:  779:        case WM_LBUTTONUP:
        -:  780:        case WM_RBUTTONUP:
        -:  781:        case WM_MBUTTONUP:
        -:  782:        case WM_XBUTTONUP:
        -:  783:        {
        -:  784:            int i, button, action;
        -:  785:
        4:  786:            if (uMsg == WM_LBUTTONDOWN || uMsg == WM_LBUTTONUP)
        4:  786-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  786-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        4:  787:                button = GLFW_MOUSE_BUTTON_LEFT;
        4:  787-block  0
    #####:  788:            else if (uMsg == WM_RBUTTONDOWN || uMsg == WM_RBUTTONUP)
    %%%%%:  788-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  788-block  1
branch  2 never executed
branch  3 never executed
    #####:  789:                button = GLFW_MOUSE_BUTTON_RIGHT;
    %%%%%:  789-block  0
    #####:  790:            else if (uMsg == WM_MBUTTONDOWN || uMsg == WM_MBUTTONUP)
    %%%%%:  790-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  790-block  1
branch  2 never executed
branch  3 never executed
    #####:  791:                button = GLFW_MOUSE_BUTTON_MIDDLE;
    %%%%%:  791-block  0
    #####:  792:            else if (GET_XBUTTON_WPARAM(wParam) == XBUTTON1)
    %%%%%:  792-block  0
branch  0 never executed
branch  1 never executed
    #####:  793:                button = GLFW_MOUSE_BUTTON_4;
    %%%%%:  793-block  0
        -:  794:            else
    #####:  795:                button = GLFW_MOUSE_BUTTON_5;
    %%%%%:  795-block  0
        -:  796:
        4:  797:            if (uMsg == WM_LBUTTONDOWN || uMsg == WM_RBUTTONDOWN ||
        4:  797-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  797-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2:  797-block  2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2:  798:                uMsg == WM_MBUTTONDOWN || uMsg == WM_XBUTTONDOWN)
        2:  798-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  799:            {
        2:  800:                action = GLFW_PRESS;
        2:  800-block  0
        -:  801:            }
        -:  802:            else
        2:  803:                action = GLFW_RELEASE;
        2:  803-block  0
        -:  804:
       20:  805:            for (i = 0;  i <= GLFW_MOUSE_BUTTON_LAST;  i++)
        4:  805-block  0
       16:  805-block  1
       20:  805-block  2
branch  0 taken 18
branch  1 taken 2 (fallthrough)
        -:  806:            {
       18:  807:                if (window->mouseButtons[i] == GLFW_PRESS)
       18:  807-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:  808:                    break;
        2:  808-block  0
        -:  809:            }
        -:  810:
        4:  811:            if (i > GLFW_MOUSE_BUTTON_LAST)
        4:  811-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  812:                SetCapture(hWnd);
        2:  812-block  0
call    0 returned 2
        -:  813:
        4:  814:            _glfwInputMouseClick(window, button, action, getKeyMods());
        4:  814-block  0
call    0 returned 4
call    1 returned 4
        -:  815:
       20:  816:            for (i = 0;  i <= GLFW_MOUSE_BUTTON_LAST;  i++)
       16:  816-block  0
       20:  816-block  1
branch  0 taken 18
branch  1 taken 2 (fallthrough)
        -:  817:            {
       18:  818:                if (window->mouseButtons[i] == GLFW_PRESS)
       18:  818-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:  819:                    break;
        2:  819-block  0
        -:  820:            }
        -:  821:
        4:  822:            if (i > GLFW_MOUSE_BUTTON_LAST)
        4:  822-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  823:                ReleaseCapture();
        2:  823-block  0
call    0 returned 2
        -:  824:
        4:  825:            if (uMsg == WM_XBUTTONDOWN || uMsg == WM_XBUTTONUP)
        4:  825-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:  825-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####:  826:                return TRUE;
    %%%%%:  826-block  0
        -:  827:
        4:  828:            return 0;
        4:  828-block  0
        -:  829:        }
        -:  830:
       15:  831:        case WM_MOUSEMOVE:
        -:  832:        {
       15:  833:            const int x = GET_X_LPARAM(lParam);
       15:  834:            const int y = GET_Y_LPARAM(lParam);
        -:  835:
       15:  836:            if (!window->win32.cursorTracked)
       15:  836-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 14
        -:  837:            {
        -:  838:                TRACKMOUSEEVENT tme;
        1:  839:                ZeroMemory(&tme, sizeof(tme));
        1:  840:                tme.cbSize = sizeof(tme);
        1:  841:                tme.dwFlags = TME_LEAVE;
        1:  842:                tme.hwndTrack = window->win32.handle;
        1:  843:                TrackMouseEvent(&tme);
        1:  843-block  0
call    0 returned 1
        -:  844:
        1:  845:                window->win32.cursorTracked = GLFW_TRUE;
        1:  846:                _glfwInputCursorEnter(window, GLFW_TRUE);
call    0 returned 1
        -:  847:            }
        -:  848:
       15:  849:            if (window->cursorMode == GLFW_CURSOR_DISABLED)
       15:  849-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -:  850:            {
    #####:  851:                const int dx = x - window->win32.lastCursorPosX;
    #####:  852:                const int dy = y - window->win32.lastCursorPosY;
        -:  853:
    #####:  854:                if (_glfw.win32.disabledCursorWindow != window)
    %%%%%:  854-block  0
branch  0 never executed
branch  1 never executed
    #####:  855:                    break;
    %%%%%:  855-block  0
    #####:  856:                if (window->rawMouseMotion)
    %%%%%:  856-block  0
branch  0 never executed
branch  1 never executed
    #####:  857:                    break;
    %%%%%:  857-block  0
        -:  858:
    #####:  859:                _glfwInputCursorPos(window,
    #####:  860:                                    window->virtualCursorPosX + dx,
    #####:  861:                                    window->virtualCursorPosY + dy);
    %%%%%:  861-block  0
call    0 never executed
        -:  862:            }
        -:  863:            else
       15:  864:                _glfwInputCursorPos(window, x, y);
       15:  864-block  0
call    0 returned 15
        -:  865:
       15:  866:            window->win32.lastCursorPosX = x;
       15:  867:            window->win32.lastCursorPosY = y;
        -:  868:
       15:  869:            return 0;
       15:  869-block  0
        -:  870:        }
        -:  871:
    #####:  872:        case WM_INPUT:
        -:  873:        {
    #####:  874:            UINT size = 0;
    #####:  875:            HRAWINPUT ri = (HRAWINPUT) lParam;
    #####:  876:            RAWINPUT* data = NULL;
        -:  877:            int dx, dy;
        -:  878:
    #####:  879:            if (_glfw.win32.disabledCursorWindow != window)
    %%%%%:  879-block  0
branch  0 never executed
branch  1 never executed
    #####:  880:                break;
    %%%%%:  880-block  0
    #####:  881:            if (!window->rawMouseMotion)
    %%%%%:  881-block  0
branch  0 never executed
branch  1 never executed
    #####:  882:                break;
    %%%%%:  882-block  0
        -:  883:
    #####:  884:            GetRawInputData(ri, RID_INPUT, NULL, &size, sizeof(RAWINPUTHEADER));
    %%%%%:  884-block  0
call    0 never executed
    #####:  885:            if (size > (UINT) _glfw.win32.rawInputSize)
branch  0 never executed
branch  1 never executed
        -:  886:            {
    #####:  887:                free(_glfw.win32.rawInput);
    #####:  888:                _glfw.win32.rawInput = calloc(size, 1);
    #####:  889:                _glfw.win32.rawInputSize = size;
    %%%%%:  889-block  0
        -:  890:            }
        -:  891:
    #####:  892:            size = _glfw.win32.rawInputSize;
    #####:  893:            if (GetRawInputData(ri, RID_INPUT,
branch  0 never executed
branch  1 never executed
    #####:  894:                                _glfw.win32.rawInput, &size,
    %%%%%:  894-block  0
call    0 never executed
        -:  895:                                sizeof(RAWINPUTHEADER)) == (UINT) -1)
        -:  896:            {
    #####:  897:                _glfwInputError(GLFW_PLATFORM_ERROR,
    %%%%%:  897-block  0
call    0 never executed
        -:  898:                                "Win32: Failed to retrieve raw input data");
    #####:  899:                break;
        -:  900:            }
        -:  901:
    #####:  902:            data = _glfw.win32.rawInput;
    #####:  903:            if (data->data.mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
    %%%%%:  903-block  0
branch  0 never executed
branch  1 never executed
        -:  904:            {
    #####:  905:                dx = data->data.mouse.lLastX - window->win32.lastCursorPosX;
    #####:  906:                dy = data->data.mouse.lLastY - window->win32.lastCursorPosY;
    %%%%%:  906-block  0
        -:  907:            }
        -:  908:            else
        -:  909:            {
    #####:  910:                dx = data->data.mouse.lLastX;
    #####:  911:                dy = data->data.mouse.lLastY;
    %%%%%:  911-block  0
        -:  912:            }
        -:  913:
    #####:  914:            _glfwInputCursorPos(window,
    #####:  915:                                window->virtualCursorPosX + dx,
    #####:  916:                                window->virtualCursorPosY + dy);
    %%%%%:  916-block  0
call    0 never executed
        -:  917:
    #####:  918:            window->win32.lastCursorPosX += dx;
    #####:  919:            window->win32.lastCursorPosY += dy;
    #####:  920:            break;
        -:  921:        }
        -:  922:
        1:  923:        case WM_MOUSELEAVE:
        -:  924:        {
        1:  925:            window->win32.cursorTracked = GLFW_FALSE;
        1:  926:            _glfwInputCursorEnter(window, GLFW_FALSE);
        1:  926-block  0
call    0 returned 1
        1:  927:            return 0;
        -:  928:        }
        -:  929:
    #####:  930:        case WM_MOUSEWHEEL:
        -:  931:        {
    #####:  932:            _glfwInputScroll(window, 0.0, (SHORT) HIWORD(wParam) / (double) WHEEL_DELTA);
    %%%%%:  932-block  0
call    0 never executed
    #####:  933:            return 0;
        -:  934:        }
        -:  935:
    #####:  936:        case WM_MOUSEHWHEEL:
        -:  937:        {
        -:  938:            // This message is only sent on Windows Vista and later
        -:  939:            // NOTE: The X-axis is inverted for consistency with macOS and X11
    #####:  940:            _glfwInputScroll(window, -((SHORT) HIWORD(wParam) / (double) WHEEL_DELTA), 0.0);
    %%%%%:  940-block  0
call    0 never executed
    #####:  941:            return 0;
        -:  942:        }
        -:  943:
    #####:  944:        case WM_ENTERSIZEMOVE:
        -:  945:        case WM_ENTERMENULOOP:
        -:  946:        {
    #####:  947:            if (window->win32.frameAction)
    %%%%%:  947-block  0
branch  0 never executed
branch  1 never executed
    #####:  948:                break;
    %%%%%:  948-block  0
        -:  949:
        -:  950:            // HACK: Enable the cursor while the user is moving or
        -:  951:            //       resizing the window or using the window menu
    #####:  952:            if (window->cursorMode == GLFW_CURSOR_DISABLED)
    %%%%%:  952-block  0
branch  0 never executed
branch  1 never executed
    #####:  953:                enableCursor(window);
    %%%%%:  953-block  0
call    0 never executed
        -:  954:
    #####:  955:            break;
    %%%%%:  955-block  0
        -:  956:        }
        -:  957:
    #####:  958:        case WM_EXITSIZEMOVE:
        -:  959:        case WM_EXITMENULOOP:
        -:  960:        {
    #####:  961:            if (window->win32.frameAction)
    %%%%%:  961-block  0
branch  0 never executed
branch  1 never executed
    #####:  962:                break;
    %%%%%:  962-block  0
        -:  963:
        -:  964:            // HACK: Disable the cursor once the user is done moving or
        -:  965:            //       resizing the window or using the menu
    #####:  966:            if (window->cursorMode == GLFW_CURSOR_DISABLED)
    %%%%%:  966-block  0
branch  0 never executed
branch  1 never executed
    #####:  967:                disableCursor(window);
    %%%%%:  967-block  0
call    0 never executed
        -:  968:
    #####:  969:            break;
    %%%%%:  969-block  0
        -:  970:        }
        -:  971:
        1:  972:        case WM_SIZE:
        -:  973:        {
        1:  974:            const int width = LOWORD(lParam);
        1:  975:            const int height = HIWORD(lParam);
        1:  976:            const GLFWbool iconified = wParam == SIZE_MINIMIZED;
       2*:  977:            const GLFWbool maximized = wParam == SIZE_MAXIMIZED ||
        1:  977-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
    %%%%%:  977-block  1
        1:  977-block  2
       1*:  978:                                       (window->win32.maximized &&
        1:  978-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  978-block  1
branch  2 never executed
branch  3 never executed
        -:  979:                                        wParam != SIZE_RESTORED);
        -:  980:
        1:  981:            if (_glfw.win32.disabledCursorWindow == window)
        1:  981-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  982:                updateClipRect(window);
    %%%%%:  982-block  0
call    0 never executed
        -:  983:
        1:  984:            if (window->win32.iconified != iconified)
        1:  984-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  985:                _glfwInputWindowIconify(window, iconified);
    %%%%%:  985-block  0
call    0 never executed
        -:  986:
        1:  987:            if (window->win32.maximized != maximized)
        1:  987-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  988:                _glfwInputWindowMaximize(window, maximized);
    %%%%%:  988-block  0
call    0 never executed
        -:  989:
        1:  990:            if (width != window->win32.width || height != window->win32.height)
        1:  990-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  990-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -:  991:            {
    #####:  992:                window->win32.width = width;
    #####:  993:                window->win32.height = height;
        -:  994:
    #####:  995:                _glfwInputFramebufferSize(window, width, height);
    %%%%%:  995-block  0
call    0 never executed
    #####:  996:                _glfwInputWindowSize(window, width, height);
call    0 never executed
        -:  997:            }
        -:  998:
       1*:  999:            if (window->monitor && window->win32.iconified != iconified)
        1:  999-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  999-block  1
branch  2 never executed
branch  3 never executed
        -: 1000:            {
    #####: 1001:                if (iconified)
    %%%%%: 1001-block  0
branch  0 never executed
branch  1 never executed
    #####: 1002:                    releaseMonitor(window);
    %%%%%: 1002-block  0
call    0 never executed
        -: 1003:                else
        -: 1004:                {
    #####: 1005:                    acquireMonitor(window);
    %%%%%: 1005-block  0
call    0 never executed
    #####: 1006:                    fitToMonitor(window);
call    0 never executed
        -: 1007:                }
        -: 1008:            }
        -: 1009:
        1: 1010:            window->win32.iconified = iconified;
        1: 1011:            window->win32.maximized = maximized;
        1: 1012:            return 0;
        1: 1012-block  0
        -: 1013:        }
        -: 1014:
        2: 1015:        case WM_MOVE:
        -: 1016:        {
        2: 1017:            if (_glfw.win32.disabledCursorWindow == window)
        2: 1017-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1018:                updateClipRect(window);
    %%%%%: 1018-block  0
call    0 never executed
        -: 1019:
        -: 1020:            // NOTE: This cannot use LOWORD/HIWORD recommended by MSDN, as
        -: 1021:            // those macros do not handle negative window positions correctly
        2: 1022:            _glfwInputWindowPos(window,
        2: 1023:                                GET_X_LPARAM(lParam),
        2: 1024:                                GET_Y_LPARAM(lParam));
        2: 1024-block  0
call    0 returned 2
        2: 1025:            return 0;
        -: 1026:        }
        -: 1027:
    #####: 1028:        case WM_SIZING:
        -: 1029:        {
    #####: 1030:            if (window->numer == GLFW_DONT_CARE ||
    %%%%%: 1030-block  0
branch  0 never executed
branch  1 never executed
    #####: 1031:                window->denom == GLFW_DONT_CARE)
    %%%%%: 1031-block  0
branch  0 never executed
branch  1 never executed
        -: 1032:            {
        -: 1033:                break;
        -: 1034:            }
        -: 1035:
    #####: 1036:            applyAspectRatio(window, (int) wParam, (RECT*) lParam);
    %%%%%: 1036-block  0
call    0 never executed
    #####: 1037:            return TRUE;
        -: 1038:        }
        -: 1039:
        1: 1040:        case WM_GETMINMAXINFO:
        -: 1041:        {
        -: 1042:            int xoff, yoff;
        1: 1043:            UINT dpi = USER_DEFAULT_SCREEN_DPI;
        1: 1044:            MINMAXINFO* mmi = (MINMAXINFO*) lParam;
        -: 1045:
        1: 1046:            if (window->monitor)
        1: 1046-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1047:                break;
    %%%%%: 1047-block  0
        -: 1048:
        1: 1049:            if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
        1: 1049-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 1050:                dpi = GetDpiForWindow(window->win32.handle);
        1: 1050-block  0
call    0 returned 1
        -: 1051:
        1: 1052:            getFullWindowSize(getWindowStyle(window), getWindowExStyle(window),
        1: 1052-block  0
call    0 returned 1
call    1 returned 1
call    2 returned 1
        -: 1053:                              0, 0, &xoff, &yoff, dpi);
        -: 1054:
       1*: 1055:            if (window->minwidth != GLFW_DONT_CARE &&
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1056:                window->minheight != GLFW_DONT_CARE)
    %%%%%: 1056-block  0
branch  0 never executed
branch  1 never executed
        -: 1057:            {
    #####: 1058:                mmi->ptMinTrackSize.x = window->minwidth + xoff;
    #####: 1059:                mmi->ptMinTrackSize.y = window->minheight + yoff;
    %%%%%: 1059-block  0
        -: 1060:            }
        -: 1061:
       1*: 1062:            if (window->maxwidth != GLFW_DONT_CARE &&
        1: 1062-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1063:                window->maxheight != GLFW_DONT_CARE)
    %%%%%: 1063-block  0
branch  0 never executed
branch  1 never executed
        -: 1064:            {
    #####: 1065:                mmi->ptMaxTrackSize.x = window->maxwidth + xoff;
    #####: 1066:                mmi->ptMaxTrackSize.y = window->maxheight + yoff;
    %%%%%: 1066-block  0
        -: 1067:            }
        -: 1068:
        1: 1069:            if (!window->decorated)
        1: 1069-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1070:            {
        -: 1071:                MONITORINFO mi;
    #####: 1072:                const HMONITOR mh = MonitorFromWindow(window->win32.handle,
    %%%%%: 1072-block  0
call    0 never executed
        -: 1073:                                                      MONITOR_DEFAULTTONEAREST);
        -: 1074:
    #####: 1075:                ZeroMemory(&mi, sizeof(mi));
    #####: 1076:                mi.cbSize = sizeof(mi);
    #####: 1077:                GetMonitorInfo(mh, &mi);
call    0 never executed
        -: 1078:
    #####: 1079:                mmi->ptMaxPosition.x = mi.rcWork.left - mi.rcMonitor.left;
    #####: 1080:                mmi->ptMaxPosition.y = mi.rcWork.top - mi.rcMonitor.top;
    #####: 1081:                mmi->ptMaxSize.x = mi.rcWork.right - mi.rcWork.left;
    #####: 1082:                mmi->ptMaxSize.y = mi.rcWork.bottom - mi.rcWork.top;
        -: 1083:            }
        -: 1084:
        1: 1085:            return 0;
        1: 1085-block  0
        -: 1086:        }
        -: 1087:
        2: 1088:        case WM_PAINT:
        -: 1089:        {
        2: 1090:            _glfwInputWindowDamage(window);
        2: 1090-block  0
call    0 returned 2
        2: 1091:            break;
        -: 1092:        }
        -: 1093:
        3: 1094:        case WM_ERASEBKGND:
        -: 1095:        {
        3: 1096:            return TRUE;
        3: 1096-block  0
        -: 1097:        }
        -: 1098:
        6: 1099:        case WM_NCACTIVATE:
        -: 1100:        case WM_NCPAINT:
        -: 1101:        {
        -: 1102:            // Prevent title bar from being drawn after restoring a minimized
        -: 1103:            // undecorated window
        6: 1104:            if (!window->decorated)
        6: 1104-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 1105:                return TRUE;
    %%%%%: 1105-block  0
        -: 1106:
        6: 1107:            break;
        6: 1107-block  0
        -: 1108:        }
        -: 1109:
    #####: 1110:        case WM_DWMCOMPOSITIONCHANGED:
        -: 1111:        case WM_DWMCOLORIZATIONCOLORCHANGED:
        -: 1112:        {
    #####: 1113:            if (window->win32.transparent)
    %%%%%: 1113-block  0
branch  0 never executed
branch  1 never executed
    #####: 1114:                updateFramebufferTransparency(window);
    %%%%%: 1114-block  0
call    0 never executed
    #####: 1115:            return 0;
    %%%%%: 1115-block  0
        -: 1116:        }
        -: 1117:
    #####: 1118:        case WM_GETDPISCALEDSIZE:
        -: 1119:        {
    #####: 1120:            if (window->win32.scaleToMonitor)
    %%%%%: 1120-block  0
branch  0 never executed
branch  1 never executed
    #####: 1121:                break;
    %%%%%: 1121-block  0
        -: 1122:
        -: 1123:            // Adjust the window size to keep the content area size constant
    #####: 1124:            if (_glfwIsWindows10CreatorsUpdateOrGreaterWin32())
    %%%%%: 1124-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1125:            {
    #####: 1126:                RECT source = {0}, target = {0};
    #####: 1127:                SIZE* size = (SIZE*) lParam;
        -: 1128:
    #####: 1129:                AdjustWindowRectExForDpi(&source, getWindowStyle(window),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1130:                                         FALSE, getWindowExStyle(window),
    #####: 1131:                                         GetDpiForWindow(window->win32.handle));
    %%%%%: 1131-block  0
call    0 never executed
    #####: 1132:                AdjustWindowRectExForDpi(&target, getWindowStyle(window),
call    0 never executed
call    1 never executed
        -: 1133:                                         FALSE, getWindowExStyle(window),
    #####: 1134:                                         LOWORD(wParam));
call    0 never executed
        -: 1135:
    #####: 1136:                size->cx += (target.right - target.left) -
    #####: 1137:                            (source.right - source.left);
    #####: 1138:                size->cy += (target.bottom - target.top) -
    #####: 1139:                            (source.bottom - source.top);
    #####: 1140:                return TRUE;
        -: 1141:            }
        -: 1142:
    #####: 1143:            break;
    %%%%%: 1143-block  0
        -: 1144:        }
        -: 1145:
    #####: 1146:        case WM_DPICHANGED:
        -: 1147:        {
    #####: 1148:            const float xscale = HIWORD(wParam) / (float) USER_DEFAULT_SCREEN_DPI;
    #####: 1149:            const float yscale = LOWORD(wParam) / (float) USER_DEFAULT_SCREEN_DPI;
        -: 1150:
        -: 1151:            // Resize windowed mode windows that either permit rescaling or that
        -: 1152:            // need it to compensate for non-client area scaling
    #####: 1153:            if (!window->monitor &&
    %%%%%: 1153-block  0
branch  0 never executed
branch  1 never executed
    #####: 1154:                (window->win32.scaleToMonitor ||
    %%%%%: 1154-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1155:                 _glfwIsWindows10CreatorsUpdateOrGreaterWin32()))
    %%%%%: 1155-block  0
call    0 never executed
        -: 1156:            {
    #####: 1157:                RECT* suggested = (RECT*) lParam;
    #####: 1158:                SetWindowPos(window->win32.handle, HWND_TOP,
    #####: 1159:                             suggested->left,
    #####: 1160:                             suggested->top,
    #####: 1161:                             suggested->right - suggested->left,
    #####: 1162:                             suggested->bottom - suggested->top,
    %%%%%: 1162-block  0
call    0 never executed
        -: 1163:                             SWP_NOACTIVATE | SWP_NOZORDER);
        -: 1164:            }
        -: 1165:
    #####: 1166:            _glfwInputWindowContentScale(window, xscale, yscale);
    %%%%%: 1166-block  0
call    0 never executed
    #####: 1167:            break;
        -: 1168:        }
        -: 1169:
       22: 1170:        case WM_SETCURSOR:
        -: 1171:        {
       22: 1172:            if (LOWORD(lParam) == HTCLIENT)
       22: 1172-block  0
branch  0 taken 16 (fallthrough)
branch  1 taken 6
        -: 1173:            {
       16: 1174:                updateCursorImage(window);
       16: 1174-block  0
call    0 returned 16
       16: 1175:                return TRUE;
        -: 1176:            }
        -: 1177:
        6: 1178:            break;
        6: 1178-block  0
        -: 1179:        }
        -: 1180:
    #####: 1181:        case WM_DROPFILES:
        -: 1182:        {
    #####: 1183:            HDROP drop = (HDROP) wParam;
        -: 1184:            POINT pt;
        -: 1185:            int i;
        -: 1186:
    #####: 1187:            const int count = DragQueryFileW(drop, 0xffffffff, NULL, 0);
    %%%%%: 1187-block  0
call    0 never executed
    #####: 1188:            char** paths = calloc(count, sizeof(char*));
        -: 1189:
        -: 1190:            // Move the mouse to the position of the drop
    #####: 1191:            DragQueryPoint(drop, &pt);
call    0 never executed
    #####: 1192:            _glfwInputCursorPos(window, pt.x, pt.y);
call    0 never executed
        -: 1193:
    #####: 1194:            for (i = 0;  i < count;  i++)
    %%%%%: 1194-block  0
branch  0 never executed
branch  1 never executed
        -: 1195:            {
    #####: 1196:                const UINT length = DragQueryFileW(drop, i, NULL, 0);
    %%%%%: 1196-block  0
call    0 never executed
    #####: 1197:                WCHAR* buffer = calloc((size_t) length + 1, sizeof(WCHAR));
        -: 1198:
    #####: 1199:                DragQueryFileW(drop, i, buffer, length + 1);
call    0 never executed
    #####: 1200:                paths[i] = _glfwCreateUTF8FromWideStringWin32(buffer);
call    0 never executed
        -: 1201:
    #####: 1202:                free(buffer);
        -: 1203:            }
        -: 1204:
    #####: 1205:            _glfwInputDrop(window, count, (const char**) paths);
    %%%%%: 1205-block  0
call    0 never executed
        -: 1206:
    #####: 1207:            for (i = 0;  i < count;  i++)
    %%%%%: 1207-block  0
branch  0 never executed
branch  1 never executed
    #####: 1208:                free(paths[i]);
    %%%%%: 1208-block  0
    #####: 1209:            free(paths);
        -: 1210:
    #####: 1211:            DragFinish(drop);
    %%%%%: 1211-block  0
call    0 never executed
    #####: 1212:            return 0;
        -: 1213:        }
        -: 1214:    }
        -: 1215:
      85*: 1216:    return DefWindowProcW(hWnd, uMsg, wParam, lParam);
    %%%%%: 1216-block  0
    %%%%%: 1216-block  1
       85: 1216-block  2
call    0 returned 85
        -: 1217:}
        -: 1218:
        -: 1219:// Creates the GLFW window
        -: 1220://
function createNativeWindow called 1 returned 100% blocks executed 73%
        1: 1221:static int createNativeWindow(_GLFWwindow* window,
        -: 1222:                              const _GLFWwndconfig* wndconfig,
        -: 1223:                              const _GLFWfbconfig* fbconfig)
        -: 1224:{
        -: 1225:    int xpos, ypos, fullWidth, fullHeight;
        -: 1226:    WCHAR* wideTitle;
        1: 1227:    DWORD style = getWindowStyle(window);
        1: 1227-block  0
call    0 returned 1
        1: 1228:    DWORD exStyle = getWindowExStyle(window);
call    0 returned 1
        -: 1229:
        1: 1230:    if (window->monitor)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1231:    {
        -: 1232:        GLFWvidmode mode;
        -: 1233:
        -: 1234:        // NOTE: This window placement is temporary and approximate, as the
        -: 1235:        //       correct position and size cannot be known until the monitor
        -: 1236:        //       video mode has been picked in _glfwSetVideoModeWin32
    #####: 1237:        _glfwPlatformGetMonitorPos(window->monitor, &xpos, &ypos);
    %%%%%: 1237-block  0
call    0 never executed
    #####: 1238:        _glfwPlatformGetVideoMode(window->monitor, &mode);
call    0 never executed
    #####: 1239:        fullWidth  = mode.width;
    #####: 1240:        fullHeight = mode.height;
        -: 1241:    }
        -: 1242:    else
        -: 1243:    {
        1: 1244:        xpos = CW_USEDEFAULT;
        1: 1245:        ypos = CW_USEDEFAULT;
        -: 1246:
        1: 1247:        window->win32.maximized = wndconfig->maximized;
        1: 1248:        if (wndconfig->maximized)
        1: 1248-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1249:            style |= WS_MAXIMIZE;
    %%%%%: 1249-block  0
        -: 1250:
        1: 1251:        getFullWindowSize(style, exStyle,
        1: 1251-block  0
call    0 returned 1
        -: 1252:                          wndconfig->width, wndconfig->height,
        -: 1253:                          &fullWidth, &fullHeight,
        -: 1254:                          USER_DEFAULT_SCREEN_DPI);
        -: 1255:    }
        -: 1256:
        1: 1257:    wideTitle = _glfwCreateWideStringFromUTF8Win32(wndconfig->title);
        1: 1257-block  0
call    0 returned 1
        1: 1258:    if (!wideTitle)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1259:        return GLFW_FALSE;
    %%%%%: 1259-block  0
        -: 1260:
        1: 1261:    window->win32.handle = CreateWindowExW(exStyle,
        1: 1261-block  0
call    0 returned 1
call    1 returned 1
        -: 1262:                                           _GLFW_WNDCLASSNAME,
        -: 1263:                                           wideTitle,
        -: 1264:                                           style,
        -: 1265:                                           xpos, ypos,
        -: 1266:                                           fullWidth, fullHeight,
        -: 1267:                                           NULL, // No parent window
        -: 1268:                                           NULL, // No window menu
        -: 1269:                                           GetModuleHandleW(NULL),
        -: 1270:                                           (LPVOID) wndconfig);
        -: 1271:
        1: 1272:    free(wideTitle);
        -: 1273:
        1: 1274:    if (!window->win32.handle)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1275:    {
    #####: 1276:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 1276-block  0
call    0 never executed
        -: 1277:                             "Win32: Failed to create window");
    #####: 1278:        return GLFW_FALSE;
        -: 1279:    }
        -: 1280:
        1: 1281:    SetPropW(window->win32.handle, L"GLFW", window);
        1: 1281-block  0
call    0 returned 1
        -: 1282:
        1: 1283:    if (IsWindows7OrGreater())
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        -: 1284:    {
        1: 1285:        ChangeWindowMessageFilterEx(window->win32.handle,
        1: 1285-block  0
call    0 returned 1
        -: 1286:                                    WM_DROPFILES, MSGFLT_ALLOW, NULL);
        1: 1287:        ChangeWindowMessageFilterEx(window->win32.handle,
call    0 returned 1
        -: 1288:                                    WM_COPYDATA, MSGFLT_ALLOW, NULL);
        1: 1289:        ChangeWindowMessageFilterEx(window->win32.handle,
call    0 returned 1
        -: 1290:                                    WM_COPYGLOBALDATA, MSGFLT_ALLOW, NULL);
        -: 1291:    }
        -: 1292:
        1: 1293:    window->win32.scaleToMonitor = wndconfig->scaleToMonitor;
        1: 1294:    window->win32.keymenu = wndconfig->win32.keymenu;
        -: 1295:
        -: 1296:    // Adjust window rect to account for DPI scaling of the window frame and
        -: 1297:    // (if enabled) DPI scaling of the content area
        -: 1298:    // This cannot be done until we know what monitor the window was placed on
        1: 1299:    if (!window->monitor)
        1: 1299-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1300:    {
        1: 1301:        RECT rect = { 0, 0, wndconfig->width, wndconfig->height };
        1: 1302:        WINDOWPLACEMENT wp = { sizeof(wp) };
        -: 1303:
        1: 1304:        if (wndconfig->scaleToMonitor)
        1: 1304-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1305:        {
        -: 1306:            float xscale, yscale;
    #####: 1307:            _glfwPlatformGetWindowContentScale(window, &xscale, &yscale);
    %%%%%: 1307-block  0
call    0 never executed
    #####: 1308:            rect.right = (int) (rect.right * xscale);
    #####: 1309:            rect.bottom = (int) (rect.bottom * yscale);
        -: 1310:        }
        -: 1311:
        1: 1312:        ClientToScreen(window->win32.handle, (POINT*) &rect.left);
        1: 1312-block  0
call    0 returned 1
        1: 1313:        ClientToScreen(window->win32.handle, (POINT*) &rect.right);
call    0 returned 1
        -: 1314:
        1: 1315:        if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        -: 1316:        {
        1: 1317:            AdjustWindowRectExForDpi(&rect, style, FALSE, exStyle,
call    0 returned 1
        1: 1318:                                     GetDpiForWindow(window->win32.handle));
        1: 1318-block  0
call    0 returned 1
        -: 1319:        }
        -: 1320:        else
    #####: 1321:            AdjustWindowRectEx(&rect, style, FALSE, exStyle);
    %%%%%: 1321-block  0
call    0 never executed
        -: 1322:
        -: 1323:        // Only update the restored window rect as the window may be maximized
        1: 1324:        GetWindowPlacement(window->win32.handle, &wp);
        1: 1324-block  0
call    0 returned 1
        1: 1325:        wp.rcNormalPosition = rect;
        1: 1326:        wp.showCmd = SW_HIDE;
        1: 1327:        SetWindowPlacement(window->win32.handle, &wp);
call    0 returned 1
        -: 1328:    }
        -: 1329:
        1: 1330:    DragAcceptFiles(window->win32.handle, TRUE);
        1: 1330-block  0
call    0 returned 1
        -: 1331:
        1: 1332:    if (fbconfig->transparent)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1333:    {
    #####: 1334:        updateFramebufferTransparency(window);
    %%%%%: 1334-block  0
call    0 never executed
    #####: 1335:        window->win32.transparent = GLFW_TRUE;
        -: 1336:    }
        -: 1337:
        1: 1338:    _glfwPlatformGetWindowSize(window, &window->win32.width, &window->win32.height);
        1: 1338-block  0
call    0 returned 1
        -: 1339:
        1: 1340:    return GLFW_TRUE;
        -: 1341:}
        -: 1342:
        -: 1343:
        -: 1344://////////////////////////////////////////////////////////////////////////
        -: 1345://////                       GLFW internal API                      //////
        -: 1346://////////////////////////////////////////////////////////////////////////
        -: 1347:
        -: 1348:// Registers the GLFW window class
        -: 1349://
function _glfwRegisterWindowClassWin32 called 1 returned 100% blocks executed 86%
        1: 1350:GLFWbool _glfwRegisterWindowClassWin32(void)
        -: 1351:{
        -: 1352:    WNDCLASSEXW wc;
        -: 1353:
        1: 1354:    ZeroMemory(&wc, sizeof(wc));
        1: 1355:    wc.cbSize        = sizeof(wc);
        1: 1356:    wc.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        1: 1357:    wc.lpfnWndProc   = (WNDPROC) windowProc;
        1: 1358:    wc.hInstance     = GetModuleHandleW(NULL);
        1: 1358-block  0
call    0 returned 1
        1: 1359:    wc.hCursor       = LoadCursorW(NULL, IDC_ARROW);
call    0 returned 1
        1: 1360:    wc.lpszClassName = _GLFW_WNDCLASSNAME;
        -: 1361:
        -: 1362:    // Load user-provided icon if available
        1: 1363:    wc.hIcon = LoadImageW(GetModuleHandleW(NULL),
call    0 returned 1
call    1 returned 1
        -: 1364:                          L"GLFW_ICON", IMAGE_ICON,
        -: 1365:                          0, 0, LR_DEFAULTSIZE | LR_SHARED);
        1: 1366:    if (!wc.hIcon)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1367:    {
        -: 1368:        // No user-provided icon found, load default icon
        1: 1369:        wc.hIcon = LoadImageW(NULL,
        1: 1369-block  0
call    0 returned 1
        -: 1370:                              IDI_APPLICATION, IMAGE_ICON,
        -: 1371:                              0, 0, LR_DEFAULTSIZE | LR_SHARED);
        -: 1372:    }
        -: 1373:
        1: 1374:    if (!RegisterClassExW(&wc))
        1: 1374-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -: 1375:    {
    #####: 1376:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 1376-block  0
call    0 never executed
        -: 1377:                             "Win32: Failed to register window class");
    #####: 1378:        return GLFW_FALSE;
        -: 1379:    }
        -: 1380:
        1: 1381:    return GLFW_TRUE;
        1: 1381-block  0
        -: 1382:}
        -: 1383:
        -: 1384:// Unregisters the GLFW window class
        -: 1385://
function _glfwUnregisterWindowClassWin32 called 1 returned 100% blocks executed 100%
        1: 1386:void _glfwUnregisterWindowClassWin32(void)
        -: 1387:{
        1: 1388:    UnregisterClassW(_GLFW_WNDCLASSNAME, GetModuleHandleW(NULL));
        1: 1388-block  0
call    0 returned 1
call    1 returned 1
        1: 1389:}
        -: 1390:
        -: 1391:
        -: 1392://////////////////////////////////////////////////////////////////////////
        -: 1393://////                       GLFW platform API                      //////
        -: 1394://////////////////////////////////////////////////////////////////////////
        -: 1395:
function _glfwPlatformCreateWindow called 1 returned 100% blocks executed 34%
        1: 1396:int _glfwPlatformCreateWindow(_GLFWwindow* window,
        -: 1397:                              const _GLFWwndconfig* wndconfig,
        -: 1398:                              const _GLFWctxconfig* ctxconfig,
        -: 1399:                              const _GLFWfbconfig* fbconfig)
        -: 1400:{
        1: 1401:    if (!createNativeWindow(window, wndconfig, fbconfig))
        1: 1401-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1402:        return GLFW_FALSE;
    %%%%%: 1402-block  0
        -: 1403:
        1: 1404:    if (ctxconfig->client != GLFW_NO_API)
        1: 1404-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1405:    {
        1: 1406:        if (ctxconfig->source == GLFW_NATIVE_CONTEXT_API)
        1: 1406-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1407:        {
        1: 1408:            if (!_glfwInitWGL())
        1: 1408-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1409:                return GLFW_FALSE;
    %%%%%: 1409-block  0
        1: 1410:            if (!_glfwCreateContextWGL(window, ctxconfig, fbconfig))
        1: 1410-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1411:                return GLFW_FALSE;
    %%%%%: 1411-block  0
        -: 1412:        }
    #####: 1413:        else if (ctxconfig->source == GLFW_EGL_CONTEXT_API)
    %%%%%: 1413-block  0
branch  0 never executed
branch  1 never executed
        -: 1414:        {
    #####: 1415:            if (!_glfwInitEGL())
    %%%%%: 1415-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1416:                return GLFW_FALSE;
    %%%%%: 1416-block  0
    #####: 1417:            if (!_glfwCreateContextEGL(window, ctxconfig, fbconfig))
    %%%%%: 1417-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1418:                return GLFW_FALSE;
    %%%%%: 1418-block  0
        -: 1419:        }
    #####: 1420:        else if (ctxconfig->source == GLFW_OSMESA_CONTEXT_API)
    %%%%%: 1420-block  0
branch  0 never executed
branch  1 never executed
        -: 1421:        {
    #####: 1422:            if (!_glfwInitOSMesa())
    %%%%%: 1422-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1423:                return GLFW_FALSE;
    %%%%%: 1423-block  0
    #####: 1424:            if (!_glfwCreateContextOSMesa(window, ctxconfig, fbconfig))
    %%%%%: 1424-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1425:                return GLFW_FALSE;
    %%%%%: 1425-block  0
        -: 1426:        }
        -: 1427:    }
        -: 1428:
        1: 1429:    if (window->monitor)
        1: 1429-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1430:    {
    #####: 1431:        _glfwPlatformShowWindow(window);
    %%%%%: 1431-block  0
call    0 never executed
    #####: 1432:        _glfwPlatformFocusWindow(window);
call    0 never executed
    #####: 1433:        acquireMonitor(window);
call    0 never executed
    #####: 1434:        fitToMonitor(window);
call    0 never executed
        -: 1435:    }
        -: 1436:
        1: 1437:    return GLFW_TRUE;
        1: 1437-block  0
        -: 1438:}
        -: 1439:
function _glfwPlatformDestroyWindow called 1 returned 100% blocks executed 73%
        1: 1440:void _glfwPlatformDestroyWindow(_GLFWwindow* window)
        -: 1441:{
        1: 1442:    if (window->monitor)
        1: 1442-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1443:        releaseMonitor(window);
    %%%%%: 1443-block  0
call    0 never executed
        -: 1444:
        1: 1445:    if (window->context.destroy)
        1: 1445-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1446:        window->context.destroy(window);
        1: 1446-block  0
call    0 returned 1
        -: 1447:
        1: 1448:    if (_glfw.win32.disabledCursorWindow == window)
        1: 1448-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1449:        _glfw.win32.disabledCursorWindow = NULL;
    %%%%%: 1449-block  0
        -: 1450:
        1: 1451:    if (window->win32.handle)
        1: 1451-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1452:    {
        1: 1453:        RemovePropW(window->win32.handle, L"GLFW");
        1: 1453-block  0
call    0 returned 1
        1: 1454:        DestroyWindow(window->win32.handle);
call    0 returned 1
        1: 1455:        window->win32.handle = NULL;
        -: 1456:    }
        -: 1457:
        1: 1458:    if (window->win32.bigIcon)
        1: 1458-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1459:        DestroyIcon(window->win32.bigIcon);
    %%%%%: 1459-block  0
call    0 never executed
        -: 1460:
        1: 1461:    if (window->win32.smallIcon)
        1: 1461-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1462:        DestroyIcon(window->win32.smallIcon);
    %%%%%: 1462-block  0
call    0 never executed
        1: 1463:}
        -: 1464:
function _glfwPlatformSetWindowTitle called 0 returned 0% blocks executed 0%
    #####: 1465:void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
        -: 1466:{
    #####: 1467:    WCHAR* wideTitle = _glfwCreateWideStringFromUTF8Win32(title);
    %%%%%: 1467-block  0
call    0 never executed
    #####: 1468:    if (!wideTitle)
branch  0 never executed
branch  1 never executed
    #####: 1469:        return;
    %%%%%: 1469-block  0
        -: 1470:
    #####: 1471:    SetWindowTextW(window->win32.handle, wideTitle);
    %%%%%: 1471-block  0
call    0 never executed
    #####: 1472:    free(wideTitle);
        -: 1473:}
        -: 1474:
function _glfwPlatformSetWindowIcon called 0 returned 0% blocks executed 0%
    #####: 1475:void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
        -: 1476:                                int count, const GLFWimage* images)
        -: 1477:{
    #####: 1478:    HICON bigIcon = NULL, smallIcon = NULL;
        -: 1479:
    #####: 1480:    if (count)
    %%%%%: 1480-block  0
branch  0 never executed
branch  1 never executed
        -: 1481:    {
    #####: 1482:        const GLFWimage* bigImage = chooseImage(count, images,
    %%%%%: 1482-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1483:                                                GetSystemMetrics(SM_CXICON),
        -: 1484:                                                GetSystemMetrics(SM_CYICON));
    #####: 1485:        const GLFWimage* smallImage = chooseImage(count, images,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1486:                                                  GetSystemMetrics(SM_CXSMICON),
        -: 1487:                                                  GetSystemMetrics(SM_CYSMICON));
        -: 1488:
    #####: 1489:        bigIcon = createIcon(bigImage, 0, 0, GLFW_TRUE);
call    0 never executed
    #####: 1490:        smallIcon = createIcon(smallImage, 0, 0, GLFW_TRUE);
call    0 never executed
        -: 1491:    }
        -: 1492:    else
        -: 1493:    {
    #####: 1494:        bigIcon = (HICON) GetClassLongPtrW(window->win32.handle, GCLP_HICON);
    %%%%%: 1494-block  0
call    0 never executed
    #####: 1495:        smallIcon = (HICON) GetClassLongPtrW(window->win32.handle, GCLP_HICONSM);
call    0 never executed
        -: 1496:    }
        -: 1497:
    #####: 1498:    SendMessage(window->win32.handle, WM_SETICON, ICON_BIG, (LPARAM) bigIcon);
    %%%%%: 1498-block  0
call    0 never executed
    #####: 1499:    SendMessage(window->win32.handle, WM_SETICON, ICON_SMALL, (LPARAM) smallIcon);
call    0 never executed
        -: 1500:
    #####: 1501:    if (window->win32.bigIcon)
branch  0 never executed
branch  1 never executed
    #####: 1502:        DestroyIcon(window->win32.bigIcon);
    %%%%%: 1502-block  0
call    0 never executed
        -: 1503:
    #####: 1504:    if (window->win32.smallIcon)
    %%%%%: 1504-block  0
branch  0 never executed
branch  1 never executed
    #####: 1505:        DestroyIcon(window->win32.smallIcon);
    %%%%%: 1505-block  0
call    0 never executed
        -: 1506:
    #####: 1507:    if (count)
    %%%%%: 1507-block  0
branch  0 never executed
branch  1 never executed
        -: 1508:    {
    #####: 1509:        window->win32.bigIcon = bigIcon;
    #####: 1510:        window->win32.smallIcon = smallIcon;
    %%%%%: 1510-block  0
        -: 1511:    }
    #####: 1512:}
        -: 1513:
function _glfwPlatformGetWindowPos called 0 returned 0% blocks executed 0%
    #####: 1514:void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
        -: 1515:{
    #####: 1516:    POINT pos = { 0, 0 };
    #####: 1517:    ClientToScreen(window->win32.handle, &pos);
    %%%%%: 1517-block  0
call    0 never executed
        -: 1518:
    #####: 1519:    if (xpos)
branch  0 never executed
branch  1 never executed
    #####: 1520:        *xpos = pos.x;
    %%%%%: 1520-block  0
    #####: 1521:    if (ypos)
    %%%%%: 1521-block  0
branch  0 never executed
branch  1 never executed
    #####: 1522:        *ypos = pos.y;
    %%%%%: 1522-block  0
    #####: 1523:}
        -: 1524:
function _glfwPlatformSetWindowPos called 1 returned 100% blocks executed 73%
        1: 1525:void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
        -: 1526:{
        1: 1527:    RECT rect = { xpos, ypos, xpos, ypos };
        -: 1528:
        1: 1529:    if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
        1: 1529-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        -: 1530:    {
        1: 1531:        AdjustWindowRectExForDpi(&rect, getWindowStyle(window),
call    0 returned 1
call    1 returned 1
call    2 returned 1
        -: 1532:                                 FALSE, getWindowExStyle(window),
        1: 1533:                                 GetDpiForWindow(window->win32.handle));
        1: 1533-block  0
call    0 returned 1
        -: 1534:    }
        -: 1535:    else
        -: 1536:    {
    #####: 1537:        AdjustWindowRectEx(&rect, getWindowStyle(window),
    %%%%%: 1537-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1538:                           FALSE, getWindowExStyle(window));
        -: 1539:    }
        -: 1540:
        1: 1541:    SetWindowPos(window->win32.handle, NULL, rect.left, rect.top, 0, 0,
        1: 1541-block  0
call    0 returned 1
        -: 1542:                 SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
        1: 1543:}
        -: 1544:
function _glfwPlatformGetWindowSize called 1 returned 100% blocks executed 100%
        1: 1545:void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
        -: 1546:{
        -: 1547:    RECT area;
        1: 1548:    GetClientRect(window->win32.handle, &area);
        1: 1548-block  0
call    0 returned 1
        -: 1549:
        1: 1550:    if (width)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1551:        *width = area.right;
        1: 1551-block  0
        1: 1552:    if (height)
        1: 1552-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1553:        *height = area.bottom;
        1: 1553-block  0
        1: 1554:}
        -: 1555:
function _glfwPlatformSetWindowSize called 0 returned 0% blocks executed 0%
    #####: 1556:void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
        -: 1557:{
    #####: 1558:    if (window->monitor)
    %%%%%: 1558-block  0
branch  0 never executed
branch  1 never executed
        -: 1559:    {
    #####: 1560:        if (window->monitor->window == window)
    %%%%%: 1560-block  0
branch  0 never executed
branch  1 never executed
        -: 1561:        {
    #####: 1562:            acquireMonitor(window);
    %%%%%: 1562-block  0
call    0 never executed
    #####: 1563:            fitToMonitor(window);
call    0 never executed
        -: 1564:        }
        -: 1565:    }
        -: 1566:    else
        -: 1567:    {
    #####: 1568:        RECT rect = { 0, 0, width, height };
        -: 1569:
    #####: 1570:        if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
    %%%%%: 1570-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1571:        {
    #####: 1572:            AdjustWindowRectExForDpi(&rect, getWindowStyle(window),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1573:                                     FALSE, getWindowExStyle(window),
    #####: 1574:                                     GetDpiForWindow(window->win32.handle));
    %%%%%: 1574-block  0
call    0 never executed
        -: 1575:        }
        -: 1576:        else
        -: 1577:        {
    #####: 1578:            AdjustWindowRectEx(&rect, getWindowStyle(window),
    %%%%%: 1578-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1579:                               FALSE, getWindowExStyle(window));
        -: 1580:        }
        -: 1581:
    #####: 1582:        SetWindowPos(window->win32.handle, HWND_TOP,
    #####: 1583:                     0, 0, rect.right - rect.left, rect.bottom - rect.top,
    %%%%%: 1583-block  0
call    0 never executed
        -: 1584:                     SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOMOVE | SWP_NOZORDER);
        -: 1585:    }
    #####: 1586:}
        -: 1587:
function _glfwPlatformSetWindowSizeLimits called 0 returned 0% blocks executed 0%
    #####: 1588:void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
        -: 1589:                                      int minwidth, int minheight,
        -: 1590:                                      int maxwidth, int maxheight)
        -: 1591:{
        -: 1592:    RECT area;
        -: 1593:
    #####: 1594:    if ((minwidth == GLFW_DONT_CARE || minheight == GLFW_DONT_CARE) &&
    %%%%%: 1594-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1594-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1594-block  2
branch  4 never executed
branch  5 never executed
    #####: 1595:        (maxwidth == GLFW_DONT_CARE || maxheight == GLFW_DONT_CARE))
    %%%%%: 1595-block  0
branch  0 never executed
branch  1 never executed
        -: 1596:    {
    #####: 1597:        return;
    %%%%%: 1597-block  0
        -: 1598:    }
        -: 1599:
    #####: 1600:    GetWindowRect(window->win32.handle, &area);
    %%%%%: 1600-block  0
call    0 never executed
    #####: 1601:    MoveWindow(window->win32.handle,
    #####: 1602:               area.left, area.top,
    #####: 1603:               area.right - area.left,
    #####: 1604:               area.bottom - area.top, TRUE);
call    0 never executed
        -: 1605:}
        -: 1606:
function _glfwPlatformSetWindowAspectRatio called 0 returned 0% blocks executed 0%
    #####: 1607:void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int numer, int denom)
        -: 1608:{
        -: 1609:    RECT area;
        -: 1610:
    #####: 1611:    if (numer == GLFW_DONT_CARE || denom == GLFW_DONT_CARE)
    %%%%%: 1611-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1611-block  1
branch  2 never executed
branch  3 never executed
    #####: 1612:        return;
    %%%%%: 1612-block  0
        -: 1613:
    #####: 1614:    GetWindowRect(window->win32.handle, &area);
    %%%%%: 1614-block  0
call    0 never executed
    #####: 1615:    applyAspectRatio(window, WMSZ_BOTTOMRIGHT, &area);
call    0 never executed
    #####: 1616:    MoveWindow(window->win32.handle,
    #####: 1617:               area.left, area.top,
    #####: 1618:               area.right - area.left,
    #####: 1619:               area.bottom - area.top, TRUE);
call    0 never executed
        -: 1620:}
        -: 1621:
function _glfwPlatformGetFramebufferSize called 0 returned 0% blocks executed 0%
    #####: 1622:void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* height)
        -: 1623:{
    #####: 1624:    _glfwPlatformGetWindowSize(window, width, height);
    %%%%%: 1624-block  0
call    0 never executed
    #####: 1625:}
        -: 1626:
function _glfwPlatformGetWindowFrameSize called 0 returned 0% blocks executed 0%
    #####: 1627:void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
        -: 1628:                                     int* left, int* top,
        -: 1629:                                     int* right, int* bottom)
        -: 1630:{
        -: 1631:    RECT rect;
        -: 1632:    int width, height;
        -: 1633:
    #####: 1634:    _glfwPlatformGetWindowSize(window, &width, &height);
    %%%%%: 1634-block  0
call    0 never executed
    #####: 1635:    SetRect(&rect, 0, 0, width, height);
call    0 never executed
        -: 1636:
    #####: 1637:    if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1638:    {
    #####: 1639:        AdjustWindowRectExForDpi(&rect, getWindowStyle(window),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1640:                                 FALSE, getWindowExStyle(window),
    #####: 1641:                                 GetDpiForWindow(window->win32.handle));
    %%%%%: 1641-block  0
call    0 never executed
        -: 1642:    }
        -: 1643:    else
        -: 1644:    {
    #####: 1645:        AdjustWindowRectEx(&rect, getWindowStyle(window),
    %%%%%: 1645-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1646:                           FALSE, getWindowExStyle(window));
        -: 1647:    }
        -: 1648:
    #####: 1649:    if (left)
    %%%%%: 1649-block  0
branch  0 never executed
branch  1 never executed
    #####: 1650:        *left = -rect.left;
    %%%%%: 1650-block  0
    #####: 1651:    if (top)
    %%%%%: 1651-block  0
branch  0 never executed
branch  1 never executed
    #####: 1652:        *top = -rect.top;
    %%%%%: 1652-block  0
    #####: 1653:    if (right)
    %%%%%: 1653-block  0
branch  0 never executed
branch  1 never executed
    #####: 1654:        *right = rect.right - width;
    %%%%%: 1654-block  0
    #####: 1655:    if (bottom)
    %%%%%: 1655-block  0
branch  0 never executed
branch  1 never executed
    #####: 1656:        *bottom = rect.bottom - height;
    %%%%%: 1656-block  0
    #####: 1657:}
        -: 1658:
function _glfwPlatformGetWindowContentScale called 0 returned 0% blocks executed 0%
    #####: 1659:void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
        -: 1660:                                        float* xscale, float* yscale)
        -: 1661:{
    #####: 1662:    const HANDLE handle = MonitorFromWindow(window->win32.handle,
    %%%%%: 1662-block  0
call    0 never executed
        -: 1663:                                            MONITOR_DEFAULTTONEAREST);
    #####: 1664:    _glfwGetMonitorContentScaleWin32(handle, xscale, yscale);
call    0 never executed
    #####: 1665:}
        -: 1666:
function _glfwPlatformIconifyWindow called 0 returned 0% blocks executed 0%
    #####: 1667:void _glfwPlatformIconifyWindow(_GLFWwindow* window)
        -: 1668:{
    #####: 1669:    ShowWindow(window->win32.handle, SW_MINIMIZE);
    %%%%%: 1669-block  0
call    0 never executed
    #####: 1670:}
        -: 1671:
function _glfwPlatformRestoreWindow called 0 returned 0% blocks executed 0%
    #####: 1672:void _glfwPlatformRestoreWindow(_GLFWwindow* window)
        -: 1673:{
    #####: 1674:    ShowWindow(window->win32.handle, SW_RESTORE);
    %%%%%: 1674-block  0
call    0 never executed
    #####: 1675:}
        -: 1676:
function _glfwPlatformMaximizeWindow called 0 returned 0% blocks executed 0%
    #####: 1677:void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
        -: 1678:{
    #####: 1679:    ShowWindow(window->win32.handle, SW_MAXIMIZE);
    %%%%%: 1679-block  0
call    0 never executed
    #####: 1680:}
        -: 1681:
function _glfwPlatformShowWindow called 1 returned 100% blocks executed 100%
        1: 1682:void _glfwPlatformShowWindow(_GLFWwindow* window)
        -: 1683:{
        1: 1684:    ShowWindow(window->win32.handle, SW_SHOWNA);
        1: 1684-block  0
call    0 returned 1
        1: 1685:}
        -: 1686:
function _glfwPlatformHideWindow called 0 returned 0% blocks executed 0%
    #####: 1687:void _glfwPlatformHideWindow(_GLFWwindow* window)
        -: 1688:{
    #####: 1689:    ShowWindow(window->win32.handle, SW_HIDE);
    %%%%%: 1689-block  0
call    0 never executed
    #####: 1690:}
        -: 1691:
function _glfwPlatformRequestWindowAttention called 0 returned 0% blocks executed 0%
    #####: 1692:void _glfwPlatformRequestWindowAttention(_GLFWwindow* window)
        -: 1693:{
    #####: 1694:    FlashWindow(window->win32.handle, TRUE);
    %%%%%: 1694-block  0
call    0 never executed
    #####: 1695:}
        -: 1696:
function _glfwPlatformFocusWindow called 1 returned 100% blocks executed 100%
        1: 1697:void _glfwPlatformFocusWindow(_GLFWwindow* window)
        -: 1698:{
        1: 1699:    BringWindowToTop(window->win32.handle);
        1: 1699-block  0
call    0 returned 1
        1: 1700:    SetForegroundWindow(window->win32.handle);
call    0 returned 1
        1: 1701:    SetFocus(window->win32.handle);
call    0 returned 1
        1: 1702:}
        -: 1703:
function _glfwPlatformSetWindowMonitor called 0 returned 0% blocks executed 0%
    #####: 1704:void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
        -: 1705:                                   _GLFWmonitor* monitor,
        -: 1706:                                   int xpos, int ypos,
        -: 1707:                                   int width, int height,
        -: 1708:                                   int refreshRate)
        -: 1709:{
    #####: 1710:    if (window->monitor == monitor)
    %%%%%: 1710-block  0
branch  0 never executed
branch  1 never executed
        -: 1711:    {
    #####: 1712:        if (monitor)
    %%%%%: 1712-block  0
branch  0 never executed
branch  1 never executed
        -: 1713:        {
    #####: 1714:            if (monitor->window == window)
    %%%%%: 1714-block  0
branch  0 never executed
branch  1 never executed
        -: 1715:            {
    #####: 1716:                acquireMonitor(window);
    %%%%%: 1716-block  0
call    0 never executed
    #####: 1717:                fitToMonitor(window);
call    0 never executed
        -: 1718:            }
        -: 1719:        }
        -: 1720:        else
        -: 1721:        {
    #####: 1722:            RECT rect = { xpos, ypos, xpos + width, ypos + height };
        -: 1723:
    #####: 1724:            if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
    %%%%%: 1724-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1725:            {
    #####: 1726:                AdjustWindowRectExForDpi(&rect, getWindowStyle(window),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1727:                                         FALSE, getWindowExStyle(window),
    #####: 1728:                                         GetDpiForWindow(window->win32.handle));
    %%%%%: 1728-block  0
call    0 never executed
        -: 1729:            }
        -: 1730:            else
        -: 1731:            {
    #####: 1732:                AdjustWindowRectEx(&rect, getWindowStyle(window),
    %%%%%: 1732-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1733:                                   FALSE, getWindowExStyle(window));
        -: 1734:            }
        -: 1735:
    #####: 1736:            SetWindowPos(window->win32.handle, HWND_TOP,
    #####: 1737:                         rect.left, rect.top,
    #####: 1738:                         rect.right - rect.left, rect.bottom - rect.top,
    %%%%%: 1738-block  0
call    0 never executed
        -: 1739:                         SWP_NOCOPYBITS | SWP_NOACTIVATE | SWP_NOZORDER);
        -: 1740:        }
        -: 1741:
    #####: 1742:        return;
    %%%%%: 1742-block  0
        -: 1743:    }
        -: 1744:
    #####: 1745:    if (window->monitor)
    %%%%%: 1745-block  0
branch  0 never executed
branch  1 never executed
    #####: 1746:        releaseMonitor(window);
    %%%%%: 1746-block  0
call    0 never executed
        -: 1747:
    #####: 1748:    _glfwInputWindowMonitor(window, monitor);
    %%%%%: 1748-block  0
call    0 never executed
        -: 1749:
    #####: 1750:    if (window->monitor)
branch  0 never executed
branch  1 never executed
        -: 1751:    {
    #####: 1752:        MONITORINFO mi = { sizeof(mi) };
    #####: 1753:        UINT flags = SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOCOPYBITS;
        -: 1754:
    #####: 1755:        if (window->decorated)
    %%%%%: 1755-block  0
branch  0 never executed
branch  1 never executed
        -: 1756:        {
    #####: 1757:            DWORD style = GetWindowLongW(window->win32.handle, GWL_STYLE);
    %%%%%: 1757-block  0
call    0 never executed
    #####: 1758:            style &= ~WS_OVERLAPPEDWINDOW;
    #####: 1759:            style |= getWindowStyle(window);
call    0 never executed
    #####: 1760:            SetWindowLongW(window->win32.handle, GWL_STYLE, style);
call    0 never executed
    #####: 1761:            flags |= SWP_FRAMECHANGED;
        -: 1762:        }
        -: 1763:
    #####: 1764:        acquireMonitor(window);
    %%%%%: 1764-block  0
call    0 never executed
        -: 1765:
    #####: 1766:        GetMonitorInfo(window->monitor->win32.handle, &mi);
call    0 never executed
    #####: 1767:        SetWindowPos(window->win32.handle, HWND_TOPMOST,
    #####: 1768:                     mi.rcMonitor.left,
    #####: 1769:                     mi.rcMonitor.top,
    #####: 1770:                     mi.rcMonitor.right - mi.rcMonitor.left,
    #####: 1771:                     mi.rcMonitor.bottom - mi.rcMonitor.top,
call    0 never executed
        -: 1772:                     flags);
        -: 1773:    }
        -: 1774:    else
        -: 1775:    {
        -: 1776:        HWND after;
    #####: 1777:        RECT rect = { xpos, ypos, xpos + width, ypos + height };
    #####: 1778:        DWORD style = GetWindowLongW(window->win32.handle, GWL_STYLE);
    %%%%%: 1778-block  0
call    0 never executed
    #####: 1779:        UINT flags = SWP_NOACTIVATE | SWP_NOCOPYBITS;
        -: 1780:
    #####: 1781:        if (window->decorated)
branch  0 never executed
branch  1 never executed
        -: 1782:        {
    #####: 1783:            style &= ~WS_POPUP;
    #####: 1784:            style |= getWindowStyle(window);
    %%%%%: 1784-block  0
call    0 never executed
    #####: 1785:            SetWindowLongW(window->win32.handle, GWL_STYLE, style);
call    0 never executed
        -: 1786:
    #####: 1787:            flags |= SWP_FRAMECHANGED;
        -: 1788:        }
        -: 1789:
    #####: 1790:        if (window->floating)
    %%%%%: 1790-block  0
branch  0 never executed
branch  1 never executed
    #####: 1791:            after = HWND_TOPMOST;
    %%%%%: 1791-block  0
        -: 1792:        else
    #####: 1793:            after = HWND_NOTOPMOST;
    %%%%%: 1793-block  0
        -: 1794:
    #####: 1795:        if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
    %%%%%: 1795-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1796:        {
    #####: 1797:            AdjustWindowRectExForDpi(&rect, getWindowStyle(window),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1798:                                     FALSE, getWindowExStyle(window),
    #####: 1799:                                     GetDpiForWindow(window->win32.handle));
    %%%%%: 1799-block  0
call    0 never executed
        -: 1800:        }
        -: 1801:        else
        -: 1802:        {
    #####: 1803:            AdjustWindowRectEx(&rect, getWindowStyle(window),
    %%%%%: 1803-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1804:                               FALSE, getWindowExStyle(window));
        -: 1805:        }
        -: 1806:
    #####: 1807:        SetWindowPos(window->win32.handle, after,
    #####: 1808:                     rect.left, rect.top,
    #####: 1809:                     rect.right - rect.left, rect.bottom - rect.top,
    %%%%%: 1809-block  0
call    0 never executed
        -: 1810:                     flags);
        -: 1811:    }
        -: 1812:}
        -: 1813:
function _glfwPlatformWindowFocused called 0 returned 0% blocks executed 0%
    #####: 1814:int _glfwPlatformWindowFocused(_GLFWwindow* window)
        -: 1815:{
    #####: 1816:    return window->win32.handle == GetActiveWindow();
    %%%%%: 1816-block  0
call    0 never executed
        -: 1817:}
        -: 1818:
function _glfwPlatformWindowIconified called 0 returned 0% blocks executed 0%
    #####: 1819:int _glfwPlatformWindowIconified(_GLFWwindow* window)
        -: 1820:{
    #####: 1821:    return IsIconic(window->win32.handle);
    %%%%%: 1821-block  0
call    0 never executed
        -: 1822:}
        -: 1823:
function _glfwPlatformWindowVisible called 0 returned 0% blocks executed 0%
    #####: 1824:int _glfwPlatformWindowVisible(_GLFWwindow* window)
        -: 1825:{
    #####: 1826:    return IsWindowVisible(window->win32.handle);
    %%%%%: 1826-block  0
call    0 never executed
        -: 1827:}
        -: 1828:
function _glfwPlatformWindowMaximized called 0 returned 0% blocks executed 0%
    #####: 1829:int _glfwPlatformWindowMaximized(_GLFWwindow* window)
        -: 1830:{
    #####: 1831:    return IsZoomed(window->win32.handle);
    %%%%%: 1831-block  0
call    0 never executed
        -: 1832:}
        -: 1833:
function _glfwPlatformWindowHovered called 0 returned 0% blocks executed 0%
    #####: 1834:int _glfwPlatformWindowHovered(_GLFWwindow* window)
        -: 1835:{
    #####: 1836:    return cursorInContentArea(window);
    %%%%%: 1836-block  0
call    0 never executed
        -: 1837:}
        -: 1838:
function _glfwPlatformFramebufferTransparent called 0 returned 0% blocks executed 0%
    #####: 1839:int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
        -: 1840:{
        -: 1841:    BOOL composition, opaque;
        -: 1842:    DWORD color;
        -: 1843:
    #####: 1844:    if (!window->win32.transparent)
    %%%%%: 1844-block  0
branch  0 never executed
branch  1 never executed
    #####: 1845:        return GLFW_FALSE;
    %%%%%: 1845-block  0
        -: 1846:
    #####: 1847:    if (!IsWindowsVistaOrGreater())
    %%%%%: 1847-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1848:        return GLFW_FALSE;
    %%%%%: 1848-block  0
        -: 1849:
    #####: 1850:    if (FAILED(DwmIsCompositionEnabled(&composition)) || !composition)
    %%%%%: 1850-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 1850-block  1
branch  3 never executed
branch  4 never executed
    #####: 1851:        return GLFW_FALSE;
    %%%%%: 1851-block  0
        -: 1852:
    #####: 1853:    if (!IsWindows8OrGreater())
    %%%%%: 1853-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1854:    {
        -: 1855:        // HACK: Disable framebuffer transparency on Windows 7 when the
        -: 1856:        //       colorization color is opaque, because otherwise the window
        -: 1857:        //       contents is blended additively with the previous frame instead
        -: 1858:        //       of replacing it
    #####: 1859:        if (FAILED(DwmGetColorizationColor(&color, &opaque)) || opaque)
    %%%%%: 1859-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 1859-block  1
branch  3 never executed
branch  4 never executed
    #####: 1860:            return GLFW_FALSE;
    %%%%%: 1860-block  0
        -: 1861:    }
        -: 1862:
    #####: 1863:    return GLFW_TRUE;
    %%%%%: 1863-block  0
        -: 1864:}
        -: 1865:
function _glfwPlatformSetWindowResizable called 0 returned 0% blocks executed 0%
    #####: 1866:void _glfwPlatformSetWindowResizable(_GLFWwindow* window, GLFWbool enabled)
        -: 1867:{
    #####: 1868:    updateWindowStyles(window);
    %%%%%: 1868-block  0
call    0 never executed
    #####: 1869:}
        -: 1870:
function _glfwPlatformSetWindowDecorated called 0 returned 0% blocks executed 0%
    #####: 1871:void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
        -: 1872:{
    #####: 1873:    updateWindowStyles(window);
    %%%%%: 1873-block  0
call    0 never executed
    #####: 1874:}
        -: 1875:
function _glfwPlatformSetWindowFloating called 0 returned 0% blocks executed 0%
    #####: 1876:void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
        -: 1877:{
    #####: 1878:    const HWND after = enabled ? HWND_TOPMOST : HWND_NOTOPMOST;
    %%%%%: 1878-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1878-block  1
    %%%%%: 1878-block  2
    #####: 1879:    SetWindowPos(window->win32.handle, after, 0, 0, 0, 0,
    %%%%%: 1879-block  0
call    0 never executed
        -: 1880:                 SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
    #####: 1881:}
        -: 1882:
function _glfwPlatformSetWindowMousePassthrough called 0 returned 0% blocks executed 0%
    #####: 1883:void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enabled)
        -: 1884:{
    #####: 1885:    COLORREF key = 0;
    #####: 1886:    BYTE alpha = 0;
    #####: 1887:    DWORD flags = 0;
    #####: 1888:    DWORD exStyle = GetWindowLongW(window->win32.handle, GWL_EXSTYLE);
    %%%%%: 1888-block  0
call    0 never executed
        -: 1889:
    #####: 1890:    if (exStyle & WS_EX_LAYERED)
branch  0 never executed
branch  1 never executed
    #####: 1891:        GetLayeredWindowAttributes(window->win32.handle, &key, &alpha, &flags);
    %%%%%: 1891-block  0
call    0 never executed
        -: 1892:
    #####: 1893:    if (enabled)
    %%%%%: 1893-block  0
branch  0 never executed
branch  1 never executed
    #####: 1894:        exStyle |= (WS_EX_TRANSPARENT | WS_EX_LAYERED);
    %%%%%: 1894-block  0
        -: 1895:    else
        -: 1896:    {
    #####: 1897:        exStyle &= ~WS_EX_TRANSPARENT;
        -: 1898:        // NOTE: Window opacity also needs the layered window style so do not
        -: 1899:        //       remove it if the window is alpha blended
    #####: 1900:        if (exStyle & WS_EX_LAYERED)
    %%%%%: 1900-block  0
branch  0 never executed
branch  1 never executed
        -: 1901:        {
    #####: 1902:            if (!(flags & LWA_ALPHA))
    %%%%%: 1902-block  0
branch  0 never executed
branch  1 never executed
    #####: 1903:                exStyle &= ~WS_EX_LAYERED;
    %%%%%: 1903-block  0
        -: 1904:        }
        -: 1905:    }
        -: 1906:
    #####: 1907:    SetWindowLongW(window->win32.handle, GWL_EXSTYLE, exStyle);
    %%%%%: 1907-block  0
call    0 never executed
        -: 1908:
    #####: 1909:    if (enabled)
branch  0 never executed
branch  1 never executed
    #####: 1910:        SetLayeredWindowAttributes(window->win32.handle, key, alpha, flags);
    %%%%%: 1910-block  0
call    0 never executed
    #####: 1911:}
        -: 1912:
function _glfwPlatformGetWindowOpacity called 0 returned 0% blocks executed 0%
    #####: 1913:float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
        -: 1914:{
        -: 1915:    BYTE alpha;
        -: 1916:    DWORD flags;
        -: 1917:
    #####: 1918:    if ((GetWindowLongW(window->win32.handle, GWL_EXSTYLE) & WS_EX_LAYERED) &&
    %%%%%: 1918-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1919:        GetLayeredWindowAttributes(window->win32.handle, NULL, &alpha, &flags))
    %%%%%: 1919-block  0
call    0 never executed
        -: 1920:    {
    #####: 1921:        if (flags & LWA_ALPHA)
    %%%%%: 1921-block  0
branch  0 never executed
branch  1 never executed
    #####: 1922:            return alpha / 255.f;
    %%%%%: 1922-block  0
        -: 1923:    }
        -: 1924:
    #####: 1925:    return 1.f;
    %%%%%: 1925-block  0
        -: 1926:}
        -: 1927:
function _glfwPlatformSetWindowOpacity called 0 returned 0% blocks executed 0%
    #####: 1928:void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
        -: 1929:{
    #####: 1930:    LONG exStyle = GetWindowLongW(window->win32.handle, GWL_EXSTYLE);
    %%%%%: 1930-block  0
call    0 never executed
    #####: 1931:    if (opacity < 1.f || (exStyle & WS_EX_TRANSPARENT))
branch  0 never executed
branch  1 never executed
    %%%%%: 1931-block  0
branch  2 never executed
branch  3 never executed
    #####: 1932:    {
    #####: 1933:        const BYTE alpha = (BYTE) (255 * opacity);
    #####: 1934:        exStyle |= WS_EX_LAYERED;
    #####: 1935:        SetWindowLongW(window->win32.handle, GWL_EXSTYLE, exStyle);
    %%%%%: 1935-block  0
call    0 never executed
    #####: 1936:        SetLayeredWindowAttributes(window->win32.handle, 0, alpha, LWA_ALPHA);
call    0 never executed
        -: 1937:    }
    #####: 1938:    else if (exStyle & WS_EX_TRANSPARENT)
    %%%%%: 1938-block  0
branch  0 never executed
branch  1 never executed
        -: 1939:    {
    #####: 1940:        SetLayeredWindowAttributes(window->win32.handle, 0, 0, 0);
    %%%%%: 1940-block  0
call    0 never executed
        -: 1941:    }
        -: 1942:    else
        -: 1943:    {
    #####: 1944:        exStyle &= ~WS_EX_LAYERED;
    #####: 1945:        SetWindowLongW(window->win32.handle, GWL_EXSTYLE, exStyle);
    %%%%%: 1945-block  0
call    0 never executed
        -: 1946:    }
    #####: 1947:}
        -: 1948:
function _glfwPlatformSetRawMouseMotion called 0 returned 0% blocks executed 0%
    #####: 1949:void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
        -: 1950:{
    #####: 1951:    if (_glfw.win32.disabledCursorWindow != window)
    %%%%%: 1951-block  0
branch  0 never executed
branch  1 never executed
    #####: 1952:        return;
    %%%%%: 1952-block  0
        -: 1953:
    #####: 1954:    if (enabled)
    %%%%%: 1954-block  0
branch  0 never executed
branch  1 never executed
    #####: 1955:        enableRawMouseMotion(window);
    %%%%%: 1955-block  0
call    0 never executed
        -: 1956:    else
    #####: 1957:        disableRawMouseMotion(window);
    %%%%%: 1957-block  0
call    0 never executed
        -: 1958:}
        -: 1959:
function _glfwPlatformRawMouseMotionSupported called 0 returned 0% blocks executed 0%
    #####: 1960:GLFWbool _glfwPlatformRawMouseMotionSupported(void)
        -: 1961:{
    #####: 1962:    return GLFW_TRUE;
    %%%%%: 1962-block  0
        -: 1963:}
        -: 1964:
function _glfwPlatformPollEvents called 104 returned 100% blocks executed 62%
      104: 1965:void _glfwPlatformPollEvents(void)
        -: 1966:{
        -: 1967:    MSG msg;
        -: 1968:    HWND handle;
        -: 1969:    _GLFWwindow* window;
        -: 1970:
      164: 1971:    while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
      104: 1971-block  0
      164: 1971-block  1
call    0 returned 164
branch  1 taken 60
branch  2 taken 104 (fallthrough)
        -: 1972:    {
       60: 1973:        if (msg.message == WM_QUIT)
       60: 1973-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 60
        -: 1974:        {
        -: 1975:            // NOTE: While GLFW does not itself post WM_QUIT, other processes
        -: 1976:            //       may post it to this one, for example Task Manager
        -: 1977:            // HACK: Treat WM_QUIT as a close on all windows
        -: 1978:
    #####: 1979:            window = _glfw.windowListHead;
    #####: 1980:            while (window)
    %%%%%: 1980-block  0
    %%%%%: 1980-block  1
branch  0 never executed
branch  1 never executed
        -: 1981:            {
    #####: 1982:                _glfwInputWindowCloseRequest(window);
    %%%%%: 1982-block  0
call    0 never executed
    #####: 1983:                window = window->next;
        -: 1984:            }
        -: 1985:        }
        -: 1986:        else
        -: 1987:        {
       60: 1988:            TranslateMessage(&msg);
       60: 1988-block  0
call    0 returned 60
       60: 1989:            DispatchMessageW(&msg);
call    0 returned 60
        -: 1990:        }
        -: 1991:    }
        -: 1992:
        -: 1993:    // HACK: Release modifier keys that the system did not emit KEYUP for
        -: 1994:    // NOTE: Shift keys on Windows tend to "stick" when both are pressed as
        -: 1995:    //       no key up message is generated by the first key release
        -: 1996:    // NOTE: Windows key is not reported as released by the Win+V hotkey
        -: 1997:    //       Other Win hotkeys are handled implicitly by _glfwInputWindowFocus
        -: 1998:    //       because they change the input focus
        -: 1999:    // NOTE: The other half of this is in the WM_*KEY* handler in windowProc
      104: 2000:    handle = GetActiveWindow();
      104: 2000-block  0
call    0 returned 104
      104: 2001:    if (handle)
branch  0 taken 104 (fallthrough)
branch  1 taken 0
        -: 2002:    {
      104: 2003:        window = GetPropW(handle, L"GLFW");
      104: 2003-block  0
call    0 returned 104
      104: 2004:        if (window)
branch  0 taken 104 (fallthrough)
branch  1 taken 0
        -: 2005:        {
        -: 2006:            int i;
      104: 2007:            const int keys[4][2] =
        -: 2008:            {
        -: 2009:                { VK_LSHIFT, GLFW_KEY_LEFT_SHIFT },
        -: 2010:                { VK_RSHIFT, GLFW_KEY_RIGHT_SHIFT },
        -: 2011:                { VK_LWIN, GLFW_KEY_LEFT_SUPER },
        -: 2012:                { VK_RWIN, GLFW_KEY_RIGHT_SUPER }
        -: 2013:            };
        -: 2014:
      520: 2015:            for (i = 0;  i < 4;  i++)
      104: 2015-block  0
      416: 2015-block  1
      520: 2015-block  2
branch  0 taken 416
branch  1 taken 104 (fallthrough)
        -: 2016:            {
      416: 2017:                const int vk = keys[i][0];
      416: 2018:                const int key = keys[i][1];
      416: 2019:                const int scancode = _glfw.win32.scancodes[key];
        -: 2020:
      416: 2021:                if ((GetKeyState(vk) & 0x8000))
      416: 2021-block  0
call    0 returned 416
branch  1 taken 0 (fallthrough)
branch  2 taken 416
    #####: 2022:                    continue;
    %%%%%: 2022-block  0
      416: 2023:                if (window->keys[key] != GLFW_PRESS)
      416: 2023-block  0
branch  0 taken 416 (fallthrough)
branch  1 taken 0
      416: 2024:                    continue;
      416: 2024-block  0
        -: 2025:
    #####: 2026:                _glfwInputKey(window, key, scancode, GLFW_RELEASE, getKeyMods());
    %%%%%: 2026-block  0
call    0 never executed
call    1 never executed
        -: 2027:            }
        -: 2028:        }
        -: 2029:    }
        -: 2030:
      104: 2031:    window = _glfw.win32.disabledCursorWindow;
      104: 2032:    if (window)
      104: 2032-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 104
        -: 2033:    {
        -: 2034:        int width, height;
    #####: 2035:        _glfwPlatformGetWindowSize(window, &width, &height);
    %%%%%: 2035-block  0
call    0 never executed
        -: 2036:
        -: 2037:        // NOTE: Re-center the cursor only if it has moved since the last call,
        -: 2038:        //       to avoid breaking glfwWaitEvents with WM_MOUSEMOVE
    #####: 2039:        if (window->win32.lastCursorPosX != width / 2 ||
branch  0 never executed
branch  1 never executed
    #####: 2040:            window->win32.lastCursorPosY != height / 2)
    %%%%%: 2040-block  0
branch  0 never executed
branch  1 never executed
        -: 2041:        {
    #####: 2042:            _glfwPlatformSetCursorPos(window, width / 2, height / 2);
    %%%%%: 2042-block  0
call    0 never executed
        -: 2043:        }
        -: 2044:    }
      104: 2045:}
        -: 2046:
function _glfwPlatformWaitEvents called 0 returned 0% blocks executed 0%
    #####: 2047:void _glfwPlatformWaitEvents(void)
        -: 2048:{
    #####: 2049:    WaitMessage();
    %%%%%: 2049-block  0
call    0 never executed
        -: 2050:
    #####: 2051:    _glfwPlatformPollEvents();
call    0 never executed
    #####: 2052:}
        -: 2053:
function _glfwPlatformWaitEventsTimeout called 0 returned 0% blocks executed 0%
    #####: 2054:void _glfwPlatformWaitEventsTimeout(double timeout)
        -: 2055:{
    #####: 2056:    MsgWaitForMultipleObjects(0, NULL, FALSE, (DWORD) (timeout * 1e3), QS_ALLEVENTS);
    %%%%%: 2056-block  0
call    0 never executed
        -: 2057:
    #####: 2058:    _glfwPlatformPollEvents();
call    0 never executed
    #####: 2059:}
        -: 2060:
function _glfwPlatformPostEmptyEvent called 0 returned 0% blocks executed 0%
    #####: 2061:void _glfwPlatformPostEmptyEvent(void)
        -: 2062:{
    #####: 2063:    PostMessage(_glfw.win32.helperWindowHandle, WM_NULL, 0, 0);
    %%%%%: 2063-block  0
call    0 never executed
    #####: 2064:}
        -: 2065:
function _glfwPlatformGetCursorPos called 0 returned 0% blocks executed 0%
    #####: 2066:void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
        -: 2067:{
        -: 2068:    POINT pos;
        -: 2069:
    #####: 2070:    if (GetCursorPos(&pos))
    %%%%%: 2070-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2071:    {
    #####: 2072:        ScreenToClient(window->win32.handle, &pos);
    %%%%%: 2072-block  0
call    0 never executed
        -: 2073:
    #####: 2074:        if (xpos)
branch  0 never executed
branch  1 never executed
    #####: 2075:            *xpos = pos.x;
    %%%%%: 2075-block  0
    #####: 2076:        if (ypos)
    %%%%%: 2076-block  0
branch  0 never executed
branch  1 never executed
    #####: 2077:            *ypos = pos.y;
    %%%%%: 2077-block  0
        -: 2078:    }
    #####: 2079:}
        -: 2080:
function _glfwPlatformSetCursorPos called 0 returned 0% blocks executed 0%
    #####: 2081:void _glfwPlatformSetCursorPos(_GLFWwindow* window, double xpos, double ypos)
        -: 2082:{
    #####: 2083:    POINT pos = { (int) xpos, (int) ypos };
        -: 2084:
        -: 2085:    // Store the new position so it can be recognized later
    #####: 2086:    window->win32.lastCursorPosX = pos.x;
    #####: 2087:    window->win32.lastCursorPosY = pos.y;
        -: 2088:
    #####: 2089:    ClientToScreen(window->win32.handle, &pos);
    %%%%%: 2089-block  0
call    0 never executed
    #####: 2090:    SetCursorPos(pos.x, pos.y);
call    0 never executed
    #####: 2091:}
        -: 2092:
function _glfwPlatformSetCursorMode called 0 returned 0% blocks executed 0%
    #####: 2093:void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
        -: 2094:{
    #####: 2095:    if (mode == GLFW_CURSOR_DISABLED)
    %%%%%: 2095-block  0
branch  0 never executed
branch  1 never executed
        -: 2096:    {
    #####: 2097:        if (_glfwPlatformWindowFocused(window))
    %%%%%: 2097-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2098:            disableCursor(window);
    %%%%%: 2098-block  0
call    0 never executed
        -: 2099:    }
    #####: 2100:    else if (_glfw.win32.disabledCursorWindow == window)
    %%%%%: 2100-block  0
branch  0 never executed
branch  1 never executed
    #####: 2101:        enableCursor(window);
    %%%%%: 2101-block  0
call    0 never executed
    #####: 2102:    else if (cursorInContentArea(window))
    %%%%%: 2102-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2103:        updateCursorImage(window);
    %%%%%: 2103-block  0
call    0 never executed
    #####: 2104:}
        -: 2105:
function _glfwPlatformGetScancodeName called 0 returned 0% blocks executed 0%
    #####: 2106:const char* _glfwPlatformGetScancodeName(int scancode)
        -: 2107:{
    #####: 2108:    if (scancode < 0 || scancode > (KF_EXTENDED | 0xff) ||
    %%%%%: 2108-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2108-block  1
branch  2 never executed
branch  3 never executed
    #####: 2109:        _glfw.win32.keycodes[scancode] == GLFW_KEY_UNKNOWN)
    %%%%%: 2109-block  0
branch  0 never executed
branch  1 never executed
        -: 2110:    {
    #####: 2111:        _glfwInputError(GLFW_INVALID_VALUE, "Invalid scancode");
    %%%%%: 2111-block  0
call    0 never executed
    #####: 2112:        return NULL;
        -: 2113:    }
        -: 2114:
    #####: 2115:    return _glfw.win32.keynames[_glfw.win32.keycodes[scancode]];
    %%%%%: 2115-block  0
        -: 2116:}
        -: 2117:
function _glfwPlatformGetKeyScancode called 0 returned 0% blocks executed 0%
    #####: 2118:int _glfwPlatformGetKeyScancode(int key)
        -: 2119:{
    #####: 2120:    return _glfw.win32.scancodes[key];
    %%%%%: 2120-block  0
        -: 2121:}
        -: 2122:
function _glfwPlatformCreateCursor called 0 returned 0% blocks executed 0%
    #####: 2123:int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
        -: 2124:                              const GLFWimage* image,
        -: 2125:                              int xhot, int yhot)
        -: 2126:{
    #####: 2127:    cursor->win32.handle = (HCURSOR) createIcon(image, xhot, yhot, GLFW_FALSE);
    %%%%%: 2127-block  0
call    0 never executed
    #####: 2128:    if (!cursor->win32.handle)
branch  0 never executed
branch  1 never executed
    #####: 2129:        return GLFW_FALSE;
    %%%%%: 2129-block  0
        -: 2130:
    #####: 2131:    return GLFW_TRUE;
    %%%%%: 2131-block  0
        -: 2132:}
        -: 2133:
function _glfwPlatformCreateStandardCursor called 0 returned 0% blocks executed 0%
    #####: 2134:int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
        -: 2135:{
    #####: 2136:    int id = 0;
        -: 2137:
    #####: 2138:    switch (shape)
    %%%%%: 2138-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 2139:    {
    #####: 2140:        case GLFW_ARROW_CURSOR:
    #####: 2141:            id = OCR_NORMAL;
    #####: 2142:            break;
    %%%%%: 2142-block  0
    #####: 2143:        case GLFW_IBEAM_CURSOR:
    #####: 2144:            id = OCR_IBEAM;
    #####: 2145:            break;
    %%%%%: 2145-block  0
    #####: 2146:        case GLFW_CROSSHAIR_CURSOR:
    #####: 2147:            id = OCR_CROSS;
    #####: 2148:            break;
    %%%%%: 2148-block  0
    #####: 2149:        case GLFW_POINTING_HAND_CURSOR:
    #####: 2150:            id = OCR_HAND;
    #####: 2151:            break;
    %%%%%: 2151-block  0
    #####: 2152:        case GLFW_RESIZE_EW_CURSOR:
    #####: 2153:            id = OCR_SIZEWE;
    #####: 2154:            break;
    %%%%%: 2154-block  0
    #####: 2155:        case GLFW_RESIZE_NS_CURSOR:
    #####: 2156:            id = OCR_SIZENS;
    #####: 2157:            break;
    %%%%%: 2157-block  0
    #####: 2158:        case GLFW_RESIZE_NWSE_CURSOR:
    #####: 2159:            id = OCR_SIZENWSE;
    #####: 2160:            break;
    %%%%%: 2160-block  0
    #####: 2161:        case GLFW_RESIZE_NESW_CURSOR:
    #####: 2162:            id = OCR_SIZENESW;
    #####: 2163:            break;
    %%%%%: 2163-block  0
    #####: 2164:        case GLFW_RESIZE_ALL_CURSOR:
    #####: 2165:            id = OCR_SIZEALL;
    #####: 2166:            break;
    %%%%%: 2166-block  0
    #####: 2167:        case GLFW_NOT_ALLOWED_CURSOR:
    #####: 2168:            id = OCR_NO;
    #####: 2169:            break;
    %%%%%: 2169-block  0
    #####: 2170:        default:
    #####: 2171:            _glfwInputError(GLFW_PLATFORM_ERROR, "Win32: Unknown standard cursor");
    %%%%%: 2171-block  0
call    0 never executed
    #####: 2172:            return GLFW_FALSE;
        -: 2173:    }
        -: 2174:
    #####: 2175:    cursor->win32.handle = LoadImageW(NULL,
    #####: 2176:                                      MAKEINTRESOURCEW(id), IMAGE_CURSOR, 0, 0,
    %%%%%: 2176-block  0
call    0 never executed
        -: 2177:                                      LR_DEFAULTSIZE | LR_SHARED);
    #####: 2178:    if (!cursor->win32.handle)
branch  0 never executed
branch  1 never executed
        -: 2179:    {
    #####: 2180:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 2180-block  0
call    0 never executed
        -: 2181:                             "Win32: Failed to create standard cursor");
    #####: 2182:        return GLFW_FALSE;
        -: 2183:    }
        -: 2184:
    #####: 2185:    return GLFW_TRUE;
    %%%%%: 2185-block  0
        -: 2186:}
        -: 2187:
function _glfwPlatformDestroyCursor called 0 returned 0% blocks executed 0%
    #####: 2188:void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
        -: 2189:{
    #####: 2190:    if (cursor->win32.handle)
    %%%%%: 2190-block  0
branch  0 never executed
branch  1 never executed
    #####: 2191:        DestroyIcon((HICON) cursor->win32.handle);
    %%%%%: 2191-block  0
call    0 never executed
    #####: 2192:}
        -: 2193:
function _glfwPlatformSetCursor called 0 returned 0% blocks executed 0%
    #####: 2194:void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
        -: 2195:{
    #####: 2196:    if (cursorInContentArea(window))
    %%%%%: 2196-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2197:        updateCursorImage(window);
    %%%%%: 2197-block  0
call    0 never executed
    #####: 2198:}
        -: 2199:
function _glfwPlatformSetClipboardString called 0 returned 0% blocks executed 0%
    #####: 2200:void _glfwPlatformSetClipboardString(const char* string)
        -: 2201:{
        -: 2202:    int characterCount;
        -: 2203:    HANDLE object;
        -: 2204:    WCHAR* buffer;
        -: 2205:
    #####: 2206:    characterCount = MultiByteToWideChar(CP_UTF8, 0, string, -1, NULL, 0);
    %%%%%: 2206-block  0
call    0 never executed
    #####: 2207:    if (!characterCount)
branch  0 never executed
branch  1 never executed
    #####: 2208:        return;
    %%%%%: 2208-block  0
        -: 2209:
    #####: 2210:    object = GlobalAlloc(GMEM_MOVEABLE, characterCount * sizeof(WCHAR));
    %%%%%: 2210-block  0
call    0 never executed
    #####: 2211:    if (!object)
branch  0 never executed
branch  1 never executed
        -: 2212:    {
    #####: 2213:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 2213-block  0
call    0 never executed
        -: 2214:                             "Win32: Failed to allocate global handle for clipboard");
    #####: 2215:        return;
        -: 2216:    }
        -: 2217:
    #####: 2218:    buffer = GlobalLock(object);
    %%%%%: 2218-block  0
call    0 never executed
    #####: 2219:    if (!buffer)
branch  0 never executed
branch  1 never executed
        -: 2220:    {
    #####: 2221:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 2221-block  0
call    0 never executed
        -: 2222:                             "Win32: Failed to lock global handle");
    #####: 2223:        GlobalFree(object);
call    0 never executed
    #####: 2224:        return;
        -: 2225:    }
        -: 2226:
    #####: 2227:    MultiByteToWideChar(CP_UTF8, 0, string, -1, buffer, characterCount);
    %%%%%: 2227-block  0
call    0 never executed
    #####: 2228:    GlobalUnlock(object);
call    0 never executed
        -: 2229:
    #####: 2230:    if (!OpenClipboard(_glfw.win32.helperWindowHandle))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2231:    {
    #####: 2232:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 2232-block  0
call    0 never executed
        -: 2233:                             "Win32: Failed to open clipboard");
    #####: 2234:        GlobalFree(object);
call    0 never executed
    #####: 2235:        return;
        -: 2236:    }
        -: 2237:
    #####: 2238:    EmptyClipboard();
    %%%%%: 2238-block  0
call    0 never executed
    #####: 2239:    SetClipboardData(CF_UNICODETEXT, object);
call    0 never executed
    #####: 2240:    CloseClipboard();
call    0 never executed
        -: 2241:}
        -: 2242:
function _glfwPlatformGetClipboardString called 0 returned 0% blocks executed 0%
    #####: 2243:const char* _glfwPlatformGetClipboardString(void)
        -: 2244:{
        -: 2245:    HANDLE object;
        -: 2246:    WCHAR* buffer;
        -: 2247:
    #####: 2248:    if (!OpenClipboard(_glfw.win32.helperWindowHandle))
    %%%%%: 2248-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2249:    {
    #####: 2250:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 2250-block  0
call    0 never executed
        -: 2251:                             "Win32: Failed to open clipboard");
    #####: 2252:        return NULL;
        -: 2253:    }
        -: 2254:
    #####: 2255:    object = GetClipboardData(CF_UNICODETEXT);
    %%%%%: 2255-block  0
call    0 never executed
    #####: 2256:    if (!object)
branch  0 never executed
branch  1 never executed
        -: 2257:    {
    #####: 2258:        _glfwInputErrorWin32(GLFW_FORMAT_UNAVAILABLE,
    %%%%%: 2258-block  0
call    0 never executed
        -: 2259:                             "Win32: Failed to convert clipboard to string");
    #####: 2260:        CloseClipboard();
call    0 never executed
    #####: 2261:        return NULL;
        -: 2262:    }
        -: 2263:
    #####: 2264:    buffer = GlobalLock(object);
    %%%%%: 2264-block  0
call    0 never executed
    #####: 2265:    if (!buffer)
branch  0 never executed
branch  1 never executed
        -: 2266:    {
    #####: 2267:        _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
    %%%%%: 2267-block  0
call    0 never executed
        -: 2268:                             "Win32: Failed to lock global handle");
    #####: 2269:        CloseClipboard();
call    0 never executed
    #####: 2270:        return NULL;
        -: 2271:    }
        -: 2272:
    #####: 2273:    free(_glfw.win32.clipboardString);
    #####: 2274:    _glfw.win32.clipboardString = _glfwCreateUTF8FromWideStringWin32(buffer);
    %%%%%: 2274-block  0
call    0 never executed
        -: 2275:
    #####: 2276:    GlobalUnlock(object);
call    0 never executed
    #####: 2277:    CloseClipboard();
call    0 never executed
        -: 2278:
    #####: 2279:    return _glfw.win32.clipboardString;
        -: 2280:}
        -: 2281:
function _glfwPlatformGetEGLPlatform called 0 returned 0% blocks executed 0%
    #####: 2282:EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
        -: 2283:{
    #####: 2284:    if (_glfw.egl.ANGLE_platform_angle)
    %%%%%: 2284-block  0
branch  0 never executed
branch  1 never executed
        -: 2285:    {
    #####: 2286:        int type = 0;
        -: 2287:
    #####: 2288:        if (_glfw.egl.ANGLE_platform_angle_opengl)
    %%%%%: 2288-block  0
branch  0 never executed
branch  1 never executed
        -: 2289:        {
    #####: 2290:            if (_glfw.hints.init.angleType == GLFW_ANGLE_PLATFORM_TYPE_OPENGL)
    %%%%%: 2290-block  0
branch  0 never executed
branch  1 never executed
    #####: 2291:                type = EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE;
    %%%%%: 2291-block  0
    #####: 2292:            else if (_glfw.hints.init.angleType == GLFW_ANGLE_PLATFORM_TYPE_OPENGLES)
    %%%%%: 2292-block  0
branch  0 never executed
branch  1 never executed
    #####: 2293:                type = EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE;
    %%%%%: 2293-block  0
        -: 2294:        }
        -: 2295:
    #####: 2296:        if (_glfw.egl.ANGLE_platform_angle_d3d)
    %%%%%: 2296-block  0
branch  0 never executed
branch  1 never executed
        -: 2297:        {
    #####: 2298:            if (_glfw.hints.init.angleType == GLFW_ANGLE_PLATFORM_TYPE_D3D9)
    %%%%%: 2298-block  0
branch  0 never executed
branch  1 never executed
    #####: 2299:                type = EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE;
    %%%%%: 2299-block  0
    #####: 2300:            else if (_glfw.hints.init.angleType == GLFW_ANGLE_PLATFORM_TYPE_D3D11)
    %%%%%: 2300-block  0
branch  0 never executed
branch  1 never executed
    #####: 2301:                type = EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE;
    %%%%%: 2301-block  0
        -: 2302:        }
        -: 2303:
    #####: 2304:        if (_glfw.egl.ANGLE_platform_angle_vulkan)
    %%%%%: 2304-block  0
branch  0 never executed
branch  1 never executed
        -: 2305:        {
    #####: 2306:            if (_glfw.hints.init.angleType == GLFW_ANGLE_PLATFORM_TYPE_VULKAN)
    %%%%%: 2306-block  0
branch  0 never executed
branch  1 never executed
    #####: 2307:                type = EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE;
    %%%%%: 2307-block  0
        -: 2308:        }
        -: 2309:
    #####: 2310:        if (type)
    %%%%%: 2310-block  0
branch  0 never executed
branch  1 never executed
        -: 2311:        {
    #####: 2312:            *attribs = calloc(3, sizeof(EGLint));
    #####: 2313:            (*attribs)[0] = EGL_PLATFORM_ANGLE_TYPE_ANGLE;
    #####: 2314:            (*attribs)[1] = type;
    #####: 2315:            (*attribs)[2] = EGL_NONE;
    #####: 2316:            return EGL_PLATFORM_ANGLE_ANGLE;
    %%%%%: 2316-block  0
        -: 2317:        }
        -: 2318:    }
        -: 2319:
    #####: 2320:    return 0;
    %%%%%: 2320-block  0
        -: 2321:}
        -: 2322:
function _glfwPlatformGetEGLNativeDisplay called 0 returned 0% blocks executed 0%
    #####: 2323:EGLNativeDisplayType _glfwPlatformGetEGLNativeDisplay(void)
        -: 2324:{
    #####: 2325:    return GetDC(_glfw.win32.helperWindowHandle);
    %%%%%: 2325-block  0
call    0 never executed
        -: 2326:}
        -: 2327:
function _glfwPlatformGetEGLNativeWindow called 0 returned 0% blocks executed 0%
    #####: 2328:EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window)
        -: 2329:{
    #####: 2330:    return window->win32.handle;
    %%%%%: 2330-block  0
        -: 2331:}
        -: 2332:
function _glfwPlatformGetRequiredInstanceExtensions called 0 returned 0% blocks executed 0%
    #####: 2333:void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
        -: 2334:{
    #####: 2335:    if (!_glfw.vk.KHR_surface || !_glfw.vk.KHR_win32_surface)
    %%%%%: 2335-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2335-block  1
branch  2 never executed
branch  3 never executed
    #####: 2336:        return;
    %%%%%: 2336-block  0
        -: 2337:
    #####: 2338:    extensions[0] = "VK_KHR_surface";
    #####: 2339:    extensions[1] = "VK_KHR_win32_surface";
    %%%%%: 2339-block  0
        -: 2340:}
        -: 2341:
function _glfwPlatformGetPhysicalDevicePresentationSupport called 0 returned 0% blocks executed 0%
    #####: 2342:int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
        -: 2343:                                                      VkPhysicalDevice device,
        -: 2344:                                                      uint32_t queuefamily)
        -: 2345:{
        -: 2346:    PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR
        -: 2347:        vkGetPhysicalDeviceWin32PresentationSupportKHR =
        -: 2348:        (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)
    #####: 2349:        vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
    %%%%%: 2349-block  0
call    0 never executed
    #####: 2350:    if (!vkGetPhysicalDeviceWin32PresentationSupportKHR)
branch  0 never executed
branch  1 never executed
        -: 2351:    {
    #####: 2352:        _glfwInputError(GLFW_API_UNAVAILABLE,
    %%%%%: 2352-block  0
call    0 never executed
        -: 2353:                        "Win32: Vulkan instance missing VK_KHR_win32_surface extension");
    #####: 2354:        return GLFW_FALSE;
        -: 2355:    }
        -: 2356:
    #####: 2357:    return vkGetPhysicalDeviceWin32PresentationSupportKHR(device, queuefamily);
    %%%%%: 2357-block  0
call    0 never executed
        -: 2358:}
        -: 2359:
function _glfwPlatformCreateWindowSurface called 0 returned 0% blocks executed 0%
    #####: 2360:VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
        -: 2361:                                          _GLFWwindow* window,
        -: 2362:                                          const VkAllocationCallbacks* allocator,
        -: 2363:                                          VkSurfaceKHR* surface)
        -: 2364:{
        -: 2365:    VkResult err;
        -: 2366:    VkWin32SurfaceCreateInfoKHR sci;
        -: 2367:    PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR;
        -: 2368:
        -: 2369:    vkCreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR)
    #####: 2370:        vkGetInstanceProcAddr(instance, "vkCreateWin32SurfaceKHR");
    %%%%%: 2370-block  0
call    0 never executed
    #####: 2371:    if (!vkCreateWin32SurfaceKHR)
branch  0 never executed
branch  1 never executed
        -: 2372:    {
    #####: 2373:        _glfwInputError(GLFW_API_UNAVAILABLE,
    %%%%%: 2373-block  0
call    0 never executed
        -: 2374:                        "Win32: Vulkan instance missing VK_KHR_win32_surface extension");
    #####: 2375:        return VK_ERROR_EXTENSION_NOT_PRESENT;
        -: 2376:    }
        -: 2377:
    #####: 2378:    memset(&sci, 0, sizeof(sci));
    #####: 2379:    sci.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    #####: 2380:    sci.hinstance = GetModuleHandle(NULL);
    %%%%%: 2380-block  0
call    0 never executed
    #####: 2381:    sci.hwnd = window->win32.handle;
        -: 2382:
    #####: 2383:    err = vkCreateWin32SurfaceKHR(instance, &sci, allocator, surface);
call    0 never executed
    #####: 2384:    if (err)
branch  0 never executed
branch  1 never executed
        -: 2385:    {
    #####: 2386:        _glfwInputError(GLFW_PLATFORM_ERROR,
    %%%%%: 2386-block  0
call    0 never executed
call    1 never executed
        -: 2387:                        "Win32: Failed to create Vulkan surface: %s",
        -: 2388:                        _glfwGetVulkanResultString(err));
        -: 2389:    }
        -: 2390:
    #####: 2391:    return err;
    %%%%%: 2391-block  0
        -: 2392:}
        -: 2393:
        -: 2394:
        -: 2395://////////////////////////////////////////////////////////////////////////
        -: 2396://////                        GLFW native API                       //////
        -: 2397://////////////////////////////////////////////////////////////////////////
        -: 2398:
function glfwGetWin32Window called 0 returned 0% blocks executed 0%
    #####: 2399:GLFWAPI HWND glfwGetWin32Window(GLFWwindow* handle)
        -: 2400:{
    #####: 2401:    _GLFWwindow* window = (_GLFWwindow*) handle;
    #####: 2402:    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
    %%%%%: 2402-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2402-block  1
call    2 never executed
    #####: 2403:    return window->win32.handle;
    %%%%%: 2403-block  0
        -: 2404:}
        -: 2405:
