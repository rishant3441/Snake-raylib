        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/textures.c
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\textures.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\textures.c.gcda
        -:    0:Runs:1
        -:    1:/**********************************************************************************************
        -:    2:*
        -:    3:*   raylib.textures - Basic functions to load and draw Textures (2d)
        -:    4:*
        -:    5:*   CONFIGURATION:
        -:    6:*
        -:    7:*   #define SUPPORT_FILEFORMAT_BMP
        -:    8:*   #define SUPPORT_FILEFORMAT_PNG
        -:    9:*   #define SUPPORT_FILEFORMAT_TGA
        -:   10:*   #define SUPPORT_FILEFORMAT_JPG
        -:   11:*   #define SUPPORT_FILEFORMAT_GIF
        -:   12:*   #define SUPPORT_FILEFORMAT_PSD
        -:   13:*   #define SUPPORT_FILEFORMAT_PIC
        -:   14:*   #define SUPPORT_FILEFORMAT_HDR
        -:   15:*   #define SUPPORT_FILEFORMAT_DDS
        -:   16:*   #define SUPPORT_FILEFORMAT_PKM
        -:   17:*   #define SUPPORT_FILEFORMAT_KTX
        -:   18:*   #define SUPPORT_FILEFORMAT_PVR
        -:   19:*   #define SUPPORT_FILEFORMAT_ASTC
        -:   20:*       Select desired fileformats to be supported for image data loading. Some of those formats are
        -:   21:*       supported by default, to remove support, just comment unrequired #define in this module
        -:   22:*
        -:   23:*   #define SUPPORT_IMAGE_EXPORT
        -:   24:*       Support image export in multiple file formats
        -:   25:*
        -:   26:*   #define SUPPORT_IMAGE_MANIPULATION
        -:   27:*       Support multiple image editing functions to scale, adjust colors, flip, draw on images, crop...
        -:   28:*       If not defined only three image editing functions supported: ImageFormat(), ImageAlphaMask(), ImageToPOT()
        -:   29:*
        -:   30:*   #define SUPPORT_IMAGE_GENERATION
        -:   31:*       Support procedural image generation functionality (gradient, spot, perlin-noise, cellular)
        -:   32:*
        -:   33:*   DEPENDENCIES:
        -:   34:*       stb_image        - Multiple image formats loading (JPEG, PNG, BMP, TGA, PSD, GIF, PIC)
        -:   35:*                          NOTE: stb_image has been slightly modified to support Android platform.
        -:   36:*       stb_image_resize - Multiple image resize algorythms
        -:   37:*
        -:   38:*
        -:   39:*   LICENSE: zlib/libpng
        -:   40:*
        -:   41:*   Copyright (c) 2013-2021 Ramon Santamaria (@raysan5)
        -:   42:*
        -:   43:*   This software is provided "as-is", without any express or implied warranty. In no event
        -:   44:*   will the authors be held liable for any damages arising from the use of this software.
        -:   45:*
        -:   46:*   Permission is granted to anyone to use this software for any purpose, including commercial
        -:   47:*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
        -:   48:*
        -:   49:*     1. The origin of this software must not be misrepresented; you must not claim that you
        -:   50:*     wrote the original software. If you use this software in a product, an acknowledgment
        -:   51:*     in the product documentation would be appreciated but is not required.
        -:   52:*
        -:   53:*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
        -:   54:*     as being the original software.
        -:   55:*
        -:   56:*     3. This notice may not be removed or altered from any source distribution.
        -:   57:*
        -:   58:**********************************************************************************************/
        -:   59:
        -:   60:#include "raylib.h"             // Declares module functions
        -:   61:
        -:   62:// Check if config flags have been externally provided on compilation line
        -:   63:#if !defined(EXTERNAL_CONFIG_FLAGS)
        -:   64:    #include "config.h"         // Defines module configuration flags
        -:   65:#endif
        -:   66:
        -:   67:#include "utils.h"              // Required for: TRACELOG() and fopen() Android mapping
        -:   68:#include "rlgl.h"               // OpenGL abstraction layer to OpenGL 1.1, 3.3 or ES2
        -:   69:
        -:   70:#include <stdlib.h>             // Required for: malloc(), free()
        -:   71:#include <string.h>             // Required for: strlen() [Used in ImageTextEx()]
        -:   72:#include <math.h>               // Required for: fabsf()
        -:   73:#include <stdio.h>              // Required for: sprintf() [Used in ExportImageAsCode()]
        -:   74:
        -:   75:// Support only desired texture formats on stb_image
        -:   76:#if !defined(SUPPORT_FILEFORMAT_BMP)
        -:   77:    #define STBI_NO_BMP
        -:   78:#endif
        -:   79:#if !defined(SUPPORT_FILEFORMAT_PNG)
        -:   80:    #define STBI_NO_PNG
        -:   81:#endif
        -:   82:#if !defined(SUPPORT_FILEFORMAT_TGA)
        -:   83:    #define STBI_NO_TGA
        -:   84:#endif
        -:   85:#if !defined(SUPPORT_FILEFORMAT_JPG)
        -:   86:    #define STBI_NO_JPEG        // Image format .jpg and .jpeg
        -:   87:#endif
        -:   88:#if !defined(SUPPORT_FILEFORMAT_PSD)
        -:   89:    #define STBI_NO_PSD
        -:   90:#endif
        -:   91:#if !defined(SUPPORT_FILEFORMAT_GIF)
        -:   92:    #define STBI_NO_GIF
        -:   93:#endif
        -:   94:#if !defined(SUPPORT_FILEFORMAT_PIC)
        -:   95:    #define STBI_NO_PIC
        -:   96:#endif
        -:   97:#if !defined(SUPPORT_FILEFORMAT_HDR)
        -:   98:    #define STBI_NO_HDR
        -:   99:#endif
        -:  100:
        -:  101:// Image fileformats not supported by default
        -:  102:#define STBI_NO_PIC
        -:  103:#define STBI_NO_PNM             // Image format .ppm and .pgm
        -:  104:
        -:  105:#if defined(__TINYC__)
        -:  106:    #define STBI_NO_SIMD
        -:  107:#endif
        -:  108:
        -:  109:#if (defined(SUPPORT_FILEFORMAT_BMP) || \
        -:  110:     defined(SUPPORT_FILEFORMAT_PNG) || \
        -:  111:     defined(SUPPORT_FILEFORMAT_TGA) || \
        -:  112:     defined(SUPPORT_FILEFORMAT_JPG) || \
        -:  113:     defined(SUPPORT_FILEFORMAT_PSD) || \
        -:  114:     defined(SUPPORT_FILEFORMAT_GIF) || \
        -:  115:     defined(SUPPORT_FILEFORMAT_PIC) || \
        -:  116:     defined(SUPPORT_FILEFORMAT_HDR))
        -:  117:
        -:  118:    #define STBI_MALLOC RL_MALLOC
        -:  119:    #define STBI_FREE RL_FREE
        -:  120:    #define STBI_REALLOC RL_REALLOC
        -:  121:
        -:  122:    #define STB_IMAGE_IMPLEMENTATION
        -:  123:    #include "external/stb_image.h"         // Required for: stbi_load_from_file()
        -:  124:                                            // NOTE: Used to read image data (multiple formats support)
        -:  125:#endif
        -:  126:
        -:  127:#if defined(SUPPORT_IMAGE_EXPORT)
        -:  128:    #define STBIW_MALLOC RL_MALLOC
        -:  129:    #define STBIW_FREE RL_FREE
        -:  130:    #define STBIW_REALLOC RL_REALLOC
        -:  131:
        -:  132:    #define STB_IMAGE_WRITE_IMPLEMENTATION
        -:  133:    #include "external/stb_image_write.h"   // Required for: stbi_write_*()
        -:  134:#endif
        -:  135:
        -:  136:#if defined(SUPPORT_IMAGE_MANIPULATION)
        -:  137:    #define STBIR_MALLOC(size,c) ((void)(c), RL_MALLOC(size))
        -:  138:    #define STBIR_FREE(ptr,c) ((void)(c), RL_FREE(ptr))
        -:  139:
        -:  140:    #define STB_IMAGE_RESIZE_IMPLEMENTATION
        -:  141:    #include "external/stb_image_resize.h"  // Required for: stbir_resize_uint8() [ImageResize()]
        -:  142:#endif
        -:  143:
        -:  144:#if defined(SUPPORT_IMAGE_GENERATION)
        -:  145:    #define STB_PERLIN_IMPLEMENTATION
        -:  146:    #include "external/stb_perlin.h"        // Required for: stb_perlin_fbm_noise3
        -:  147:#endif
        -:  148:
        -:  149://----------------------------------------------------------------------------------
        -:  150:// Defines and Macros
        -:  151://----------------------------------------------------------------------------------
        -:  152:#ifndef PIXELFORMAT_UNCOMPRESSED_R5G5B5A1_ALPHA_THRESHOLD
        -:  153:    #define PIXELFORMAT_UNCOMPRESSED_R5G5B5A1_ALPHA_THRESHOLD  50    // Threshold over 255 to set alpha as 0
        -:  154:#endif
        -:  155:
        -:  156://----------------------------------------------------------------------------------
        -:  157:// Types and Structures Definition
        -:  158://----------------------------------------------------------------------------------
        -:  159:// ...
        -:  160:
        -:  161://----------------------------------------------------------------------------------
        -:  162:// Global Variables Definition
        -:  163://----------------------------------------------------------------------------------
        -:  164:// It's lonely here...
        -:  165:
        -:  166://----------------------------------------------------------------------------------
        -:  167:// Other Modules Functions Declaration (required by text)
        -:  168://----------------------------------------------------------------------------------
        -:  169:// ...
        -:  170:
        -:  171://----------------------------------------------------------------------------------
        -:  172:// Module specific Functions Declaration
        -:  173://----------------------------------------------------------------------------------
        -:  174:#if defined(SUPPORT_FILEFORMAT_DDS)
        -:  175:static Image LoadDDS(const unsigned char *fileData, unsigned int fileSize);   // Load DDS file data
        -:  176:#endif
        -:  177:#if defined(SUPPORT_FILEFORMAT_PKM)
        -:  178:static Image LoadPKM(const unsigned char *fileData, unsigned int fileSize);   // Load PKM file data
        -:  179:#endif
        -:  180:#if defined(SUPPORT_FILEFORMAT_KTX)
        -:  181:static Image LoadKTX(const unsigned char *fileData, unsigned int fileSize);   // Load KTX file data
        -:  182:static int SaveKTX(Image image, const char *fileName);  // Save image data as KTX file
        -:  183:#endif
        -:  184:#if defined(SUPPORT_FILEFORMAT_PVR)
        -:  185:static Image LoadPVR(const unsigned char *fileData, unsigned int fileSize);   // Load PVR file data
        -:  186:#endif
        -:  187:#if defined(SUPPORT_FILEFORMAT_ASTC)
        -:  188:static Image LoadASTC(const unsigned char *fileData, unsigned int fileSize);  // Load ASTC file data
        -:  189:#endif
        -:  190:
        -:  191:static Vector4 *LoadImageDataNormalized(Image image);       // Load pixel data from image as Vector4 array (float normalized)
        -:  192:
        -:  193://----------------------------------------------------------------------------------
        -:  194:// Module Functions Definition
        -:  195://----------------------------------------------------------------------------------
        -:  196:
        -:  197:// Load image from file into CPU memory (RAM)
function LoadImage called 0 returned 0% blocks executed 0%
    #####:  198:Image LoadImage(const char *fileName)
        -:  199:{
    #####:  200:    Image image = { 0 };
        -:  201:
        -:  202:#if defined(SUPPORT_FILEFORMAT_PNG) || \
        -:  203:    defined(SUPPORT_FILEFORMAT_BMP) || \
        -:  204:    defined(SUPPORT_FILEFORMAT_TGA) || \
        -:  205:    defined(SUPPORT_FILEFORMAT_JPG) || \
        -:  206:    defined(SUPPORT_FILEFORMAT_GIF) || \
        -:  207:    defined(SUPPORT_FILEFORMAT_PIC) || \
        -:  208:    defined(SUPPORT_FILEFORMAT_HDR) || \
        -:  209:    defined(SUPPORT_FILEFORMAT_PSD)
        -:  210:#define STBI_REQUIRED
        -:  211:#endif
        -:  212:
        -:  213:    // Loading file to memory
    #####:  214:    unsigned int fileSize = 0;
    #####:  215:    unsigned char *fileData = LoadFileData(fileName, &fileSize);
    %%%%%:  215-block  0
call    0 never executed
        -:  216:
        -:  217:    // Loading image from memory data
    #####:  218:    if (fileData != NULL) image = LoadImageFromMemory(GetFileExtension(fileName), fileData, fileSize);
branch  0 never executed
branch  1 never executed
    %%%%%:  218-block  0
call    2 never executed
call    3 never executed
        -:  219:
    #####:  220:    RL_FREE(fileData);
        -:  221:
    #####:  222:    return image;
    %%%%%:  222-block  0
        -:  223:}
        -:  224:
        -:  225:// Load an image from RAW file data
function LoadImageRaw called 0 returned 0% blocks executed 0%
    #####:  226:Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize)
        -:  227:{
    #####:  228:    Image image = { 0 };
        -:  229:
    #####:  230:    unsigned int dataSize = 0;
    #####:  231:    unsigned char *fileData = LoadFileData(fileName, &dataSize);
    %%%%%:  231-block  0
call    0 never executed
        -:  232:
    #####:  233:    if (fileData != NULL)
branch  0 never executed
branch  1 never executed
        -:  234:    {
    #####:  235:        unsigned char *dataPtr = fileData;
    #####:  236:        unsigned int size = GetPixelDataSize(width, height, format);
    %%%%%:  236-block  0
call    0 never executed
        -:  237:
    #####:  238:        if (headerSize > 0) dataPtr += headerSize;
branch  0 never executed
branch  1 never executed
    %%%%%:  238-block  0
        -:  239:
    #####:  240:        image.data = RL_MALLOC(size);      // Allocate required memory in bytes
    #####:  241:        memcpy(image.data, dataPtr, size); // Copy required data to image
    #####:  242:        image.width = width;
    #####:  243:        image.height = height;
    #####:  244:        image.mipmaps = 1;
    #####:  245:        image.format = format;
        -:  246:
    #####:  247:        RL_FREE(fileData);
    %%%%%:  247-block  0
        -:  248:    }
        -:  249:
    #####:  250:    return image;
    %%%%%:  250-block  0
        -:  251:}
        -:  252:
        -:  253:// Load animated image data
        -:  254://  - Image.data buffer includes all frames: [image#0][image#1][image#2][...]
        -:  255://  - Number of frames is returned through 'frames' parameter
        -:  256://  - All frames are returned in RGBA format
        -:  257://  - Frames delay data is discarded
function LoadImageAnim called 0 returned 0% blocks executed 0%
    #####:  258:Image LoadImageAnim(const char *fileName, int *frames)
        -:  259:{
    #####:  260:    Image image = { 0 };
    #####:  261:    int frameCount = 1;
        -:  262:
        -:  263:#if defined(SUPPORT_FILEFORMAT_GIF)
    #####:  264:    if (IsFileExtension(fileName, ".gif"))
    %%%%%:  264-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  265:    {
    #####:  266:        unsigned int dataSize = 0;
    #####:  267:        unsigned char *fileData = LoadFileData(fileName, &dataSize);
    %%%%%:  267-block  0
call    0 never executed
        -:  268:
    #####:  269:        if (fileData != NULL)
branch  0 never executed
branch  1 never executed
        -:  270:        {
    #####:  271:            int comp = 0;
    #####:  272:            int **delays = NULL;
    #####:  273:            image.data = stbi_load_gif_from_memory(fileData, dataSize, delays, &image.width, &image.height, &frameCount, &comp, 4);
    %%%%%:  273-block  0
call    0 never executed
        -:  274:
    #####:  275:            image.mipmaps = 1;
    #####:  276:            image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -:  277:
    #####:  278:            RL_FREE(fileData);
    #####:  279:            RL_FREE(delays);        // NOTE: Frames delays are discarded
        -:  280:        }
        -:  281:    }
        -:  282:#else
        -:  283:    if (false) { }
        -:  284:#endif
    #####:  285:    else image = LoadImage(fileName);
    %%%%%:  285-block  0
call    0 never executed
        -:  286:
        -:  287:    // TODO: Support APNG animated images?
        -:  288:
    #####:  289:    *frames = frameCount;
    #####:  290:    return image;
    %%%%%:  290-block  0
        -:  291:}
        -:  292:
        -:  293:// Load image from memory buffer, fileType refers to extension: i.e. ".png"
function LoadImageFromMemory called 0 returned 0% blocks executed 0%
    #####:  294:Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
        -:  295:{
    #####:  296:    Image image = { 0 };
        -:  297:
    #####:  298:    char fileExtLower[16] = { 0 };
    #####:  299:    strcpy(fileExtLower, TextToLower(fileType));
    %%%%%:  299-block  0
call    0 never executed
        -:  300:
        -:  301:#if defined(SUPPORT_FILEFORMAT_PNG)
    #####:  302:    if ((TextIsEqual(fileExtLower, ".png"))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  303:#else
        -:  304:    if ((false)
        -:  305:#endif
        -:  306:#if defined(SUPPORT_FILEFORMAT_BMP)
        -:  307:        || (TextIsEqual(fileExtLower, ".bmp"))
        -:  308:#endif
        -:  309:#if defined(SUPPORT_FILEFORMAT_TGA)
        -:  310:        || (TextIsEqual(fileExtLower, ".tga"))
        -:  311:#endif
        -:  312:#if defined(SUPPORT_FILEFORMAT_JPG)
        -:  313:        || (TextIsEqual(fileExtLower, ".jpg") ||
        -:  314:            TextIsEqual(fileExtLower, ".jpeg"))
        -:  315:#endif
        -:  316:#if defined(SUPPORT_FILEFORMAT_GIF)
    #####:  317:        || (TextIsEqual(fileExtLower, ".gif"))
    %%%%%:  317-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  318:#endif
        -:  319:#if defined(SUPPORT_FILEFORMAT_PIC)
        -:  320:        || (TextIsEqual(fileExtLower, ".pic"))
        -:  321:#endif
        -:  322:#if defined(SUPPORT_FILEFORMAT_PSD)
        -:  323:        || (TextIsEqual(fileExtLower, ".psd"))
        -:  324:#endif
        -:  325:       )
        -:  326:    {
        -:  327:#if defined(STBI_REQUIRED)
        -:  328:        // NOTE: Using stb_image to load images (Supports multiple image formats)
        -:  329:
    #####:  330:        if (fileData != NULL)
    %%%%%:  330-block  0
branch  0 never executed
branch  1 never executed
        -:  331:        {
    #####:  332:            int comp = 0;
    #####:  333:            image.data = stbi_load_from_memory(fileData, dataSize, &image.width, &image.height, &comp, 0);
    %%%%%:  333-block  0
call    0 never executed
        -:  334:
    #####:  335:            if (image.data != NULL)
branch  0 never executed
branch  1 never executed
        -:  336:            {
    #####:  337:                image.mipmaps = 1;
        -:  338:
    #####:  339:                if (comp == 1) image.format = PIXELFORMAT_UNCOMPRESSED_GRAYSCALE;
    %%%%%:  339-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  339-block  1
    #####:  340:                else if (comp == 2) image.format = PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA;
    %%%%%:  340-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  340-block  1
    #####:  341:                else if (comp == 3) image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8;
    %%%%%:  341-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  341-block  1
    #####:  342:                else if (comp == 4) image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
    %%%%%:  342-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  342-block  1
        -:  343:            }
        -:  344:        }
        -:  345:#endif
        -:  346:    }
        -:  347:#if defined(SUPPORT_FILEFORMAT_HDR)
    #####:  348:    else if (TextIsEqual(fileExtLower, ".hdr"))
    %%%%%:  348-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  349:    {
        -:  350:#if defined(STBI_REQUIRED)
    #####:  351:        if (fileData != NULL)
    %%%%%:  351-block  0
branch  0 never executed
branch  1 never executed
        -:  352:        {
    #####:  353:            int comp = 0;
    #####:  354:            image.data = stbi_loadf_from_memory(fileData, dataSize, &image.width, &image.height, &comp, 0);
    %%%%%:  354-block  0
call    0 never executed
        -:  355:
    #####:  356:            image.mipmaps = 1;
        -:  357:
    #####:  358:            if (comp == 1) image.format = PIXELFORMAT_UNCOMPRESSED_R32;
branch  0 never executed
branch  1 never executed
    %%%%%:  358-block  0
    #####:  359:            else if (comp == 3) image.format = PIXELFORMAT_UNCOMPRESSED_R32G32B32;
    %%%%%:  359-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  359-block  1
    #####:  360:            else if (comp == 4) image.format = PIXELFORMAT_UNCOMPRESSED_R32G32B32A32;
    %%%%%:  360-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  360-block  1
        -:  361:            else
        -:  362:            {
    #####:  363:                TRACELOG(LOG_WARNING, "IMAGE: HDR file format not supported");
    %%%%%:  363-block  0
call    0 never executed
    #####:  364:                UnloadImage(image);
call    0 never executed
        -:  365:            }
        -:  366:        }
        -:  367:#endif
        -:  368:    }
        -:  369:#endif
        -:  370:#if defined(SUPPORT_FILEFORMAT_DDS)
    #####:  371:    else if (TextIsEqual(fileExtLower, ".dds")) image = LoadDDS(fileData, dataSize);
    %%%%%:  371-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  371-block  1
call    3 never executed
        -:  372:#endif
        -:  373:#if defined(SUPPORT_FILEFORMAT_PKM)
        -:  374:    else if (TextIsEqual(fileExtLower, ".pkm")) image = LoadPKM(fileData, dataSize);
        -:  375:#endif
        -:  376:#if defined(SUPPORT_FILEFORMAT_KTX)
        -:  377:    else if (TextIsEqual(fileExtLower, ".ktx")) image = LoadKTX(fileData, dataSize);
        -:  378:#endif
        -:  379:#if defined(SUPPORT_FILEFORMAT_PVR)
        -:  380:    else if (TextIsEqual(fileExtLower, ".pvr")) image = LoadPVR(fileData, dataSize);
        -:  381:#endif
        -:  382:#if defined(SUPPORT_FILEFORMAT_ASTC)
        -:  383:    else if (TextIsEqual(fileExtLower, ".astc")) image = LoadASTC(fileData, dataSize);
        -:  384:#endif
    #####:  385:    else TRACELOG(LOG_WARNING, "IMAGE: Data format not supported");
    %%%%%:  385-block  0
call    0 never executed
        -:  386:
    #####:  387:    if (image.data != NULL) TRACELOG(LOG_INFO, "IMAGE: Data loaded successfully (%ix%i | %s | %i mipmaps)", image.width, image.height, rlGetPixelFormatName(image.format), image.mipmaps);
    %%%%%:  387-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  387-block  1
call    2 never executed
call    3 never executed
    #####:  388:    else TRACELOG(LOG_WARNING, "IMAGE: Failed to load image data");
    %%%%%:  388-block  0
call    0 never executed
        -:  389:
    #####:  390:    return image;
    %%%%%:  390-block  0
        -:  391:}
        -:  392:
        -:  393:// Load image from GPU texture data
        -:  394:// NOTE: Compressed texture formats not supported
function LoadImageFromTexture called 0 returned 0% blocks executed 0%
    #####:  395:Image LoadImageFromTexture(Texture2D texture)
        -:  396:{
    #####:  397:    Image image = { 0 };
        -:  398:
    #####:  399:    if (texture.format < PIXELFORMAT_COMPRESSED_DXT1_RGB)
    %%%%%:  399-block  0
branch  0 never executed
branch  1 never executed
        -:  400:    {
    #####:  401:        image.data = rlReadTexturePixels(texture.id, texture.width, texture.height, texture.format);
    %%%%%:  401-block  0
call    0 never executed
        -:  402:
    #####:  403:        if (image.data != NULL)
branch  0 never executed
branch  1 never executed
        -:  404:        {
    #####:  405:            image.width = texture.width;
    #####:  406:            image.height = texture.height;
    #####:  407:            image.format = texture.format;
    #####:  408:            image.mipmaps = 1;
        -:  409:
        -:  410:#if defined(GRAPHICS_API_OPENGL_ES2)
        -:  411:            // NOTE: Data retrieved on OpenGL ES 2.0 should be RGBA,
        -:  412:            // coming from FBO color buffer attachment, but it seems
        -:  413:            // original texture format is retrieved on RPI...
        -:  414:            image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -:  415:#endif
    #####:  416:            TRACELOG(LOG_INFO, "TEXTURE: [ID %i] Pixel data retrieved successfully", texture.id);
    %%%%%:  416-block  0
call    0 never executed
        -:  417:        }
    #####:  418:        else TRACELOG(LOG_WARNING, "TEXTURE: [ID %i] Failed to retrieve pixel data", texture.id);
    %%%%%:  418-block  0
call    0 never executed
        -:  419:    }
    #####:  420:    else TRACELOG(LOG_WARNING, "TEXTURE: [ID %i] Failed to retrieve compressed pixel data", texture.id);
    %%%%%:  420-block  0
call    0 never executed
        -:  421:
    #####:  422:    return image;
    %%%%%:  422-block  0
        -:  423:}
        -:  424:
        -:  425:// Load image from screen buffer and (screenshot)
function LoadImageFromScreen called 0 returned 0% blocks executed 0%
    #####:  426:Image LoadImageFromScreen(void)
        -:  427:{
    #####:  428:    Image image = { 0 };
        -:  429:
    #####:  430:    image.width = GetScreenWidth();
    %%%%%:  430-block  0
call    0 never executed
    #####:  431:    image.height = GetScreenHeight();
call    0 never executed
    #####:  432:    image.mipmaps = 1;
    #####:  433:    image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
    #####:  434:    image.data = rlReadScreenPixels(image.width, image.height);
call    0 never executed
        -:  435:
    #####:  436:    return image;
        -:  437:}
        -:  438:
        -:  439:// Unload image from CPU memory (RAM)
function UnloadImage called 225 returned 100% blocks executed 100%
      225:  440:void UnloadImage(Image image)
        -:  441:{
      225:  442:    RL_FREE(image.data);
      225:  443:}
        -:  444:
        -:  445:// Export image data to file
        -:  446:// NOTE: File format depends on fileName extension
function ExportImage called 0 returned 0% blocks executed 0%
    #####:  447:bool ExportImage(Image image, const char *fileName)
        -:  448:{
    #####:  449:    int success = 0;
        -:  450:
        -:  451:#if defined(SUPPORT_IMAGE_EXPORT)
    #####:  452:    int channels = 4;
    #####:  453:    bool allocatedData = false;
    #####:  454:    unsigned char *imgData = (unsigned char *)image.data;
        -:  455:
    #####:  456:    if (image.format == PIXELFORMAT_UNCOMPRESSED_GRAYSCALE) channels = 1;
    %%%%%:  456-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  456-block  1
    #####:  457:    else if (image.format == PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA) channels = 2;
    %%%%%:  457-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  457-block  1
    #####:  458:    else if (image.format == PIXELFORMAT_UNCOMPRESSED_R8G8B8) channels = 3;
    %%%%%:  458-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  458-block  1
    #####:  459:    else if (image.format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8) channels = 4;
    %%%%%:  459-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  459-block  1
        -:  460:    else
        -:  461:    {
        -:  462:        // NOTE: Getting Color array as RGBA unsigned char values
    #####:  463:        imgData = (unsigned char *)LoadImageColors(image);
    %%%%%:  463-block  0
call    0 never executed
    #####:  464:        allocatedData = true;
        -:  465:    }
        -:  466:
        -:  467:#if defined(SUPPORT_FILEFORMAT_PNG)
    #####:  468:    if (IsFileExtension(fileName, ".png"))
    %%%%%:  468-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  469:    {
    #####:  470:        int dataSize = 0;
    #####:  471:        unsigned char *fileData = stbi_write_png_to_mem((const unsigned char *)imgData, image.width*channels, image.width, image.height, channels, &dataSize);
    %%%%%:  471-block  0
call    0 never executed
    #####:  472:        success = SaveFileData(fileName, fileData, dataSize);
call    0 never executed
    #####:  473:        RL_FREE(fileData);
        -:  474:    }
        -:  475:#else
        -:  476:    if (false) { }
        -:  477:#endif
        -:  478:#if defined(SUPPORT_FILEFORMAT_BMP)
        -:  479:    else if (IsFileExtension(fileName, ".bmp")) success = stbi_write_bmp(fileName, image.width, image.height, channels, imgData);
        -:  480:#endif
        -:  481:#if defined(SUPPORT_FILEFORMAT_TGA)
        -:  482:    else if (IsFileExtension(fileName, ".tga")) success = stbi_write_tga(fileName, image.width, image.height, channels, imgData);
        -:  483:#endif
        -:  484:#if defined(SUPPORT_FILEFORMAT_JPG)
        -:  485:    else if (IsFileExtension(fileName, ".jpg")) success = stbi_write_jpg(fileName, image.width, image.height, channels, imgData, 90);  // JPG quality: between 1 and 100
        -:  486:#endif
        -:  487:#if defined(SUPPORT_FILEFORMAT_KTX)
        -:  488:    else if (IsFileExtension(fileName, ".ktx")) success = SaveKTX(image, fileName);
        -:  489:#endif
    #####:  490:    else if (IsFileExtension(fileName, ".raw"))
    %%%%%:  490-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  491:    {
        -:  492:        // Export raw pixel data (without header)
        -:  493:        // NOTE: It's up to the user to track image parameters
    #####:  494:        success = SaveFileData(fileName, image.data, GetPixelDataSize(image.width, image.height, image.format));
    %%%%%:  494-block  0
call    0 never executed
call    1 never executed
        -:  495:    }
        -:  496:
    #####:  497:    if (allocatedData) RL_FREE(imgData);
    %%%%%:  497-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  497-block  1
        -:  498:#endif      // SUPPORT_IMAGE_EXPORT
        -:  499:
    #####:  500:    if (success != 0) TRACELOG(LOG_INFO, "FILEIO: [%s] Image exported successfully", fileName);
    %%%%%:  500-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  500-block  1
call    2 never executed
    #####:  501:    else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to export image", fileName);
    %%%%%:  501-block  0
call    0 never executed
        -:  502:
    #####:  503:    return success;
    %%%%%:  503-block  0
        -:  504:}
        -:  505:
        -:  506:// Export image as code file (.h) defining an array of bytes
function ExportImageAsCode called 0 returned 0% blocks executed 0%
    #####:  507:bool ExportImageAsCode(Image image, const char *fileName)
        -:  508:{
    #####:  509:    bool success = false;
        -:  510:
        -:  511:#if defined(SUPPORT_IMAGE_EXPORT)
        -:  512:
        -:  513:#ifndef TEXT_BYTES_PER_LINE
        -:  514:    #define TEXT_BYTES_PER_LINE     20
        -:  515:#endif
        -:  516:
    #####:  517:    int dataSize = GetPixelDataSize(image.width, image.height, image.format);
    %%%%%:  517-block  0
call    0 never executed
        -:  518:
        -:  519:    // NOTE: Text data buffer size is estimated considering image data size in bytes
        -:  520:    // and requiring 6 char bytes for every byte: "0x00, "
    #####:  521:    char *txtData = (char *)RL_CALLOC(dataSize*6 + 2000, sizeof(char));
        -:  522:
    #####:  523:    int byteCount = 0;
    #####:  524:    byteCount += sprintf(txtData + byteCount, "////////////////////////////////////////////////////////////////////////////////////////\n");
call    0 never executed
    #####:  525:    byteCount += sprintf(txtData + byteCount, "//                                                                                    //\n");
call    0 never executed
    #####:  526:    byteCount += sprintf(txtData + byteCount, "// ImageAsCode exporter v1.0 - Image pixel data exported as an array of bytes         //\n");
call    0 never executed
    #####:  527:    byteCount += sprintf(txtData + byteCount, "//                                                                                    //\n");
call    0 never executed
    #####:  528:    byteCount += sprintf(txtData + byteCount, "// more info and bugs-report:  github.com/raysan5/raylib                              //\n");
call    0 never executed
    #####:  529:    byteCount += sprintf(txtData + byteCount, "// feedback and support:       ray[at]raylib.com                                      //\n");
call    0 never executed
    #####:  530:    byteCount += sprintf(txtData + byteCount, "//                                                                                    //\n");
call    0 never executed
    #####:  531:    byteCount += sprintf(txtData + byteCount, "// Copyright (c) 2018-2021 Ramon Santamaria (@raysan5)                                //\n");
call    0 never executed
    #####:  532:    byteCount += sprintf(txtData + byteCount, "//                                                                                    //\n");
call    0 never executed
    #####:  533:    byteCount += sprintf(txtData + byteCount, "////////////////////////////////////////////////////////////////////////////////////////\n\n");
call    0 never executed
        -:  534:
        -:  535:    // Get file name from path and convert variable name to uppercase
    #####:  536:    char varFileName[256] = { 0 };
    #####:  537:    strcpy(varFileName, GetFileNameWithoutExt(fileName));
call    0 never executed
    #####:  538:    for (int i = 0; varFileName[i] != '\0'; i++) if ((varFileName[i] >= 'a') && (varFileName[i] <= 'z')) { varFileName[i] = varFileName[i] - 32; }
    %%%%%:  538-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  538-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  538-block  2
    %%%%%:  538-block  3
    %%%%%:  538-block  4
branch  4 never executed
branch  5 never executed
        -:  539:
        -:  540:    // Add image information
    #####:  541:    byteCount += sprintf(txtData + byteCount, "// Image data information\n");
    %%%%%:  541-block  0
call    0 never executed
    #####:  542:    byteCount += sprintf(txtData + byteCount, "#define %s_WIDTH    %i\n", varFileName, image.width);
call    0 never executed
    #####:  543:    byteCount += sprintf(txtData + byteCount, "#define %s_HEIGHT   %i\n", varFileName, image.height);
call    0 never executed
    #####:  544:    byteCount += sprintf(txtData + byteCount, "#define %s_FORMAT   %i          // raylib internal pixel format\n\n", varFileName, image.format);
call    0 never executed
        -:  545:
    #####:  546:    byteCount += sprintf(txtData + byteCount, "static unsigned char %s_DATA[%i] = { ", varFileName, dataSize);
call    0 never executed
    #####:  547:    for (int i = 0; i < dataSize - 1; i++) byteCount += sprintf(txtData + byteCount, ((i%TEXT_BYTES_PER_LINE == 0)? "0x%x,\n" : "0x%x, "), ((unsigned char *)image.data)[i]);
    %%%%%:  547-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  547-block  1
    %%%%%:  547-block  2
    %%%%%:  547-block  3
call    2 never executed
    %%%%%:  547-block  4
branch  3 never executed
branch  4 never executed
    #####:  548:    byteCount += sprintf(txtData + byteCount, "0x%x };\n", ((unsigned char *)image.data)[dataSize - 1]);
    %%%%%:  548-block  0
call    0 never executed
        -:  549:
        -:  550:    // NOTE: Text data size exported is determined by '\0' (NULL) character
    #####:  551:    success = SaveFileText(fileName, txtData);
call    0 never executed
        -:  552:
    #####:  553:    RL_FREE(txtData);
        -:  554:
        -:  555:#endif      // SUPPORT_IMAGE_EXPORT
        -:  556:
    #####:  557:    if (success != 0) TRACELOG(LOG_INFO, "FILEIO: [%s] Image exported successfully", fileName);
branch  0 never executed
branch  1 never executed
    %%%%%:  557-block  0
call    2 never executed
    #####:  558:    else TRACELOG(LOG_WARNING, "FILEIO: [%s] Failed to export image", fileName);
    %%%%%:  558-block  0
call    0 never executed
        -:  559:
    #####:  560:    return success;
    %%%%%:  560-block  0
        -:  561:}
        -:  562:
        -:  563://------------------------------------------------------------------------------------
        -:  564:// Image generation functions
        -:  565://------------------------------------------------------------------------------------
        -:  566:// Generate image: plain color
function GenImageColor called 0 returned 0% blocks executed 0%
    #####:  567:Image GenImageColor(int width, int height, Color color)
        -:  568:{
    #####:  569:    Color *pixels = (Color *)RL_CALLOC(width*height, sizeof(Color));
        -:  570:
    #####:  571:    for (int i = 0; i < width*height; i++) pixels[i] = color;
    %%%%%:  571-block  0
    %%%%%:  571-block  1
    %%%%%:  571-block  2
branch  0 never executed
branch  1 never executed
        -:  572:
    #####:  573:    Image image = {
        -:  574:        .data = pixels,
        -:  575:        .width = width,
        -:  576:        .height = height,
        -:  577:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  578:        .mipmaps = 1
        -:  579:    };
        -:  580:
    #####:  581:    return image;
    %%%%%:  581-block  0
        -:  582:}
        -:  583:
        -:  584:#if defined(SUPPORT_IMAGE_GENERATION)
        -:  585:// Generate image: vertical gradient
function GenImageGradientV called 0 returned 0% blocks executed 0%
    #####:  586:Image GenImageGradientV(int width, int height, Color top, Color bottom)
        -:  587:{
    #####:  588:    Color *pixels = (Color *)RL_MALLOC(width*height*sizeof(Color));
        -:  589:
    #####:  590:    for (int j = 0; j < height; j++)
    %%%%%:  590-block  0
    %%%%%:  590-block  1
    %%%%%:  590-block  2
branch  0 never executed
branch  1 never executed
        -:  591:    {
    #####:  592:        float factor = (float)j/(float)height;
    #####:  593:        for (int i = 0; i < width; i++)
    %%%%%:  593-block  0
    %%%%%:  593-block  1
branch  0 never executed
branch  1 never executed
        -:  594:        {
    #####:  595:            pixels[j*width + i].r = (int)((float)bottom.r*factor + (float)top.r*(1.f - factor));
    #####:  596:            pixels[j*width + i].g = (int)((float)bottom.g*factor + (float)top.g*(1.f - factor));
    #####:  597:            pixels[j*width + i].b = (int)((float)bottom.b*factor + (float)top.b*(1.f - factor));
    #####:  598:            pixels[j*width + i].a = (int)((float)bottom.a*factor + (float)top.a*(1.f - factor));
    %%%%%:  598-block  0
        -:  599:        }
        -:  600:    }
        -:  601:
    #####:  602:    Image image = {
        -:  603:        .data = pixels,
        -:  604:        .width = width,
        -:  605:        .height = height,
        -:  606:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  607:        .mipmaps = 1
        -:  608:    };
        -:  609:
    #####:  610:    return image;
    %%%%%:  610-block  0
        -:  611:}
        -:  612:
        -:  613:// Generate image: horizontal gradient
function GenImageGradientH called 0 returned 0% blocks executed 0%
    #####:  614:Image GenImageGradientH(int width, int height, Color left, Color right)
        -:  615:{
    #####:  616:    Color *pixels = (Color *)RL_MALLOC(width*height*sizeof(Color));
        -:  617:
    #####:  618:    for (int i = 0; i < width; i++)
    %%%%%:  618-block  0
    %%%%%:  618-block  1
    %%%%%:  618-block  2
branch  0 never executed
branch  1 never executed
        -:  619:    {
    #####:  620:        float factor = (float)i/(float)width;
    #####:  621:        for (int j = 0; j < height; j++)
    %%%%%:  621-block  0
    %%%%%:  621-block  1
branch  0 never executed
branch  1 never executed
        -:  622:        {
    #####:  623:            pixels[j*width + i].r = (int)((float)right.r*factor + (float)left.r*(1.f - factor));
    #####:  624:            pixels[j*width + i].g = (int)((float)right.g*factor + (float)left.g*(1.f - factor));
    #####:  625:            pixels[j*width + i].b = (int)((float)right.b*factor + (float)left.b*(1.f - factor));
    #####:  626:            pixels[j*width + i].a = (int)((float)right.a*factor + (float)left.a*(1.f - factor));
    %%%%%:  626-block  0
        -:  627:        }
        -:  628:    }
        -:  629:
    #####:  630:    Image image = {
        -:  631:        .data = pixels,
        -:  632:        .width = width,
        -:  633:        .height = height,
        -:  634:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  635:        .mipmaps = 1
        -:  636:    };
        -:  637:
    #####:  638:    return image;
    %%%%%:  638-block  0
        -:  639:}
        -:  640:
        -:  641:// Generate image: radial gradient
function GenImageGradientRadial called 0 returned 0% blocks executed 0%
    #####:  642:Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer)
        -:  643:{
    #####:  644:    Color *pixels = (Color *)RL_MALLOC(width*height*sizeof(Color));
    #####:  645:    float radius = (width < height)? (float)width/2.0f : (float)height/2.0f;
    %%%%%:  645-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  645-block  1
    %%%%%:  645-block  2
        -:  646:
    #####:  647:    float centerX = (float)width/2.0f;
    #####:  648:    float centerY = (float)height/2.0f;
        -:  649:
    #####:  650:    for (int y = 0; y < height; y++)
    %%%%%:  650-block  0
    %%%%%:  650-block  1
    %%%%%:  650-block  2
branch  0 never executed
branch  1 never executed
        -:  651:    {
    #####:  652:        for (int x = 0; x < width; x++)
    %%%%%:  652-block  0
    %%%%%:  652-block  1
branch  0 never executed
branch  1 never executed
        -:  653:        {
    #####:  654:            float dist = hypotf((float)x - centerX, (float)y - centerY);
    #####:  655:            float factor = (dist - radius*density)/(radius*(1.0f - density));
        -:  656:
    #####:  657:            factor = (float)fmax(factor, 0.0f);
    #####:  658:            factor = (float)fmin(factor, 1.f); // dist can be bigger than radius so we have to check
        -:  659:
    #####:  660:            pixels[y*width + x].r = (int)((float)outer.r*factor + (float)inner.r*(1.0f - factor));
    #####:  661:            pixels[y*width + x].g = (int)((float)outer.g*factor + (float)inner.g*(1.0f - factor));
    #####:  662:            pixels[y*width + x].b = (int)((float)outer.b*factor + (float)inner.b*(1.0f - factor));
    #####:  663:            pixels[y*width + x].a = (int)((float)outer.a*factor + (float)inner.a*(1.0f - factor));
    %%%%%:  663-block  0
        -:  664:        }
        -:  665:    }
        -:  666:
    #####:  667:    Image image = {
        -:  668:        .data = pixels,
        -:  669:        .width = width,
        -:  670:        .height = height,
        -:  671:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  672:        .mipmaps = 1
        -:  673:    };
        -:  674:
    #####:  675:    return image;
    %%%%%:  675-block  0
        -:  676:}
        -:  677:
        -:  678:// Generate image: checked
function GenImageChecked called 0 returned 0% blocks executed 0%
    #####:  679:Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2)
        -:  680:{
    #####:  681:    Color *pixels = (Color *)RL_MALLOC(width*height*sizeof(Color));
        -:  682:
    #####:  683:    for (int y = 0; y < height; y++)
    %%%%%:  683-block  0
    %%%%%:  683-block  1
    %%%%%:  683-block  2
branch  0 never executed
branch  1 never executed
        -:  684:    {
    #####:  685:        for (int x = 0; x < width; x++)
    %%%%%:  685-block  0
    %%%%%:  685-block  1
    %%%%%:  685-block  2
branch  0 never executed
branch  1 never executed
        -:  686:        {
    #####:  687:            if ((x/checksX + y/checksY)%2 == 0) pixels[y*width + x] = col1;
    %%%%%:  687-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  687-block  1
    #####:  688:            else pixels[y*width + x] = col2;
    %%%%%:  688-block  0
        -:  689:        }
        -:  690:    }
        -:  691:
    #####:  692:    Image image = {
        -:  693:        .data = pixels,
        -:  694:        .width = width,
        -:  695:        .height = height,
        -:  696:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  697:        .mipmaps = 1
        -:  698:    };
        -:  699:
    #####:  700:    return image;
    %%%%%:  700-block  0
        -:  701:}
        -:  702:
        -:  703:// Generate image: white noise
function GenImageWhiteNoise called 0 returned 0% blocks executed 0%
    #####:  704:Image GenImageWhiteNoise(int width, int height, float factor)
        -:  705:{
    #####:  706:    Color *pixels = (Color *)RL_MALLOC(width*height*sizeof(Color));
        -:  707:
    #####:  708:    for (int i = 0; i < width*height; i++)
    %%%%%:  708-block  0
    %%%%%:  708-block  1
    %%%%%:  708-block  2
branch  0 never executed
branch  1 never executed
        -:  709:    {
    #####:  710:        if (GetRandomValue(0, 99) < (int)(factor*100.0f)) pixels[i] = WHITE;
    %%%%%:  710-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  710-block  1
    #####:  711:        else pixels[i] = BLACK;
    %%%%%:  711-block  0
        -:  712:    }
        -:  713:
    #####:  714:    Image image = {
        -:  715:        .data = pixels,
        -:  716:        .width = width,
        -:  717:        .height = height,
        -:  718:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  719:        .mipmaps = 1
        -:  720:    };
        -:  721:
    #####:  722:    return image;
    %%%%%:  722-block  0
        -:  723:}
        -:  724:
        -:  725:// Generate image: perlin noise
function GenImagePerlinNoise called 0 returned 0% blocks executed 0%
    #####:  726:Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale)
        -:  727:{
    #####:  728:    Color *pixels = (Color *)RL_MALLOC(width*height*sizeof(Color));
        -:  729:
    #####:  730:    for (int y = 0; y < height; y++)
    %%%%%:  730-block  0
    %%%%%:  730-block  1
    %%%%%:  730-block  2
branch  0 never executed
branch  1 never executed
        -:  731:    {
    #####:  732:        for (int x = 0; x < width; x++)
    %%%%%:  732-block  0
    %%%%%:  732-block  1
branch  0 never executed
branch  1 never executed
        -:  733:        {
    #####:  734:            float nx = (float)(x + offsetX)*scale/(float)width;
    #####:  735:            float ny = (float)(y + offsetY)*scale/(float)height;
        -:  736:
        -:  737:            // Typical values to start playing with:
        -:  738:            //   lacunarity = ~2.0   -- spacing between successive octaves (use exactly 2.0 for wrapping output)
        -:  739:            //   gain       =  0.5   -- relative weighting applied to each successive octave
        -:  740:            //   octaves    =  6     -- number of "octaves" of noise3() to sum
        -:  741:
        -:  742:            // NOTE: We need to translate the data from [-1..1] to [0..1]
    #####:  743:            float p = (stb_perlin_fbm_noise3(nx, ny, 1.0f, 2.0f, 0.5f, 6) + 1.0f)/2.0f;
    %%%%%:  743-block  0
call    0 never executed
        -:  744:
    #####:  745:            int intensity = (int)(p*255.0f);
    #####:  746:            pixels[y*width + x] = (Color){intensity, intensity, intensity, 255};
        -:  747:        }
        -:  748:    }
        -:  749:
    #####:  750:    Image image = {
        -:  751:        .data = pixels,
        -:  752:        .width = width,
        -:  753:        .height = height,
        -:  754:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  755:        .mipmaps = 1
        -:  756:    };
        -:  757:
    #####:  758:    return image;
    %%%%%:  758-block  0
        -:  759:}
        -:  760:
        -:  761:// Generate image: cellular algorithm. Bigger tileSize means bigger cells
function GenImageCellular called 0 returned 0% blocks executed 0%
    #####:  762:Image GenImageCellular(int width, int height, int tileSize)
        -:  763:{
    #####:  764:    Color *pixels = (Color *)RL_MALLOC(width*height*sizeof(Color));
        -:  765:
    #####:  766:    int seedsPerRow = width/tileSize;
    #####:  767:    int seedsPerCol = height/tileSize;
    #####:  768:    int seedCount = seedsPerRow*seedsPerCol;
        -:  769:
    #####:  770:    Vector2 *seeds = (Vector2 *)RL_MALLOC(seedCount*sizeof(Vector2));
        -:  771:
    #####:  772:    for (int i = 0; i < seedCount; i++)
    %%%%%:  772-block  0
    %%%%%:  772-block  1
branch  0 never executed
branch  1 never executed
        -:  773:    {
    #####:  774:        int y = (i/seedsPerRow)*tileSize + GetRandomValue(0, tileSize - 1);
    %%%%%:  774-block  0
call    0 never executed
    #####:  775:        int x = (i%seedsPerRow)*tileSize + GetRandomValue(0, tileSize - 1);
call    0 never executed
    #####:  776:        seeds[i] = (Vector2){ (float)x, (float)y};
        -:  777:    }
        -:  778:
    #####:  779:    for (int y = 0; y < height; y++)
    %%%%%:  779-block  0
    %%%%%:  779-block  1
    %%%%%:  779-block  2
branch  0 never executed
branch  1 never executed
        -:  780:    {
    #####:  781:        int tileY = y/tileSize;
        -:  782:
    #####:  783:        for (int x = 0; x < width; x++)
    %%%%%:  783-block  0
    %%%%%:  783-block  1
branch  0 never executed
branch  1 never executed
        -:  784:        {
    #####:  785:            int tileX = x/tileSize;
        -:  786:
    #####:  787:            float minDistance = (float)strtod("Inf", NULL);
    %%%%%:  787-block  0
call    0 never executed
        -:  788:
        -:  789:            // Check all adjacent tiles
    #####:  790:            for (int i = -1; i < 2; i++)
    %%%%%:  790-block  0
    %%%%%:  790-block  1
branch  0 never executed
branch  1 never executed
        -:  791:            {
    #####:  792:                if ((tileX + i < 0) || (tileX + i >= seedsPerRow)) continue;
    %%%%%:  792-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  792-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  792-block  2
        -:  793:
    #####:  794:                for (int j = -1; j < 2; j++)
    %%%%%:  794-block  0
    %%%%%:  794-block  1
    %%%%%:  794-block  2
branch  0 never executed
branch  1 never executed
        -:  795:                {
    #####:  796:                    if ((tileY + j < 0) || (tileY + j >= seedsPerCol)) continue;
    %%%%%:  796-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  796-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  796-block  2
        -:  797:
    #####:  798:                    Vector2 neighborSeed = seeds[(tileY + j)*seedsPerRow + tileX + i];
        -:  799:
    #####:  800:                    float dist = (float)hypot(x - (int)neighborSeed.x, y - (int)neighborSeed.y);
    #####:  801:                    minDistance = (float)fmin(minDistance, dist);
    %%%%%:  801-block  0
        -:  802:                }
        -:  803:            }
        -:  804:
        -:  805:            // I made this up but it seems to give good results at all tile sizes
    #####:  806:            int intensity = (int)(minDistance*256.0f/tileSize);
    #####:  807:            if (intensity > 255) intensity = 255;
    %%%%%:  807-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  807-block  1
        -:  808:
    #####:  809:            pixels[y*width + x] = (Color){ intensity, intensity, intensity, 255 };
    %%%%%:  809-block  0
        -:  810:        }
        -:  811:    }
        -:  812:
    #####:  813:    RL_FREE(seeds);
        -:  814:
    #####:  815:    Image image = {
        -:  816:        .data = pixels,
        -:  817:        .width = width,
        -:  818:        .height = height,
        -:  819:        .format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
        -:  820:        .mipmaps = 1
        -:  821:    };
        -:  822:
    #####:  823:    return image;
    %%%%%:  823-block  0
        -:  824:}
        -:  825:#endif      // SUPPORT_IMAGE_GENERATION
        -:  826:
        -:  827://------------------------------------------------------------------------------------
        -:  828:// Image manipulation functions
        -:  829://------------------------------------------------------------------------------------
        -:  830:// Copy an image to a new image
function ImageCopy called 0 returned 0% blocks executed 0%
    #####:  831:Image ImageCopy(Image image)
        -:  832:{
    #####:  833:    Image newImage = { 0 };
        -:  834:
    #####:  835:    int width = image.width;
    #####:  836:    int height = image.height;
    #####:  837:    int size = 0;
        -:  838:
    #####:  839:    for (int i = 0; i < image.mipmaps; i++)
    %%%%%:  839-block  0
    %%%%%:  839-block  1
    %%%%%:  839-block  2
branch  0 never executed
branch  1 never executed
        -:  840:    {
    #####:  841:        size += GetPixelDataSize(width, height, image.format);
    %%%%%:  841-block  0
call    0 never executed
        -:  842:
    #####:  843:        width /= 2;
    #####:  844:        height /= 2;
        -:  845:
        -:  846:        // Security check for NPOT textures
    #####:  847:        if (width < 1) width = 1;
branch  0 never executed
branch  1 never executed
    %%%%%:  847-block  0
    #####:  848:        if (height < 1) height = 1;
    %%%%%:  848-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  848-block  1
        -:  849:    }
        -:  850:
    #####:  851:    newImage.data = RL_MALLOC(size);
        -:  852:
    #####:  853:    if (newImage.data != NULL)
    %%%%%:  853-block  0
branch  0 never executed
branch  1 never executed
        -:  854:    {
        -:  855:        // NOTE: Size must be provided in bytes
    #####:  856:        memcpy(newImage.data, image.data, size);
        -:  857:
    #####:  858:        newImage.width = image.width;
    #####:  859:        newImage.height = image.height;
    #####:  860:        newImage.mipmaps = image.mipmaps;
    #####:  861:        newImage.format = image.format;
    %%%%%:  861-block  0
        -:  862:    }
        -:  863:
    #####:  864:    return newImage;
    %%%%%:  864-block  0
        -:  865:}
        -:  866:
        -:  867:// Create an image from another image piece
function ImageFromImage called 224 returned 100% blocks executed 100%
      224:  868:Image ImageFromImage(Image image, Rectangle rec)
        -:  869:{
      224:  870:    Image result = { 0 };
        -:  871:
      224:  872:    int bytesPerPixel = GetPixelDataSize(1, 1, image.format);
      224:  872-block  0
call    0 returned 224
        -:  873:
        -:  874:    // TODO: Check rec is valid?
        -:  875:
      224:  876:    result.width = (int)rec.width;
      224:  877:    result.height = (int)rec.height;
      224:  878:    result.data = RL_CALLOC((int)(rec.width*rec.height)*bytesPerPixel, 1);
      224:  879:    result.format = image.format;
      224:  880:    result.mipmaps = 1;
        -:  881:
     2464:  882:    for (int y = 0; y < rec.height; y++)
     2464:  882-block  0
branch  0 taken 2240
branch  1 taken 224 (fallthrough)
        -:  883:    {
     2240:  884:        memcpy(((unsigned char *)result.data) + y*(int)rec.width*bytesPerPixel, ((unsigned char *)image.data) + ((y + (int)rec.y)*image.width + (int)rec.x)*bytesPerPixel, (int)rec.width*bytesPerPixel);
     2240:  884-block  0
        -:  885:    }
        -:  886:
      224:  887:    return result;
      224:  887-block  0
        -:  888:}
        -:  889:
        -:  890:// Crop an image to area defined by a rectangle
        -:  891:// NOTE: Security checks are performed in case rectangle goes out of bounds
function ImageCrop called 0 returned 0% blocks executed 0%
    #####:  892:void ImageCrop(Image *image, Rectangle crop)
        -:  893:{
        -:  894:    // Security check to avoid program crash
    #####:  895:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%:  895-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  895-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  895-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  895-block  3
        -:  896:
        -:  897:    // Security checks to validate crop rectangle
    #####:  898:    if (crop.x < 0) { crop.width += crop.x; crop.x = 0; }
    %%%%%:  898-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  898-block  1
    #####:  899:    if (crop.y < 0) { crop.height += crop.y; crop.y = 0; }
    %%%%%:  899-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  899-block  1
    #####:  900:    if ((crop.x + crop.width) > image->width) crop.width = image->width - crop.x;
    %%%%%:  900-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  900-block  1
    #####:  901:    if ((crop.y + crop.height) > image->height) crop.height = image->height - crop.y;
    %%%%%:  901-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  901-block  1
    #####:  902:    if ((crop.x > image->width) || (crop.y > image->height))
    %%%%%:  902-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  902-block  1
branch  2 never executed
branch  3 never executed
        -:  903:    {
    #####:  904:        TRACELOG(LOG_WARNING, "IMAGE: Failed to crop, rectangle out of bounds");
    %%%%%:  904-block  0
call    0 never executed
    #####:  905:        return;
        -:  906:    }
        -:  907:
    #####:  908:    if (image->mipmaps > 1) TRACELOG(LOG_WARNING, "Image manipulation only applied to base mipmap level");
    %%%%%:  908-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  908-block  1
call    2 never executed
    #####:  909:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image manipulation not supported for compressed formats");
    %%%%%:  909-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  909-block  1
call    2 never executed
        -:  910:    else
        -:  911:    {
    #####:  912:        int bytesPerPixel = GetPixelDataSize(1, 1, image->format);
    %%%%%:  912-block  0
call    0 never executed
        -:  913:
    #####:  914:        unsigned char *croppedData = (unsigned char *)RL_MALLOC((int)(crop.width*crop.height)*bytesPerPixel);
        -:  915:
        -:  916:        // OPTION 1: Move cropped data line-by-line
    #####:  917:        for (int y = (int)crop.y, offsetSize = 0; y < (int)(crop.y + crop.height); y++)
    %%%%%:  917-block  0
branch  0 never executed
branch  1 never executed
        -:  918:        {
    #####:  919:            memcpy(croppedData + offsetSize, ((unsigned char *)image->data) + (y*image->width + (int)crop.x)*bytesPerPixel, (int)crop.width*bytesPerPixel);
    #####:  920:            offsetSize += ((int)crop.width*bytesPerPixel);
    %%%%%:  920-block  0
        -:  921:        }
        -:  922:
        -:  923:        /*
        -:  924:        // OPTION 2: Move cropped data pixel-by-pixel or byte-by-byte
        -:  925:        for (int y = (int)crop.y; y < (int)(crop.y + crop.height); y++)
        -:  926:        {
        -:  927:            for (int x = (int)crop.x; x < (int)(crop.x + crop.width); x++)
        -:  928:            {
        -:  929:                //memcpy(croppedData + ((y - (int)crop.y)*(int)crop.width + (x - (int)crop.x))*bytesPerPixel, ((unsigned char *)image->data) + (y*image->width + x)*bytesPerPixel, bytesPerPixel);
        -:  930:                for (int i = 0; i < bytesPerPixel; i++) croppedData[((y - (int)crop.y)*(int)crop.width + (x - (int)crop.x))*bytesPerPixel + i] = ((unsigned char *)image->data)[(y*image->width + x)*bytesPerPixel + i];
        -:  931:            }
        -:  932:        }
        -:  933:        */
        -:  934:
    #####:  935:        RL_FREE(image->data);
    #####:  936:        image->data = croppedData;
    #####:  937:        image->width = (int)crop.width;
    #####:  938:        image->height = (int)crop.height;
    %%%%%:  938-block  0
        -:  939:    }
        -:  940:}
        -:  941:
        -:  942:// Convert image data to desired format
function ImageFormat called 0 returned 0% blocks executed 0%
    #####:  943:void ImageFormat(Image *image, int newFormat)
        -:  944:{
        -:  945:    // Security check to avoid program crash
    #####:  946:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%:  946-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  946-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  946-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  946-block  3
        -:  947:
    #####:  948:    if ((newFormat != 0) && (image->format != newFormat))
    %%%%%:  948-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  948-block  1
branch  2 never executed
branch  3 never executed
        -:  949:    {
    #####:  950:        if ((image->format < PIXELFORMAT_COMPRESSED_DXT1_RGB) && (newFormat < PIXELFORMAT_COMPRESSED_DXT1_RGB))
    %%%%%:  950-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  950-block  1
branch  2 never executed
branch  3 never executed
    #####:  951:        {
    %%%%%:  951-block  0
    #####:  952:            Vector4 *pixels = LoadImageDataNormalized(*image);     // Supports 8 to 32 bit per channel
    %%%%%:  952-block  0
call    0 never executed
        -:  953:
    #####:  954:            RL_FREE(image->data);      // WARNING! We loose mipmaps data --> Regenerated at the end...
    #####:  955:            image->data = NULL;
    #####:  956:            image->format = newFormat;
        -:  957:
    #####:  958:            int k = 0;
        -:  959:
    #####:  960:            switch (image->format)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -:  961:            {
    #####:  962:                case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE:
        -:  963:                {
    #####:  964:                    image->data = (unsigned char *)RL_MALLOC(image->width*image->height*sizeof(unsigned char));
        -:  965:
    #####:  966:                    for (int i = 0; i < image->width*image->height; i++)
    %%%%%:  966-block  0
    %%%%%:  966-block  1
branch  0 never executed
branch  1 never executed
        -:  967:                    {
    #####:  968:                        ((unsigned char *)image->data)[i] = (unsigned char)((pixels[i].x*0.299f + pixels[i].y*0.587f + pixels[i].z*0.114f)*255.0f);
    %%%%%:  968-block  0
        -:  969:                    }
        -:  970:
    #####:  971:                } break;
    %%%%%:  971-block  0
    #####:  972:                case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -:  973:                {
    #####:  974:                    image->data = (unsigned char *)RL_MALLOC(image->width*image->height*2*sizeof(unsigned char));
        -:  975:
    #####:  976:                    for (int i = 0; i < image->width*image->height*2; i += 2, k++)
    %%%%%:  976-block  0
    %%%%%:  976-block  1
branch  0 never executed
branch  1 never executed
        -:  977:                    {
    #####:  978:                        ((unsigned char *)image->data)[i] = (unsigned char)((pixels[k].x*0.299f + (float)pixels[k].y*0.587f + (float)pixels[k].z*0.114f)*255.0f);
    #####:  979:                        ((unsigned char *)image->data)[i + 1] = (unsigned char)(pixels[k].w*255.0f);
    %%%%%:  979-block  0
        -:  980:                    }
        -:  981:
    #####:  982:                } break;
    %%%%%:  982-block  0
    #####:  983:                case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -:  984:                {
    #####:  985:                    image->data = (unsigned short *)RL_MALLOC(image->width*image->height*sizeof(unsigned short));
        -:  986:
    #####:  987:                    unsigned char r = 0;
    #####:  988:                    unsigned char g = 0;
    #####:  989:                    unsigned char b = 0;
        -:  990:
    #####:  991:                    for (int i = 0; i < image->width*image->height; i++)
    %%%%%:  991-block  0
    %%%%%:  991-block  1
branch  0 never executed
branch  1 never executed
        -:  992:                    {
    #####:  993:                        r = (unsigned char)(round(pixels[i].x*31.0f));
    #####:  994:                        g = (unsigned char)(round(pixels[i].y*63.0f));
    #####:  995:                        b = (unsigned char)(round(pixels[i].z*31.0f));
        -:  996:
    #####:  997:                        ((unsigned short *)image->data)[i] = (unsigned short)r << 11 | (unsigned short)g << 5 | (unsigned short)b;
    %%%%%:  997-block  0
        -:  998:                    }
        -:  999:
    #####: 1000:                } break;
    %%%%%: 1000-block  0
    #####: 1001:                case PIXELFORMAT_UNCOMPRESSED_R8G8B8:
        -: 1002:                {
    #####: 1003:                    image->data = (unsigned char *)RL_MALLOC(image->width*image->height*3*sizeof(unsigned char));
        -: 1004:
    #####: 1005:                    for (int i = 0, k = 0; i < image->width*image->height*3; i += 3, k++)
    %%%%%: 1005-block  0
    %%%%%: 1005-block  1
branch  0 never executed
branch  1 never executed
        -: 1006:                    {
    #####: 1007:                        ((unsigned char *)image->data)[i] = (unsigned char)(pixels[k].x*255.0f);
    #####: 1008:                        ((unsigned char *)image->data)[i + 1] = (unsigned char)(pixels[k].y*255.0f);
    #####: 1009:                        ((unsigned char *)image->data)[i + 2] = (unsigned char)(pixels[k].z*255.0f);
    %%%%%: 1009-block  0
        -: 1010:                    }
    #####: 1011:                } break;
    %%%%%: 1011-block  0
    #####: 1012:                case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 1013:                {
    #####: 1014:                    image->data = (unsigned short *)RL_MALLOC(image->width*image->height*sizeof(unsigned short));
        -: 1015:
    #####: 1016:                    unsigned char r = 0;
    #####: 1017:                    unsigned char g = 0;
    #####: 1018:                    unsigned char b = 0;
    #####: 1019:                    unsigned char a = 0;
        -: 1020:
    #####: 1021:                    for (int i = 0; i < image->width*image->height; i++)
    %%%%%: 1021-block  0
    %%%%%: 1021-block  1
branch  0 never executed
branch  1 never executed
        -: 1022:                    {
    #####: 1023:                        r = (unsigned char)(round(pixels[i].x*31.0f));
    #####: 1024:                        g = (unsigned char)(round(pixels[i].y*31.0f));
    #####: 1025:                        b = (unsigned char)(round(pixels[i].z*31.0f));
    #####: 1026:                        a = (pixels[i].w > ((float)PIXELFORMAT_UNCOMPRESSED_R5G5B5A1_ALPHA_THRESHOLD/255.0f))? 1 : 0;
        -: 1027:
    #####: 1028:                        ((unsigned short *)image->data)[i] = (unsigned short)r << 11 | (unsigned short)g << 6 | (unsigned short)b << 1 | (unsigned short)a;
    %%%%%: 1028-block  0
        -: 1029:                    }
        -: 1030:
    #####: 1031:                } break;
    %%%%%: 1031-block  0
    #####: 1032:                case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4:
        -: 1033:                {
    #####: 1034:                    image->data = (unsigned short *)RL_MALLOC(image->width*image->height*sizeof(unsigned short));
        -: 1035:
    #####: 1036:                    unsigned char r = 0;
    #####: 1037:                    unsigned char g = 0;
    #####: 1038:                    unsigned char b = 0;
    #####: 1039:                    unsigned char a = 0;
        -: 1040:
    #####: 1041:                    for (int i = 0; i < image->width*image->height; i++)
    %%%%%: 1041-block  0
    %%%%%: 1041-block  1
branch  0 never executed
branch  1 never executed
        -: 1042:                    {
    #####: 1043:                        r = (unsigned char)(round(pixels[i].x*15.0f));
    #####: 1044:                        g = (unsigned char)(round(pixels[i].y*15.0f));
    #####: 1045:                        b = (unsigned char)(round(pixels[i].z*15.0f));
    #####: 1046:                        a = (unsigned char)(round(pixels[i].w*15.0f));
        -: 1047:
    #####: 1048:                        ((unsigned short *)image->data)[i] = (unsigned short)r << 12 | (unsigned short)g << 8 | (unsigned short)b << 4 | (unsigned short)a;
    %%%%%: 1048-block  0
        -: 1049:                    }
        -: 1050:
    #####: 1051:                } break;
    %%%%%: 1051-block  0
    #####: 1052:                case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8:
        -: 1053:                {
    #####: 1054:                    image->data = (unsigned char *)RL_MALLOC(image->width*image->height*4*sizeof(unsigned char));
        -: 1055:
    #####: 1056:                    for (int i = 0, k = 0; i < image->width*image->height*4; i += 4, k++)
    %%%%%: 1056-block  0
    %%%%%: 1056-block  1
branch  0 never executed
branch  1 never executed
        -: 1057:                    {
    #####: 1058:                        ((unsigned char *)image->data)[i] = (unsigned char)(pixels[k].x*255.0f);
    #####: 1059:                        ((unsigned char *)image->data)[i + 1] = (unsigned char)(pixels[k].y*255.0f);
    #####: 1060:                        ((unsigned char *)image->data)[i + 2] = (unsigned char)(pixels[k].z*255.0f);
    #####: 1061:                        ((unsigned char *)image->data)[i + 3] = (unsigned char)(pixels[k].w*255.0f);
    %%%%%: 1061-block  0
        -: 1062:                    }
    #####: 1063:                } break;
    %%%%%: 1063-block  0
    #####: 1064:                case PIXELFORMAT_UNCOMPRESSED_R32:
        -: 1065:                {
        -: 1066:                    // WARNING: Image is converted to GRAYSCALE eqeuivalent 32bit
        -: 1067:
    #####: 1068:                    image->data = (float *)RL_MALLOC(image->width*image->height*sizeof(float));
        -: 1069:
    #####: 1070:                    for (int i = 0; i < image->width*image->height; i++)
    %%%%%: 1070-block  0
    %%%%%: 1070-block  1
branch  0 never executed
branch  1 never executed
        -: 1071:                    {
    #####: 1072:                        ((float *)image->data)[i] = (float)(pixels[i].x*0.299f + pixels[i].y*0.587f + pixels[i].z*0.114f);
    %%%%%: 1072-block  0
        -: 1073:                    }
    #####: 1074:                } break;
    %%%%%: 1074-block  0
    #####: 1075:                case PIXELFORMAT_UNCOMPRESSED_R32G32B32:
        -: 1076:                {
    #####: 1077:                    image->data = (float *)RL_MALLOC(image->width*image->height*3*sizeof(float));
        -: 1078:
    #####: 1079:                    for (int i = 0, k = 0; i < image->width*image->height*3; i += 3, k++)
    %%%%%: 1079-block  0
    %%%%%: 1079-block  1
branch  0 never executed
branch  1 never executed
        -: 1080:                    {
    #####: 1081:                        ((float *)image->data)[i] = pixels[k].x;
    #####: 1082:                        ((float *)image->data)[i + 1] = pixels[k].y;
    #####: 1083:                        ((float *)image->data)[i + 2] = pixels[k].z;
    %%%%%: 1083-block  0
        -: 1084:                    }
    #####: 1085:                } break;
    %%%%%: 1085-block  0
    #####: 1086:                case PIXELFORMAT_UNCOMPRESSED_R32G32B32A32:
        -: 1087:                {
    #####: 1088:                    image->data = (float *)RL_MALLOC(image->width*image->height*4*sizeof(float));
        -: 1089:
    #####: 1090:                    for (int i = 0, k = 0; i < image->width*image->height*4; i += 4, k++)
    %%%%%: 1090-block  0
    %%%%%: 1090-block  1
branch  0 never executed
branch  1 never executed
        -: 1091:                    {
    #####: 1092:                        ((float *)image->data)[i] = pixels[k].x;
    #####: 1093:                        ((float *)image->data)[i + 1] = pixels[k].y;
    #####: 1094:                        ((float *)image->data)[i + 2] = pixels[k].z;
    #####: 1095:                        ((float *)image->data)[i + 3] = pixels[k].w;
    %%%%%: 1095-block  0
        -: 1096:                    }
    #####: 1097:                } break;
    %%%%%: 1097-block  0
    #####: 1098:                default: break;
    %%%%%: 1098-block  0
        -: 1099:            }
        -: 1100:
    #####: 1101:            RL_FREE(pixels);
    #####: 1102:            pixels = NULL;
        -: 1103:
        -: 1104:            // In case original image had mipmaps, generate mipmaps for formated image
        -: 1105:            // NOTE: Original mipmaps are replaced by new ones, if custom mipmaps were used, they are lost
    #####: 1106:            if (image->mipmaps > 1)
    %%%%%: 1106-block  0
branch  0 never executed
branch  1 never executed
        -: 1107:            {
    #####: 1108:                image->mipmaps = 1;
        -: 1109:            #if defined(SUPPORT_IMAGE_MANIPULATION)
    #####: 1110:                if (image->data != NULL) ImageMipmaps(image);
    %%%%%: 1110-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1110-block  1
call    2 never executed
        -: 1111:            #endif
        -: 1112:            }
        -: 1113:        }
    #####: 1114:        else TRACELOG(LOG_WARNING, "IMAGE: Data format is compressed, can not be converted");
    %%%%%: 1114-block  0
call    0 never executed
        -: 1115:    }
        -: 1116:}
        -: 1117:
        -: 1118:// Convert image to POT (power-of-two)
        -: 1119:// NOTE: It could be useful on OpenGL ES 2.0 (RPI, HTML5)
function ImageToPOT called 0 returned 0% blocks executed 0%
    #####: 1120:void ImageToPOT(Image *image, Color fill)
        -: 1121:{
        -: 1122:    // Security check to avoid program crash
    #####: 1123:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1123-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1123-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1123-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1123-block  3
        -: 1124:
        -: 1125:    // Calculate next power-of-two values
        -: 1126:    // NOTE: Just add the required amount of pixels at the right and bottom sides of image...
    #####: 1127:    int potWidth = (int)powf(2, ceilf(logf((float)image->width)/logf(2)));
    #####: 1128:    int potHeight = (int)powf(2, ceilf(logf((float)image->height)/logf(2)));
        -: 1129:
        -: 1130:    // Check if POT texture generation is required (if texture is not already POT)
    #####: 1131:    if ((potWidth != image->width) || (potHeight != image->height)) ImageResizeCanvas(image, potWidth, potHeight, 0, 0, fill);
    %%%%%: 1131-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1131-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1131-block  2
call    4 never executed
        -: 1132:}
        -: 1133:
        -: 1134:#if defined(SUPPORT_IMAGE_MANIPULATION)
        -: 1135:// Create an image from text (default font)
function ImageText called 0 returned 0% blocks executed 0%
    #####: 1136:Image ImageText(const char *text, int fontSize, Color color)
        -: 1137:{
    #####: 1138:    int defaultFontSize = 10;   // Default Font chars height in pixel
    #####: 1139:    if (fontSize < defaultFontSize) fontSize = defaultFontSize;
    %%%%%: 1139-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1139-block  1
    #####: 1140:    int spacing = fontSize/defaultFontSize;
        -: 1141:
    #####: 1142:    Image imText = ImageTextEx(GetFontDefault(), text, (float)fontSize, (float)spacing, color);
    %%%%%: 1142-block  0
call    0 never executed
call    1 never executed
        -: 1143:
    #####: 1144:    return imText;
        -: 1145:}
        -: 1146:
        -: 1147:// Create an image from text (custom sprite font)
function ImageTextEx called 0 returned 0% blocks executed 0%
    #####: 1148:Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint)
        -: 1149:{
    #####: 1150:    int size = (int)strlen(text);   // Get size in bytes of text
        -: 1151:
    #####: 1152:    int textOffsetX = 0;            // Image drawing position X
    #####: 1153:    int textOffsetY = 0;            // Offset between lines (on line break '\n')
        -: 1154:
        -: 1155:    // NOTE: Text image is generated at font base size, later scaled to desired font size
    #####: 1156:    Vector2 imSize = MeasureTextEx(font, text, (float)font.baseSize, spacing);
    %%%%%: 1156-block  0
call    0 never executed
        -: 1157:
        -: 1158:    // Create image to store text
    #####: 1159:    Image imText = GenImageColor((int)imSize.x, (int)imSize.y, BLANK);
call    0 never executed
        -: 1160:
    #####: 1161:    for (int i = 0; i < size; i++)
    %%%%%: 1161-block  0
branch  0 never executed
branch  1 never executed
        -: 1162:    {
        -: 1163:        // Get next codepoint from byte string and glyph index in font
    #####: 1164:        int codepointByteCount = 0;
    #####: 1165:        int codepoint = GetCodepoint(&text[i], &codepointByteCount);
    %%%%%: 1165-block  0
call    0 never executed
    #####: 1166:        int index = GetGlyphIndex(font, codepoint);
call    0 never executed
        -: 1167:
        -: 1168:        // NOTE: Normally we exit the decoding sequence as soon as a bad byte is found (and return 0x3f)
        -: 1169:        // but we need to draw all of the bad bytes using the '?' symbol moving one byte
    #####: 1170:        if (codepoint == 0x3f) codepointByteCount = 1;
branch  0 never executed
branch  1 never executed
    %%%%%: 1170-block  0
        -: 1171:
    #####: 1172:        if (codepoint == '\n')
    %%%%%: 1172-block  0
branch  0 never executed
branch  1 never executed
        -: 1173:        {
        -: 1174:            // NOTE: Fixed line spacing of 1.5 line-height
        -: 1175:            // TODO: Support custom line spacing defined by user
    #####: 1176:            textOffsetY += (font.baseSize + font.baseSize/2);
    #####: 1177:            textOffsetX = 0;
    %%%%%: 1177-block  0
        -: 1178:        }
        -: 1179:        else
        -: 1180:        {
    #####: 1181:            if ((codepoint != ' ') && (codepoint != '\t'))
    %%%%%: 1181-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1181-block  1
branch  2 never executed
branch  3 never executed
        -: 1182:            {
    #####: 1183:                Rectangle rec = { (float)(textOffsetX + font.glyphs[index].offsetX), (float)(textOffsetY + font.glyphs[index].offsetY), (float)font.recs[index].width, (float)font.recs[index].height };
    #####: 1184:                ImageDraw(&imText, font.glyphs[index].image, (Rectangle){ 0, 0, (float)font.glyphs[index].image.width, (float)font.glyphs[index].image.height }, rec, tint);
    %%%%%: 1184-block  0
call    0 never executed
        -: 1185:            }
        -: 1186:
    #####: 1187:            if (font.glyphs[index].advanceX == 0) textOffsetX += (int)(font.recs[index].width + spacing);
    %%%%%: 1187-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1187-block  1
    #####: 1188:            else textOffsetX += font.glyphs[index].advanceX + (int)spacing;
    %%%%%: 1188-block  0
        -: 1189:        }
        -: 1190:
    #####: 1191:        i += (codepointByteCount - 1);   // Move text bytes counter to next codepoint
    %%%%%: 1191-block  0
        -: 1192:    }
        -: 1193:
        -: 1194:    // Scale image depending on text size
    #####: 1195:    if (fontSize > imSize.y)
    %%%%%: 1195-block  0
branch  0 never executed
branch  1 never executed
        -: 1196:    {
    #####: 1197:        float scaleFactor = fontSize/imSize.y;
    #####: 1198:        TRACELOG(LOG_INFO, "IMAGE: Text scaled by factor: %f", scaleFactor);
    %%%%%: 1198-block  0
call    0 never executed
        -: 1199:
        -: 1200:        // Using nearest-neighbor scaling algorithm for default font
    #####: 1201:        if (font.texture.id == GetFontDefault().texture.id) ImageResizeNN(&imText, (int)(imSize.x*scaleFactor), (int)(imSize.y*scaleFactor));
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 1201-block  0
call    3 never executed
    #####: 1202:        else ImageResize(&imText, (int)(imSize.x*scaleFactor), (int)(imSize.y*scaleFactor));
    %%%%%: 1202-block  0
call    0 never executed
        -: 1203:    }
        -: 1204:
    #####: 1205:    return imText;
    %%%%%: 1205-block  0
        -: 1206:}
        -: 1207:
        -: 1208:// Crop image depending on alpha value
        -: 1209:// NOTE: Threshold is defined as a percentatge: 0.0f -> 1.0f
function ImageAlphaCrop called 0 returned 0% blocks executed 0%
    #####: 1210:void ImageAlphaCrop(Image *image, float threshold)
        -: 1211:{
        -: 1212:    // Security check to avoid program crash
    #####: 1213:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1213-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1213-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1213-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1213-block  3
        -: 1214:
    #####: 1215:    Rectangle crop = GetImageAlphaBorder(*image, threshold);
    %%%%%: 1215-block  0
call    0 never executed
        -: 1216:
        -: 1217:    // Crop if rectangle is valid
    #####: 1218:    if (((int)crop.width != 0) && ((int)crop.height != 0)) ImageCrop(image, crop);
branch  0 never executed
branch  1 never executed
    %%%%%: 1218-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 1218-block  1
call    4 never executed
        -: 1219:}
        -: 1220:
        -: 1221:// Clear alpha channel to desired color
        -: 1222:// NOTE: Threshold defines the alpha limit, 0.0f to 1.0f
function ImageAlphaClear called 0 returned 0% blocks executed 0%
    #####: 1223:void ImageAlphaClear(Image *image, Color color, float threshold)
        -: 1224:{
        -: 1225:    // Security check to avoid program crash
    #####: 1226:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1226-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1226-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1226-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1226-block  3
        -: 1227:
    #####: 1228:    if (image->mipmaps > 1) TRACELOG(LOG_WARNING, "Image manipulation only applied to base mipmap level");
    %%%%%: 1228-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1228-block  1
call    2 never executed
    #####: 1229:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image manipulation not supported for compressed formats");
    %%%%%: 1229-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1229-block  1
call    2 never executed
        -: 1230:    else
        -: 1231:    {
    #####: 1232:        switch (image->format)
    %%%%%: 1232-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1233:        {
    #####: 1234:            case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 1235:            {
    #####: 1236:                unsigned char thresholdValue = (unsigned char)(threshold*255.0f);
    #####: 1237:                for (int i = 1; i < image->width*image->height*2; i += 2)
    %%%%%: 1237-block  0
    %%%%%: 1237-block  1
    %%%%%: 1237-block  2
branch  0 never executed
branch  1 never executed
        -: 1238:                {
    #####: 1239:                    if (((unsigned char *)image->data)[i] <= thresholdValue)
    %%%%%: 1239-block  0
branch  0 never executed
branch  1 never executed
        -: 1240:                    {
    #####: 1241:                        ((unsigned char *)image->data)[i - 1] = color.r;
    #####: 1242:                        ((unsigned char *)image->data)[i] = color.a;
    %%%%%: 1242-block  0
        -: 1243:                    }
        -: 1244:                }
    #####: 1245:            } break;
    %%%%%: 1245-block  0
    #####: 1246:            case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 1247:            {
    #####: 1248:                unsigned char thresholdValue = ((threshold < 0.5f)? 0 : 1);
        -: 1249:
    #####: 1250:                unsigned char r = (unsigned char)(round((float)color.r*31.0f));
    #####: 1251:                unsigned char g = (unsigned char)(round((float)color.g*31.0f));
    #####: 1252:                unsigned char b = (unsigned char)(round((float)color.b*31.0f));
    #####: 1253:                unsigned char a = (color.a < 128)? 0 : 1;
        -: 1254:
    #####: 1255:                for (int i = 0; i < image->width*image->height; i++)
    %%%%%: 1255-block  0
    %%%%%: 1255-block  1
    %%%%%: 1255-block  2
branch  0 never executed
branch  1 never executed
        -: 1256:                {
    #####: 1257:                    if ((((unsigned short *)image->data)[i] & 0b0000000000000001) <= thresholdValue)
    %%%%%: 1257-block  0
branch  0 never executed
branch  1 never executed
        -: 1258:                    {
    #####: 1259:                        ((unsigned short *)image->data)[i] = (unsigned short)r << 11 | (unsigned short)g << 6 | (unsigned short)b << 1 | (unsigned short)a;
    %%%%%: 1259-block  0
        -: 1260:                    }
        -: 1261:                }
    #####: 1262:            } break;
    %%%%%: 1262-block  0
    #####: 1263:            case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4:
        -: 1264:            {
    #####: 1265:                unsigned char thresholdValue = (unsigned char)(threshold*15.0f);
        -: 1266:
    #####: 1267:                unsigned char r = (unsigned char)(round((float)color.r*15.0f));
    #####: 1268:                unsigned char g = (unsigned char)(round((float)color.g*15.0f));
    #####: 1269:                unsigned char b = (unsigned char)(round((float)color.b*15.0f));
    #####: 1270:                unsigned char a = (unsigned char)(round((float)color.a*15.0f));
        -: 1271:
    #####: 1272:                for (int i = 0; i < image->width*image->height; i++)
    %%%%%: 1272-block  0
    %%%%%: 1272-block  1
    %%%%%: 1272-block  2
branch  0 never executed
branch  1 never executed
        -: 1273:                {
    #####: 1274:                    if ((((unsigned short *)image->data)[i] & 0x000f) <= thresholdValue)
    %%%%%: 1274-block  0
branch  0 never executed
branch  1 never executed
        -: 1275:                    {
    #####: 1276:                        ((unsigned short *)image->data)[i] = (unsigned short)r << 12 | (unsigned short)g << 8 | (unsigned short)b << 4 | (unsigned short)a;
    %%%%%: 1276-block  0
        -: 1277:                    }
        -: 1278:                }
    #####: 1279:            } break;
    %%%%%: 1279-block  0
    #####: 1280:            case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8:
        -: 1281:            {
    #####: 1282:                unsigned char thresholdValue = (unsigned char)(threshold*255.0f);
    #####: 1283:                for (int i = 3; i < image->width*image->height*4; i += 4)
    %%%%%: 1283-block  0
    %%%%%: 1283-block  1
    %%%%%: 1283-block  2
branch  0 never executed
branch  1 never executed
        -: 1284:                {
    #####: 1285:                    if (((unsigned char *)image->data)[i] <= thresholdValue)
    %%%%%: 1285-block  0
branch  0 never executed
branch  1 never executed
        -: 1286:                    {
    #####: 1287:                        ((unsigned char *)image->data)[i - 3] = color.r;
    #####: 1288:                        ((unsigned char *)image->data)[i - 2] = color.g;
    #####: 1289:                        ((unsigned char *)image->data)[i - 1] = color.b;
    #####: 1290:                        ((unsigned char *)image->data)[i] = color.a;
    %%%%%: 1290-block  0
        -: 1291:                    }
        -: 1292:                }
    #####: 1293:            } break;
    %%%%%: 1293-block  0
    #####: 1294:            case PIXELFORMAT_UNCOMPRESSED_R32G32B32A32:
        -: 1295:            {
    #####: 1296:                for (int i = 3; i < image->width*image->height*4; i += 4)
    %%%%%: 1296-block  0
    %%%%%: 1296-block  1
    %%%%%: 1296-block  2
branch  0 never executed
branch  1 never executed
        -: 1297:                {
    #####: 1298:                    if (((float *)image->data)[i] <= threshold)
    %%%%%: 1298-block  0
branch  0 never executed
branch  1 never executed
        -: 1299:                    {
    #####: 1300:                        ((float *)image->data)[i - 3] = (float)color.r/255.0f;
    #####: 1301:                        ((float *)image->data)[i - 2] = (float)color.g/255.0f;
    #####: 1302:                        ((float *)image->data)[i - 1] = (float)color.b/255.0f;
    #####: 1303:                        ((float *)image->data)[i] = (float)color.a/255.0f;
    %%%%%: 1303-block  0
        -: 1304:                    }
        -: 1305:                }
    #####: 1306:            } break;
    %%%%%: 1306-block  0
    #####: 1307:            default: break;
    %%%%%: 1307-block  0
        -: 1308:        }
        -: 1309:    }
        -: 1310:}
        -: 1311:
        -: 1312:// Apply alpha mask to image
        -: 1313:// NOTE 1: Returned image is GRAY_ALPHA (16bit) or RGBA (32bit)
        -: 1314:// NOTE 2: alphaMask should be same size as image
function ImageAlphaMask called 0 returned 0% blocks executed 0%
    #####: 1315:void ImageAlphaMask(Image *image, Image alphaMask)
        -: 1316:{
    #####: 1317:    if ((image->width != alphaMask.width) || (image->height != alphaMask.height))
    %%%%%: 1317-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1317-block  1
branch  2 never executed
branch  3 never executed
        -: 1318:    {
    #####: 1319:        TRACELOG(LOG_WARNING, "IMAGE: Alpha mask must be same size as image");
    %%%%%: 1319-block  0
call    0 never executed
        -: 1320:    }
    #####: 1321:    else if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB)
    %%%%%: 1321-block  0
branch  0 never executed
branch  1 never executed
        -: 1322:    {
    #####: 1323:        TRACELOG(LOG_WARNING, "IMAGE: Alpha mask can not be applied to compressed data formats");
    %%%%%: 1323-block  0
call    0 never executed
        -: 1324:    }
        -: 1325:    else
        -: 1326:    {
        -: 1327:        // Force mask to be Grayscale
    #####: 1328:        Image mask = ImageCopy(alphaMask);
    %%%%%: 1328-block  0
call    0 never executed
    #####: 1329:        if (mask.format != PIXELFORMAT_UNCOMPRESSED_GRAYSCALE) ImageFormat(&mask, PIXELFORMAT_UNCOMPRESSED_GRAYSCALE);
branch  0 never executed
branch  1 never executed
    %%%%%: 1329-block  0
call    2 never executed
        -: 1330:
        -: 1331:        // In case image is only grayscale, we just add alpha channel
    #####: 1332:        if (image->format == PIXELFORMAT_UNCOMPRESSED_GRAYSCALE)
    %%%%%: 1332-block  0
branch  0 never executed
branch  1 never executed
        -: 1333:        {
    #####: 1334:            unsigned char *data = (unsigned char *)RL_MALLOC(image->width*image->height*2);
        -: 1335:
        -: 1336:            // Apply alpha mask to alpha channel
    #####: 1337:            for (int i = 0, k = 0; (i < mask.width*mask.height) || (i < image->width*image->height); i++, k += 2)
    %%%%%: 1337-block  0
    %%%%%: 1337-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1337-block  2
branch  2 never executed
branch  3 never executed
        -: 1338:            {
    #####: 1339:                data[k] = ((unsigned char *)image->data)[i];
    #####: 1340:                data[k + 1] = ((unsigned char *)mask.data)[i];
    %%%%%: 1340-block  0
        -: 1341:            }
        -: 1342:
    #####: 1343:            RL_FREE(image->data);
    #####: 1344:            image->data = data;
    #####: 1345:            image->format = PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA;
    %%%%%: 1345-block  0
        -: 1346:        }
        -: 1347:        else
        -: 1348:        {
        -: 1349:            // Convert image to RGBA
    #####: 1350:            if (image->format != PIXELFORMAT_UNCOMPRESSED_R8G8B8A8) ImageFormat(image, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8);
    %%%%%: 1350-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1350-block  1
call    2 never executed
        -: 1351:
        -: 1352:            // Apply alpha mask to alpha channel
    #####: 1353:            for (int i = 0, k = 3; (i < mask.width*mask.height) || (i < image->width*image->height); i++, k += 4)
    %%%%%: 1353-block  0
    %%%%%: 1353-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1353-block  2
branch  2 never executed
branch  3 never executed
        -: 1354:            {
    #####: 1355:                ((unsigned char *)image->data)[k] = ((unsigned char *)mask.data)[i];
    %%%%%: 1355-block  0
        -: 1356:            }
        -: 1357:        }
        -: 1358:
    #####: 1359:        UnloadImage(mask);
    %%%%%: 1359-block  0
call    0 never executed
        -: 1360:    }
    #####: 1361:}
        -: 1362:
        -: 1363:// Premultiply alpha channel
function ImageAlphaPremultiply called 0 returned 0% blocks executed 0%
    #####: 1364:void ImageAlphaPremultiply(Image *image)
        -: 1365:{
        -: 1366:    // Security check to avoid program crash
    #####: 1367:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1367-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1367-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1367-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1367-block  3
        -: 1368:
    #####: 1369:    float alpha = 0.0f;
    #####: 1370:    Color *pixels = LoadImageColors(*image);
    %%%%%: 1370-block  0
call    0 never executed
        -: 1371:
    #####: 1372:    for (int i = 0; i < image->width*image->height; i++)
    %%%%%: 1372-block  0
    %%%%%: 1372-block  1
branch  0 never executed
branch  1 never executed
        -: 1373:    {
    #####: 1374:        if (pixels[i].a == 0)
    %%%%%: 1374-block  0
branch  0 never executed
branch  1 never executed
        -: 1375:        {
    #####: 1376:            pixels[i].r = 0;
    #####: 1377:            pixels[i].g = 0;
    #####: 1378:            pixels[i].b = 0;
    %%%%%: 1378-block  0
        -: 1379:        }
    #####: 1380:        else if (pixels[i].a < 255)
    %%%%%: 1380-block  0
branch  0 never executed
branch  1 never executed
        -: 1381:        {
    #####: 1382:            alpha = (float)pixels[i].a/255.0f;
    #####: 1383:            pixels[i].r = (unsigned char)((float)pixels[i].r*alpha);
    #####: 1384:            pixels[i].g = (unsigned char)((float)pixels[i].g*alpha);
    #####: 1385:            pixels[i].b = (unsigned char)((float)pixels[i].b*alpha);
    %%%%%: 1385-block  0
        -: 1386:        }
        -: 1387:    }
        -: 1388:
    #####: 1389:    RL_FREE(image->data);
        -: 1390:
    #####: 1391:    int format = image->format;
    #####: 1392:    image->data = pixels;
    #####: 1393:    image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 1394:
    #####: 1395:    ImageFormat(image, format);
    %%%%%: 1395-block  0
call    0 never executed
        -: 1396:}
        -: 1397:
        -: 1398:// Resize and image to new size
        -: 1399:// NOTE: Uses stb default scaling filters (both bicubic):
        -: 1400:// STBIR_DEFAULT_FILTER_UPSAMPLE    STBIR_FILTER_CATMULLROM
        -: 1401:// STBIR_DEFAULT_FILTER_DOWNSAMPLE  STBIR_FILTER_MITCHELL   (high-quality Catmull-Rom)
function ImageResize called 0 returned 0% blocks executed 0%
    #####: 1402:void ImageResize(Image *image, int newWidth, int newHeight)
        -: 1403:{
        -: 1404:    // Security check to avoid program crash
    #####: 1405:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1405-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1405-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1405-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1405-block  3
        -: 1406:
    #####: 1407:    bool fastPath = true;
    #####: 1408:    if ((image->format != PIXELFORMAT_UNCOMPRESSED_GRAYSCALE) && (image->format != PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA) && (image->format != PIXELFORMAT_UNCOMPRESSED_R8G8B8) && (image->format != PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)) fastPath = true;
    %%%%%: 1408-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1408-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1408-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1408-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1408-block  4
        -: 1409:
    #####: 1410:    if (fastPath)
    %%%%%: 1410-block  0
branch  0 never executed
branch  1 never executed
        -: 1411:    {
    #####: 1412:        int bytesPerPixel = GetPixelDataSize(1, 1, image->format);
    %%%%%: 1412-block  0
call    0 never executed
    #####: 1413:        unsigned char *output = (unsigned char *)RL_MALLOC(newWidth*newHeight*bytesPerPixel);
        -: 1414:
    #####: 1415:        switch (image->format)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1416:        {
    #####: 1417:            case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: stbir_resize_uint8((unsigned char *)image->data, image->width, image->height, 0, output, newWidth, newHeight, 0, 1); break;
    %%%%%: 1417-block  0
call    0 never executed
    #####: 1418:            case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: stbir_resize_uint8((unsigned char *)image->data, image->width, image->height, 0, output, newWidth, newHeight, 0, 2); break;
    %%%%%: 1418-block  0
call    0 never executed
    #####: 1419:            case PIXELFORMAT_UNCOMPRESSED_R8G8B8: stbir_resize_uint8((unsigned char *)image->data, image->width, image->height, 0, output, newWidth, newHeight, 0, 3); break;
    %%%%%: 1419-block  0
call    0 never executed
    #####: 1420:            case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: stbir_resize_uint8((unsigned char *)image->data, image->width, image->height, 0, output, newWidth, newHeight, 0, 4); break;
    %%%%%: 1420-block  0
call    0 never executed
    #####: 1421:            default: break;
    %%%%%: 1421-block  0
        -: 1422:        }
        -: 1423:
    #####: 1424:        RL_FREE(image->data);
    #####: 1425:        image->data = output;
    #####: 1426:        image->width = newWidth;
    #####: 1427:        image->height = newHeight;
    %%%%%: 1427-block  0
        -: 1428:    }
        -: 1429:    else
        -: 1430:    {
        -: 1431:        // Get data as Color pixels array to work with it
    #####: 1432:        Color *pixels = LoadImageColors(*image);
    %%%%%: 1432-block  0
call    0 never executed
    #####: 1433:        Color *output = (Color *)RL_MALLOC(newWidth*newHeight*sizeof(Color));
        -: 1434:
        -: 1435:        // NOTE: Color data is casted to (unsigned char *), there shouldn't been any problem...
    #####: 1436:        stbir_resize_uint8((unsigned char *)pixels, image->width, image->height, 0, (unsigned char *)output, newWidth, newHeight, 0, 4);
call    0 never executed
        -: 1437:
    #####: 1438:        int format = image->format;
        -: 1439:
    #####: 1440:        UnloadImageColors(pixels);
call    0 never executed
    #####: 1441:        RL_FREE(image->data);
        -: 1442:
    #####: 1443:        image->data = output;
    #####: 1444:        image->width = newWidth;
    #####: 1445:        image->height = newHeight;
    #####: 1446:        image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 1447:
    #####: 1448:        ImageFormat(image, format);  // Reformat 32bit RGBA image to original format
call    0 never executed
        -: 1449:    }
        -: 1450:}
        -: 1451:
        -: 1452:// Resize and image to new size using Nearest-Neighbor scaling algorithm
function ImageResizeNN called 0 returned 0% blocks executed 0%
    #####: 1453:void ImageResizeNN(Image *image,int newWidth,int newHeight)
        -: 1454:{
        -: 1455:    // Security check to avoid program crash
    #####: 1456:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1456-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1456-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1456-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1456-block  3
        -: 1457:
    #####: 1458:    Color *pixels = LoadImageColors(*image);
    %%%%%: 1458-block  0
call    0 never executed
    #####: 1459:    Color *output = (Color *)RL_MALLOC(newWidth*newHeight*sizeof(Color));
        -: 1460:
        -: 1461:    // EDIT: added +1 to account for an early rounding problem
    #####: 1462:    int xRatio = (int)((image->width << 16)/newWidth) + 1;
    #####: 1463:    int yRatio = (int)((image->height << 16)/newHeight) + 1;
        -: 1464:
        -: 1465:    int x2, y2;
    #####: 1466:    for (int y = 0; y < newHeight; y++)
    %%%%%: 1466-block  0
    %%%%%: 1466-block  1
branch  0 never executed
branch  1 never executed
        -: 1467:    {
    #####: 1468:        for (int x = 0; x < newWidth; x++)
    %%%%%: 1468-block  0
    %%%%%: 1468-block  1
branch  0 never executed
branch  1 never executed
        -: 1469:        {
    #####: 1470:            x2 = ((x*xRatio) >> 16);
    #####: 1471:            y2 = ((y*yRatio) >> 16);
        -: 1472:
    #####: 1473:            output[(y*newWidth) + x] = pixels[(y2*image->width) + x2] ;
    %%%%%: 1473-block  0
        -: 1474:        }
        -: 1475:    }
        -: 1476:
    #####: 1477:    int format = image->format;
        -: 1478:
    #####: 1479:    RL_FREE(image->data);
        -: 1480:
    #####: 1481:    image->data = output;
    #####: 1482:    image->width = newWidth;
    #####: 1483:    image->height = newHeight;
    #####: 1484:    image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 1485:
    #####: 1486:    ImageFormat(image, format);  // Reformat 32bit RGBA image to original format
    %%%%%: 1486-block  0
call    0 never executed
        -: 1487:
    #####: 1488:    UnloadImageColors(pixels);
call    0 never executed
        -: 1489:}
        -: 1490:
        -: 1491:// Resize canvas and fill with color
        -: 1492:// NOTE: Resize offset is relative to the top-left corner of the original image
function ImageResizeCanvas called 0 returned 0% blocks executed 0%
    #####: 1493:void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill)
        -: 1494:{
        -: 1495:    // Security check to avoid program crash
    #####: 1496:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1496-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1496-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1496-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1496-block  3
        -: 1497:
    #####: 1498:    if (image->mipmaps > 1) TRACELOG(LOG_WARNING, "Image manipulation only applied to base mipmap level");
    %%%%%: 1498-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1498-block  1
call    2 never executed
    #####: 1499:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image manipulation not supported for compressed formats");
    %%%%%: 1499-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1499-block  1
call    2 never executed
    #####: 1500:    else if ((newWidth != image->width) || (newHeight != image->height))
    %%%%%: 1500-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1500-block  1
branch  2 never executed
branch  3 never executed
        -: 1501:    {
    #####: 1502:        Rectangle srcRec = { 0, 0, (float)image->width, (float)image->height };
    #####: 1503:        Vector2 dstPos = { (float)offsetX, (float)offsetY };
        -: 1504:
    #####: 1505:        if (offsetX < 0)
    %%%%%: 1505-block  0
branch  0 never executed
branch  1 never executed
        -: 1506:        {
    #####: 1507:            srcRec.x = (float)-offsetX;
    #####: 1508:            srcRec.width += (float)offsetX;
    #####: 1509:            dstPos.x = 0;
    %%%%%: 1509-block  0
        -: 1510:        }
    #####: 1511:        else if ((offsetX + image->width) > newWidth) srcRec.width = (float)(newWidth - offsetX);
    %%%%%: 1511-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1511-block  1
        -: 1512:
    #####: 1513:        if (offsetY < 0)
    %%%%%: 1513-block  0
branch  0 never executed
branch  1 never executed
        -: 1514:        {
    #####: 1515:            srcRec.y = (float)-offsetY;
    #####: 1516:            srcRec.height += (float)offsetY;
    #####: 1517:            dstPos.y = 0;
    %%%%%: 1517-block  0
        -: 1518:        }
    #####: 1519:        else if ((offsetY + image->height) > newHeight) srcRec.height = (float)(newHeight - offsetY);
    %%%%%: 1519-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1519-block  1
        -: 1520:
    #####: 1521:        if (newWidth < srcRec.width) srcRec.width = (float)newWidth;
    %%%%%: 1521-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1521-block  1
    #####: 1522:        if (newHeight < srcRec.height) srcRec.height = (float)newHeight;
    %%%%%: 1522-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1522-block  1
        -: 1523:
    #####: 1524:        int bytesPerPixel = GetPixelDataSize(1, 1, image->format);
    %%%%%: 1524-block  0
call    0 never executed
    #####: 1525:        unsigned char *resizedData = (unsigned char *)RL_CALLOC(newWidth*newHeight*bytesPerPixel, 1);
        -: 1526:
        -: 1527:        // TODO: Fill resizedData with fill color (must be formatted to image->format)
        -: 1528:
    #####: 1529:        int dstOffsetSize = ((int)dstPos.y*newWidth + (int)dstPos.x)*bytesPerPixel;
        -: 1530:
    #####: 1531:        for (int y = 0; y < (int)srcRec.height; y++)
    %%%%%: 1531-block  0
branch  0 never executed
branch  1 never executed
        -: 1532:        {
    #####: 1533:            memcpy(resizedData + dstOffsetSize, ((unsigned char *)image->data) + ((y + (int)srcRec.y)*image->width + (int)srcRec.x)*bytesPerPixel, (int)srcRec.width*bytesPerPixel);
    #####: 1534:            dstOffsetSize += (newWidth*bytesPerPixel);
    %%%%%: 1534-block  0
        -: 1535:        }
        -: 1536:
    #####: 1537:        RL_FREE(image->data);
    #####: 1538:        image->data = resizedData;
    #####: 1539:        image->width = newWidth;
    #####: 1540:        image->height = newHeight;
    %%%%%: 1540-block  0
        -: 1541:    }
        -: 1542:}
        -: 1543:
        -: 1544:// Generate all mipmap levels for a provided image
        -: 1545:// NOTE 1: Supports POT and NPOT images
        -: 1546:// NOTE 2: image.data is scaled to include mipmap levels
        -: 1547:// NOTE 3: Mipmaps format is the same as base image
function ImageMipmaps called 0 returned 0% blocks executed 0%
    #####: 1548:void ImageMipmaps(Image *image)
        -: 1549:{
        -: 1550:    // Security check to avoid program crash
    #####: 1551:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1551-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1551-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1551-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1551-block  3
        -: 1552:
    #####: 1553:    int mipCount = 1;                   // Required mipmap levels count (including base level)
    #####: 1554:    int mipWidth = image->width;        // Base image width
    #####: 1555:    int mipHeight = image->height;      // Base image height
    #####: 1556:    int mipSize = GetPixelDataSize(mipWidth, mipHeight, image->format);  // Image data size (in bytes)
    %%%%%: 1556-block  0
call    0 never executed
        -: 1557:
        -: 1558:    // Count mipmap levels required
    #####: 1559:    while ((mipWidth != 1) || (mipHeight != 1))
    %%%%%: 1559-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1559-block  1
branch  2 never executed
branch  3 never executed
        -: 1560:    {
    #####: 1561:        if (mipWidth != 1) mipWidth /= 2;
    %%%%%: 1561-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1561-block  1
    #####: 1562:        if (mipHeight != 1) mipHeight /= 2;
    %%%%%: 1562-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1562-block  1
        -: 1563:
        -: 1564:        // Security check for NPOT textures
    #####: 1565:        if (mipWidth < 1) mipWidth = 1;
    %%%%%: 1565-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1565-block  1
    #####: 1566:        if (mipHeight < 1) mipHeight = 1;
    %%%%%: 1566-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1566-block  1
        -: 1567:
        -: 1568:        TRACELOGD("IMAGE: Next mipmap level: %i x %i - current size %i", mipWidth, mipHeight, mipSize);
        -: 1569:
    #####: 1570:        mipCount++;
    #####: 1571:        mipSize += GetPixelDataSize(mipWidth, mipHeight, image->format);       // Add mipmap size (in bytes)
    %%%%%: 1571-block  0
call    0 never executed
        -: 1572:    }
        -: 1573:
    #####: 1574:    if (image->mipmaps < mipCount)
    %%%%%: 1574-block  0
branch  0 never executed
branch  1 never executed
        -: 1575:    {
    #####: 1576:        void *temp = RL_REALLOC(image->data, mipSize);
        -: 1577:
    #####: 1578:        if (temp != NULL) image->data = temp;      // Assign new pointer (new size) to store mipmaps data
    %%%%%: 1578-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1578-block  1
    #####: 1579:        else TRACELOG(LOG_WARNING, "IMAGE: Mipmaps required memory could not be allocated");
    %%%%%: 1579-block  0
call    0 never executed
        -: 1580:
        -: 1581:        // Pointer to allocated memory point where store next mipmap level data
    #####: 1582:        unsigned char *nextmip = (unsigned char *)image->data + GetPixelDataSize(image->width, image->height, image->format);
    %%%%%: 1582-block  0
call    0 never executed
        -: 1583:
    #####: 1584:        mipWidth = image->width/2;
    #####: 1585:        mipHeight = image->height/2;
    #####: 1586:        mipSize = GetPixelDataSize(mipWidth, mipHeight, image->format);
call    0 never executed
    #####: 1587:        Image imCopy = ImageCopy(*image);
call    0 never executed
        -: 1588:
    #####: 1589:        for (int i = 1; i < mipCount; i++)
    %%%%%: 1589-block  0
branch  0 never executed
branch  1 never executed
        -: 1590:        {
        -: 1591:            TRACELOGD("IMAGE: Generating mipmap level: %i (%i x %i) - size: %i - offset: 0x%x", i, mipWidth, mipHeight, mipSize, nextmip);
        -: 1592:
    #####: 1593:            ImageResize(&imCopy, mipWidth, mipHeight);  // Uses internally Mitchell cubic downscale filter
    %%%%%: 1593-block  0
call    0 never executed
        -: 1594:
    #####: 1595:            memcpy(nextmip, imCopy.data, mipSize);
    #####: 1596:            nextmip += mipSize;
    #####: 1597:            image->mipmaps++;
        -: 1598:
    #####: 1599:            mipWidth /= 2;
    #####: 1600:            mipHeight /= 2;
        -: 1601:
        -: 1602:            // Security check for NPOT textures
    #####: 1603:            if (mipWidth < 1) mipWidth = 1;
branch  0 never executed
branch  1 never executed
    %%%%%: 1603-block  0
    #####: 1604:            if (mipHeight < 1) mipHeight = 1;
    %%%%%: 1604-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1604-block  1
        -: 1605:
    #####: 1606:            mipSize = GetPixelDataSize(mipWidth, mipHeight, image->format);
    %%%%%: 1606-block  0
call    0 never executed
        -: 1607:        }
        -: 1608:
    #####: 1609:        UnloadImage(imCopy);
    %%%%%: 1609-block  0
call    0 never executed
        -: 1610:    }
    #####: 1611:    else TRACELOG(LOG_WARNING, "IMAGE: Mipmaps already available");
    %%%%%: 1611-block  0
call    0 never executed
        -: 1612:}
        -: 1613:
        -: 1614:// Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
        -: 1615:// NOTE: In case selected bpp do not represent an known 16bit format,
        -: 1616:// dithered data is stored in the LSB part of the unsigned short
function ImageDither called 0 returned 0% blocks executed 0%
    #####: 1617:void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp)
        -: 1618:{
        -: 1619:    // Security check to avoid program crash
    #####: 1620:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1620-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1620-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1620-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1620-block  3
        -: 1621:
    #####: 1622:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB)
    %%%%%: 1622-block  0
branch  0 never executed
branch  1 never executed
        -: 1623:    {
    #####: 1624:        TRACELOG(LOG_WARNING, "IMAGE: Compressed data formats can not be dithered");
    %%%%%: 1624-block  0
call    0 never executed
    #####: 1625:        return;
        -: 1626:    }
        -: 1627:
    #####: 1628:    if ((rBpp + gBpp + bBpp + aBpp) > 16)
    %%%%%: 1628-block  0
branch  0 never executed
branch  1 never executed
        -: 1629:    {
    #####: 1630:        TRACELOG(LOG_WARNING, "IMAGE: Unsupported dithering bpps (%ibpp), only 16bpp or lower modes supported", (rBpp+gBpp+bBpp+aBpp));
    %%%%%: 1630-block  0
call    0 never executed
        -: 1631:    }
        -: 1632:    else
        -: 1633:    {
    #####: 1634:        Color *pixels = LoadImageColors(*image);
    %%%%%: 1634-block  0
call    0 never executed
        -: 1635:
    #####: 1636:        RL_FREE(image->data);      // free old image data
        -: 1637:
    #####: 1638:        if ((image->format != PIXELFORMAT_UNCOMPRESSED_R8G8B8) && (image->format != PIXELFORMAT_UNCOMPRESSED_R8G8B8A8))
branch  0 never executed
branch  1 never executed
    %%%%%: 1638-block  0
branch  2 never executed
branch  3 never executed
        -: 1639:        {
    #####: 1640:            TRACELOG(LOG_WARNING, "IMAGE: Format is already 16bpp or lower, dithering could have no effect");
    %%%%%: 1640-block  0
call    0 never executed
        -: 1641:        }
        -: 1642:
        -: 1643:        // Define new image format, check if desired bpp match internal known format
    #####: 1644:        if ((rBpp == 5) && (gBpp == 6) && (bBpp == 5) && (aBpp == 0)) image->format = PIXELFORMAT_UNCOMPRESSED_R5G6B5;
    %%%%%: 1644-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1644-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1644-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1644-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1644-block  4
    #####: 1645:        else if ((rBpp == 5) && (gBpp == 5) && (bBpp == 5) && (aBpp == 1)) image->format = PIXELFORMAT_UNCOMPRESSED_R5G5B5A1;
    %%%%%: 1645-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1645-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1645-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1645-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1645-block  4
    #####: 1646:        else if ((rBpp == 4) && (gBpp == 4) && (bBpp == 4) && (aBpp == 4)) image->format = PIXELFORMAT_UNCOMPRESSED_R4G4B4A4;
    %%%%%: 1646-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1646-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1646-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1646-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1646-block  4
        -: 1647:        else
        -: 1648:        {
    #####: 1649:            image->format = 0;
    #####: 1650:            TRACELOG(LOG_WARNING, "IMAGE: Unsupported dithered OpenGL internal format: %ibpp (R%iG%iB%iA%i)", (rBpp+gBpp+bBpp+aBpp), rBpp, gBpp, bBpp, aBpp);
    %%%%%: 1650-block  0
call    0 never executed
        -: 1651:        }
        -: 1652:
        -: 1653:        // NOTE: We will store the dithered data as unsigned short (16bpp)
    #####: 1654:        image->data = (unsigned short *)RL_MALLOC(image->width*image->height*sizeof(unsigned short));
        -: 1655:
    #####: 1656:        Color oldPixel = WHITE;
    #####: 1657:        Color newPixel = WHITE;
        -: 1658:
        -: 1659:        int rError, gError, bError;
        -: 1660:        unsigned short rPixel, gPixel, bPixel, aPixel;   // Used for 16bit pixel composition
        -: 1661:
        -: 1662:        #define MIN(a,b) (((a)<(b))?(a):(b))
        -: 1663:
    #####: 1664:        for (int y = 0; y < image->height; y++)
    %%%%%: 1664-block  0
    %%%%%: 1664-block  1
    %%%%%: 1664-block  2
branch  0 never executed
branch  1 never executed
        -: 1665:        {
    #####: 1666:            for (int x = 0; x < image->width; x++)
    %%%%%: 1666-block  0
    %%%%%: 1666-block  1
branch  0 never executed
branch  1 never executed
        -: 1667:            {
    #####: 1668:                oldPixel = pixels[y*image->width + x];
        -: 1669:
        -: 1670:                // NOTE: New pixel obtained by bits truncate, it would be better to round values (check ImageFormat())
    #####: 1671:                newPixel.r = oldPixel.r >> (8 - rBpp);     // R bits
    #####: 1672:                newPixel.g = oldPixel.g >> (8 - gBpp);     // G bits
    #####: 1673:                newPixel.b = oldPixel.b >> (8 - bBpp);     // B bits
    #####: 1674:                newPixel.a = oldPixel.a >> (8 - aBpp);     // A bits (not used on dithering)
        -: 1675:
        -: 1676:                // NOTE: Error must be computed between new and old pixel but using same number of bits!
        -: 1677:                // We want to know how much color precision we have lost...
    #####: 1678:                rError = (int)oldPixel.r - (int)(newPixel.r << (8 - rBpp));
    #####: 1679:                gError = (int)oldPixel.g - (int)(newPixel.g << (8 - gBpp));
    #####: 1680:                bError = (int)oldPixel.b - (int)(newPixel.b << (8 - bBpp));
        -: 1681:
    #####: 1682:                pixels[y*image->width + x] = newPixel;
        -: 1683:
        -: 1684:                // NOTE: Some cases are out of the array and should be ignored
    #####: 1685:                if (x < (image->width - 1))
    %%%%%: 1685-block  0
branch  0 never executed
branch  1 never executed
        -: 1686:                {
    #####: 1687:                    pixels[y*image->width + x+1].r = MIN((int)pixels[y*image->width + x+1].r + (int)((float)rError*7.0f/16), 0xff);
    #####: 1688:                    pixels[y*image->width + x+1].g = MIN((int)pixels[y*image->width + x+1].g + (int)((float)gError*7.0f/16), 0xff);
    #####: 1689:                    pixels[y*image->width + x+1].b = MIN((int)pixels[y*image->width + x+1].b + (int)((float)bError*7.0f/16), 0xff);
    %%%%%: 1689-block  0
        -: 1690:                }
        -: 1691:
    #####: 1692:                if ((x > 0) && (y < (image->height - 1)))
    %%%%%: 1692-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1692-block  1
branch  2 never executed
branch  3 never executed
        -: 1693:                {
    #####: 1694:                    pixels[(y+1)*image->width + x-1].r = MIN((int)pixels[(y+1)*image->width + x-1].r + (int)((float)rError*3.0f/16), 0xff);
    #####: 1695:                    pixels[(y+1)*image->width + x-1].g = MIN((int)pixels[(y+1)*image->width + x-1].g + (int)((float)gError*3.0f/16), 0xff);
    #####: 1696:                    pixels[(y+1)*image->width + x-1].b = MIN((int)pixels[(y+1)*image->width + x-1].b + (int)((float)bError*3.0f/16), 0xff);
    %%%%%: 1696-block  0
        -: 1697:                }
        -: 1698:
    #####: 1699:                if (y < (image->height - 1))
    %%%%%: 1699-block  0
branch  0 never executed
branch  1 never executed
        -: 1700:                {
    #####: 1701:                    pixels[(y+1)*image->width + x].r = MIN((int)pixels[(y+1)*image->width + x].r + (int)((float)rError*5.0f/16), 0xff);
    #####: 1702:                    pixels[(y+1)*image->width + x].g = MIN((int)pixels[(y+1)*image->width + x].g + (int)((float)gError*5.0f/16), 0xff);
    #####: 1703:                    pixels[(y+1)*image->width + x].b = MIN((int)pixels[(y+1)*image->width + x].b + (int)((float)bError*5.0f/16), 0xff);
    %%%%%: 1703-block  0
        -: 1704:                }
        -: 1705:
    #####: 1706:                if ((x < (image->width - 1)) && (y < (image->height - 1)))
    %%%%%: 1706-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1706-block  1
branch  2 never executed
branch  3 never executed
        -: 1707:                {
    #####: 1708:                    pixels[(y+1)*image->width + x+1].r = MIN((int)pixels[(y+1)*image->width + x+1].r + (int)((float)rError*1.0f/16), 0xff);
    #####: 1709:                    pixels[(y+1)*image->width + x+1].g = MIN((int)pixels[(y+1)*image->width + x+1].g + (int)((float)gError*1.0f/16), 0xff);
    #####: 1710:                    pixels[(y+1)*image->width + x+1].b = MIN((int)pixels[(y+1)*image->width + x+1].b + (int)((float)bError*1.0f/16), 0xff);
    %%%%%: 1710-block  0
        -: 1711:                }
        -: 1712:
    #####: 1713:                rPixel = (unsigned short)newPixel.r;
    #####: 1714:                gPixel = (unsigned short)newPixel.g;
    #####: 1715:                bPixel = (unsigned short)newPixel.b;
    #####: 1716:                aPixel = (unsigned short)newPixel.a;
        -: 1717:
    #####: 1718:                ((unsigned short *)image->data)[y*image->width + x] = (rPixel << (gBpp + bBpp + aBpp)) | (gPixel << (bBpp + aBpp)) | (bPixel << aBpp) | aPixel;
    %%%%%: 1718-block  0
        -: 1719:            }
        -: 1720:        }
        -: 1721:
    #####: 1722:        UnloadImageColors(pixels);
    %%%%%: 1722-block  0
call    0 never executed
        -: 1723:    }
        -: 1724:}
        -: 1725:
        -: 1726:// Flip image vertically
function ImageFlipVertical called 0 returned 0% blocks executed 0%
    #####: 1727:void ImageFlipVertical(Image *image)
        -: 1728:{
        -: 1729:    // Security check to avoid program crash
    #####: 1730:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1730-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1730-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1730-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1730-block  3
        -: 1731:
    #####: 1732:    if (image->mipmaps > 1) TRACELOG(LOG_WARNING, "Image manipulation only applied to base mipmap level");
    %%%%%: 1732-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1732-block  1
call    2 never executed
    #####: 1733:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image manipulation not supported for compressed formats");
    %%%%%: 1733-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1733-block  1
call    2 never executed
        -: 1734:    else
        -: 1735:    {
    #####: 1736:        int bytesPerPixel = GetPixelDataSize(1, 1, image->format);
    %%%%%: 1736-block  0
call    0 never executed
    #####: 1737:        unsigned char *flippedData = (unsigned char *)RL_MALLOC(image->width*image->height*bytesPerPixel);
        -: 1738:
    #####: 1739:        for (int i = (image->height - 1), offsetSize = 0; i >= 0; i--)
    %%%%%: 1739-block  0
branch  0 never executed
branch  1 never executed
        -: 1740:        {
    #####: 1741:            memcpy(flippedData + offsetSize, ((unsigned char *)image->data) + i*image->width*bytesPerPixel, image->width*bytesPerPixel);
    #####: 1742:            offsetSize += image->width*bytesPerPixel;
    %%%%%: 1742-block  0
        -: 1743:        }
        -: 1744:
    #####: 1745:        RL_FREE(image->data);
    #####: 1746:        image->data = flippedData;
    %%%%%: 1746-block  0
        -: 1747:    }
        -: 1748:}
        -: 1749:
        -: 1750:// Flip image horizontally
function ImageFlipHorizontal called 0 returned 0% blocks executed 0%
    #####: 1751:void ImageFlipHorizontal(Image *image)
        -: 1752:{
        -: 1753:    // Security check to avoid program crash
    #####: 1754:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1754-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1754-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1754-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1754-block  3
        -: 1755:
    #####: 1756:    if (image->mipmaps > 1) TRACELOG(LOG_WARNING, "Image manipulation only applied to base mipmap level");
    %%%%%: 1756-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1756-block  1
call    2 never executed
    #####: 1757:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image manipulation not supported for compressed formats");
    %%%%%: 1757-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1757-block  1
call    2 never executed
        -: 1758:    else
        -: 1759:    {
    #####: 1760:        int bytesPerPixel = GetPixelDataSize(1, 1, image->format);
    %%%%%: 1760-block  0
call    0 never executed
    #####: 1761:        unsigned char *flippedData = (unsigned char *)RL_MALLOC(image->width*image->height*bytesPerPixel);
        -: 1762:
    #####: 1763:        for (int y = 0; y < image->height; y++)
    %%%%%: 1763-block  0
    %%%%%: 1763-block  1
branch  0 never executed
branch  1 never executed
        -: 1764:        {
    #####: 1765:            for (int x = 0; x < image->width; x++)
    %%%%%: 1765-block  0
    %%%%%: 1765-block  1
    %%%%%: 1765-block  2
branch  0 never executed
branch  1 never executed
        -: 1766:            {
        -: 1767:                // OPTION 1: Move pixels with memcopy()
        -: 1768:                //memcpy(flippedData + (y*image->width + x)*bytesPerPixel, ((unsigned char *)image->data) + (y*image->width + (image->width - 1 - x))*bytesPerPixel, bytesPerPixel);
        -: 1769:
        -: 1770:                // OPTION 2: Just copy data pixel by pixel
    #####: 1771:                for (int i = 0; i < bytesPerPixel; i++) flippedData[(y*image->width + x)*bytesPerPixel + i] = ((unsigned char *)image->data)[(y*image->width + (image->width - 1 - x))*bytesPerPixel + i];
    %%%%%: 1771-block  0
    %%%%%: 1771-block  1
    %%%%%: 1771-block  2
branch  0 never executed
branch  1 never executed
        -: 1772:            }
        -: 1773:        }
        -: 1774:
    #####: 1775:        RL_FREE(image->data);
    #####: 1776:        image->data = flippedData;
    %%%%%: 1776-block  0
        -: 1777:
        -: 1778:        /*
        -: 1779:        // OPTION 3: Faster implementation (specific for 32bit pixels)
        -: 1780:        // NOTE: It does not require additional allocations
        -: 1781:        uint32_t *ptr = (uint32_t *)image->data;
        -: 1782:        for (int y = 0; y < image->height; y++)
        -: 1783:        {
        -: 1784:            for (int x = 0; x < image->width/2; x++)
        -: 1785:            {
        -: 1786:                uint32_t backup = ptr[y*image->width + x];
        -: 1787:                ptr[y*image->width + x] = ptr[y*image->width + (image->width - 1 - x)];
        -: 1788:                ptr[y*image->width + (image->width - 1 - x)] = backup;
        -: 1789:            }
        -: 1790:        }
        -: 1791:        */
        -: 1792:    }
        -: 1793:}
        -: 1794:
        -: 1795:// Rotate image clockwise 90deg
function ImageRotateCW called 0 returned 0% blocks executed 0%
    #####: 1796:void ImageRotateCW(Image *image)
        -: 1797:{
        -: 1798:    // Security check to avoid program crash
    #####: 1799:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1799-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1799-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1799-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1799-block  3
        -: 1800:
    #####: 1801:    if (image->mipmaps > 1) TRACELOG(LOG_WARNING, "Image manipulation only applied to base mipmap level");
    %%%%%: 1801-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1801-block  1
call    2 never executed
    #####: 1802:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image manipulation not supported for compressed formats");
    %%%%%: 1802-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1802-block  1
call    2 never executed
        -: 1803:    else
        -: 1804:    {
    #####: 1805:        int bytesPerPixel = GetPixelDataSize(1, 1, image->format);
    %%%%%: 1805-block  0
call    0 never executed
    #####: 1806:        unsigned char *rotatedData = (unsigned char *)RL_MALLOC(image->width*image->height*bytesPerPixel);
        -: 1807:
    #####: 1808:        for (int y = 0; y < image->height; y++)
    %%%%%: 1808-block  0
    %%%%%: 1808-block  1
branch  0 never executed
branch  1 never executed
        -: 1809:        {
    #####: 1810:            for (int x = 0; x < image->width; x++)
    %%%%%: 1810-block  0
    %%%%%: 1810-block  1
    %%%%%: 1810-block  2
branch  0 never executed
branch  1 never executed
        -: 1811:            {
        -: 1812:                //memcpy(rotatedData + (x*image->height + (image->height - y - 1))*bytesPerPixel, ((unsigned char *)image->data) + (y*image->width + x)*bytesPerPixel, bytesPerPixel);
    #####: 1813:                for (int i = 0; i < bytesPerPixel; i++) rotatedData[(x*image->height + (image->height - y - 1))*bytesPerPixel + i] = ((unsigned char *)image->data)[(y*image->width + x)*bytesPerPixel + i];
    %%%%%: 1813-block  0
    %%%%%: 1813-block  1
    %%%%%: 1813-block  2
branch  0 never executed
branch  1 never executed
        -: 1814:            }
        -: 1815:        }
        -: 1816:
    #####: 1817:        RL_FREE(image->data);
    #####: 1818:        image->data = rotatedData;
    #####: 1819:        int width = image->width;
    #####: 1820:        int height = image-> height;
        -: 1821:
    #####: 1822:        image->width = height;
    #####: 1823:        image->height = width;
    %%%%%: 1823-block  0
        -: 1824:    }
        -: 1825:}
        -: 1826:
        -: 1827:// Rotate image counter-clockwise 90deg
function ImageRotateCCW called 0 returned 0% blocks executed 0%
    #####: 1828:void ImageRotateCCW(Image *image)
        -: 1829:{
        -: 1830:    // Security check to avoid program crash
    #####: 1831:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1831-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1831-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1831-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1831-block  3
        -: 1832:
    #####: 1833:    if (image->mipmaps > 1) TRACELOG(LOG_WARNING, "Image manipulation only applied to base mipmap level");
    %%%%%: 1833-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1833-block  1
call    2 never executed
    #####: 1834:    if (image->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image manipulation not supported for compressed formats");
    %%%%%: 1834-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1834-block  1
call    2 never executed
        -: 1835:    else
        -: 1836:    {
    #####: 1837:        int bytesPerPixel = GetPixelDataSize(1, 1, image->format);
    %%%%%: 1837-block  0
call    0 never executed
    #####: 1838:        unsigned char *rotatedData = (unsigned char *)RL_MALLOC(image->width*image->height*bytesPerPixel);
        -: 1839:
    #####: 1840:        for (int y = 0; y < image->height; y++)
    %%%%%: 1840-block  0
    %%%%%: 1840-block  1
branch  0 never executed
branch  1 never executed
        -: 1841:        {
    #####: 1842:            for (int x = 0; x < image->width; x++)
    %%%%%: 1842-block  0
    %%%%%: 1842-block  1
    %%%%%: 1842-block  2
branch  0 never executed
branch  1 never executed
        -: 1843:            {
        -: 1844:                //memcpy(rotatedData + (x*image->height + y))*bytesPerPixel, ((unsigned char *)image->data) + (y*image->width + (image->width - x - 1))*bytesPerPixel, bytesPerPixel);
    #####: 1845:                for (int i = 0; i < bytesPerPixel; i++) rotatedData[(x*image->height + y)*bytesPerPixel + i] = ((unsigned char *)image->data)[(y*image->width + (image->width - x - 1))*bytesPerPixel + i];
    %%%%%: 1845-block  0
    %%%%%: 1845-block  1
    %%%%%: 1845-block  2
branch  0 never executed
branch  1 never executed
        -: 1846:            }
        -: 1847:        }
        -: 1848:
    #####: 1849:        RL_FREE(image->data);
    #####: 1850:        image->data = rotatedData;
    #####: 1851:        int width = image->width;
    #####: 1852:        int height = image-> height;
        -: 1853:
    #####: 1854:        image->width = height;
    #####: 1855:        image->height = width;
    %%%%%: 1855-block  0
        -: 1856:    }
        -: 1857:}
        -: 1858:
        -: 1859:// Modify image color: tint
function ImageColorTint called 0 returned 0% blocks executed 0%
    #####: 1860:void ImageColorTint(Image *image, Color color)
        -: 1861:{
        -: 1862:    // Security check to avoid program crash
    #####: 1863:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1863-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1863-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1863-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1863-block  3
        -: 1864:
    #####: 1865:    Color *pixels = LoadImageColors(*image);
    %%%%%: 1865-block  0
call    0 never executed
        -: 1866:
    #####: 1867:    float cR = (float)color.r/255;
    #####: 1868:    float cG = (float)color.g/255;
    #####: 1869:    float cB = (float)color.b/255;
    #####: 1870:    float cA = (float)color.a/255;
        -: 1871:
    #####: 1872:    for (int y = 0; y < image->height; y++)
    %%%%%: 1872-block  0
    %%%%%: 1872-block  1
branch  0 never executed
branch  1 never executed
        -: 1873:    {
    #####: 1874:        for (int x = 0; x < image->width; x++)
    %%%%%: 1874-block  0
    %%%%%: 1874-block  1
branch  0 never executed
branch  1 never executed
        -: 1875:        {
    #####: 1876:            int index = y*image->width + x;
    #####: 1877:            unsigned char r = (unsigned char)(((float)pixels[index].r/255*cR)*255.0f);
    #####: 1878:            unsigned char g = (unsigned char)(((float)pixels[index].g/255*cG)*255.0f);
    #####: 1879:            unsigned char b = (unsigned char)(((float)pixels[index].b/255*cB)*255.0f);
    #####: 1880:            unsigned char a = (unsigned char)(((float)pixels[index].a/255*cA)*255.0f);
        -: 1881:
    #####: 1882:            pixels[y*image->width + x].r = r;
    #####: 1883:            pixels[y*image->width + x].g = g;
    #####: 1884:            pixels[y*image->width + x].b = b;
    #####: 1885:            pixels[y*image->width + x].a = a;
    %%%%%: 1885-block  0
        -: 1886:        }
        -: 1887:    }
        -: 1888:
    #####: 1889:    int format = image->format;
    #####: 1890:    RL_FREE(image->data);
        -: 1891:
    #####: 1892:    image->data = pixels;
    #####: 1893:    image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 1894:
    #####: 1895:    ImageFormat(image, format);
    %%%%%: 1895-block  0
call    0 never executed
        -: 1896:}
        -: 1897:
        -: 1898:// Modify image color: invert
function ImageColorInvert called 0 returned 0% blocks executed 0%
    #####: 1899:void ImageColorInvert(Image *image)
        -: 1900:{
        -: 1901:    // Security check to avoid program crash
    #####: 1902:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1902-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1902-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1902-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1902-block  3
        -: 1903:
    #####: 1904:    Color *pixels = LoadImageColors(*image);
    %%%%%: 1904-block  0
call    0 never executed
        -: 1905:
    #####: 1906:    for (int y = 0; y < image->height; y++)
    %%%%%: 1906-block  0
    %%%%%: 1906-block  1
branch  0 never executed
branch  1 never executed
        -: 1907:    {
    #####: 1908:        for (int x = 0; x < image->width; x++)
    %%%%%: 1908-block  0
    %%%%%: 1908-block  1
branch  0 never executed
branch  1 never executed
        -: 1909:        {
    #####: 1910:            pixels[y*image->width + x].r = 255 - pixels[y*image->width + x].r;
    #####: 1911:            pixels[y*image->width + x].g = 255 - pixels[y*image->width + x].g;
    #####: 1912:            pixels[y*image->width + x].b = 255 - pixels[y*image->width + x].b;
    %%%%%: 1912-block  0
        -: 1913:        }
        -: 1914:    }
        -: 1915:
    #####: 1916:    int format = image->format;
    #####: 1917:    RL_FREE(image->data);
        -: 1918:
    #####: 1919:    image->data = pixels;
    #####: 1920:    image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 1921:
    #####: 1922:    ImageFormat(image, format);
    %%%%%: 1922-block  0
call    0 never executed
        -: 1923:}
        -: 1924:
        -: 1925:// Modify image color: grayscale
function ImageColorGrayscale called 0 returned 0% blocks executed 0%
    #####: 1926:void ImageColorGrayscale(Image *image)
        -: 1927:{
    #####: 1928:    ImageFormat(image, PIXELFORMAT_UNCOMPRESSED_GRAYSCALE);
    %%%%%: 1928-block  0
call    0 never executed
    #####: 1929:}
        -: 1930:
        -: 1931:// Modify image color: contrast
        -: 1932:// NOTE: Contrast values between -100 and 100
function ImageColorContrast called 0 returned 0% blocks executed 0%
    #####: 1933:void ImageColorContrast(Image *image, float contrast)
        -: 1934:{
        -: 1935:    // Security check to avoid program crash
    #####: 1936:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1936-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1936-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1936-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1936-block  3
        -: 1937:
    #####: 1938:    if (contrast < -100) contrast = -100;
    %%%%%: 1938-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1938-block  1
    #####: 1939:    if (contrast > 100) contrast = 100;
    %%%%%: 1939-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1939-block  1
        -: 1940:
    #####: 1941:    contrast = (100.0f + contrast)/100.0f;
    #####: 1942:    contrast *= contrast;
        -: 1943:
    #####: 1944:    Color *pixels = LoadImageColors(*image);
    %%%%%: 1944-block  0
call    0 never executed
        -: 1945:
    #####: 1946:    for (int y = 0; y < image->height; y++)
    %%%%%: 1946-block  0
    %%%%%: 1946-block  1
branch  0 never executed
branch  1 never executed
        -: 1947:    {
    #####: 1948:        for (int x = 0; x < image->width; x++)
    %%%%%: 1948-block  0
    %%%%%: 1948-block  1
branch  0 never executed
branch  1 never executed
        -: 1949:        {
    #####: 1950:            float pR = (float)pixels[y*image->width + x].r/255.0f;
    #####: 1951:            pR -= 0.5;
    #####: 1952:            pR *= contrast;
    #####: 1953:            pR += 0.5;
    #####: 1954:            pR *= 255;
    #####: 1955:            if (pR < 0) pR = 0;
    %%%%%: 1955-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1955-block  1
    #####: 1956:            if (pR > 255) pR = 255;
    %%%%%: 1956-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1956-block  1
        -: 1957:
    #####: 1958:            float pG = (float)pixels[y*image->width + x].g/255.0f;
    #####: 1959:            pG -= 0.5;
    #####: 1960:            pG *= contrast;
    #####: 1961:            pG += 0.5;
    #####: 1962:            pG *= 255;
    #####: 1963:            if (pG < 0) pG = 0;
    %%%%%: 1963-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1963-block  1
    #####: 1964:            if (pG > 255) pG = 255;
    %%%%%: 1964-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1964-block  1
        -: 1965:
    #####: 1966:            float pB = (float)pixels[y*image->width + x].b/255.0f;
    #####: 1967:            pB -= 0.5;
    #####: 1968:            pB *= contrast;
    #####: 1969:            pB += 0.5;
    #####: 1970:            pB *= 255;
    #####: 1971:            if (pB < 0) pB = 0;
    %%%%%: 1971-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1971-block  1
    #####: 1972:            if (pB > 255) pB = 255;
    %%%%%: 1972-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1972-block  1
        -: 1973:
    #####: 1974:            pixels[y*image->width + x].r = (unsigned char)pR;
    #####: 1975:            pixels[y*image->width + x].g = (unsigned char)pG;
    #####: 1976:            pixels[y*image->width + x].b = (unsigned char)pB;
    %%%%%: 1976-block  0
        -: 1977:        }
        -: 1978:    }
        -: 1979:
    #####: 1980:    int format = image->format;
    #####: 1981:    RL_FREE(image->data);
        -: 1982:
    #####: 1983:    image->data = pixels;
    #####: 1984:    image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 1985:
    #####: 1986:    ImageFormat(image, format);
    %%%%%: 1986-block  0
call    0 never executed
        -: 1987:}
        -: 1988:
        -: 1989:// Modify image color: brightness
        -: 1990:// NOTE: Brightness values between -255 and 255
function ImageColorBrightness called 0 returned 0% blocks executed 0%
    #####: 1991:void ImageColorBrightness(Image *image, int brightness)
        -: 1992:{
        -: 1993:    // Security check to avoid program crash
    #####: 1994:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 1994-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1994-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1994-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1994-block  3
        -: 1995:
    #####: 1996:    if (brightness < -255) brightness = -255;
    %%%%%: 1996-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1996-block  1
    #####: 1997:    if (brightness > 255) brightness = 255;
    %%%%%: 1997-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1997-block  1
        -: 1998:
    #####: 1999:    Color *pixels = LoadImageColors(*image);
    %%%%%: 1999-block  0
call    0 never executed
        -: 2000:
    #####: 2001:    for (int y = 0; y < image->height; y++)
    %%%%%: 2001-block  0
    %%%%%: 2001-block  1
branch  0 never executed
branch  1 never executed
        -: 2002:    {
    #####: 2003:        for (int x = 0; x < image->width; x++)
    %%%%%: 2003-block  0
    %%%%%: 2003-block  1
branch  0 never executed
branch  1 never executed
        -: 2004:        {
    #####: 2005:            int cR = pixels[y*image->width + x].r + brightness;
    #####: 2006:            int cG = pixels[y*image->width + x].g + brightness;
    #####: 2007:            int cB = pixels[y*image->width + x].b + brightness;
        -: 2008:
    #####: 2009:            if (cR < 0) cR = 1;
    %%%%%: 2009-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2009-block  1
    #####: 2010:            if (cR > 255) cR = 255;
    %%%%%: 2010-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2010-block  1
        -: 2011:
    #####: 2012:            if (cG < 0) cG = 1;
    %%%%%: 2012-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2012-block  1
    #####: 2013:            if (cG > 255) cG = 255;
    %%%%%: 2013-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2013-block  1
        -: 2014:
    #####: 2015:            if (cB < 0) cB = 1;
    %%%%%: 2015-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2015-block  1
    #####: 2016:            if (cB > 255) cB = 255;
    %%%%%: 2016-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2016-block  1
        -: 2017:
    #####: 2018:            pixels[y*image->width + x].r = (unsigned char)cR;
    #####: 2019:            pixels[y*image->width + x].g = (unsigned char)cG;
    #####: 2020:            pixels[y*image->width + x].b = (unsigned char)cB;
    %%%%%: 2020-block  0
        -: 2021:        }
        -: 2022:    }
        -: 2023:
    #####: 2024:    int format = image->format;
    #####: 2025:    RL_FREE(image->data);
        -: 2026:
    #####: 2027:    image->data = pixels;
    #####: 2028:    image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 2029:
    #####: 2030:    ImageFormat(image, format);
    %%%%%: 2030-block  0
call    0 never executed
        -: 2031:}
        -: 2032:
        -: 2033:// Modify image color: replace color
function ImageColorReplace called 0 returned 0% blocks executed 0%
    #####: 2034:void ImageColorReplace(Image *image, Color color, Color replace)
        -: 2035:{
        -: 2036:    // Security check to avoid program crash
    #####: 2037:    if ((image->data == NULL) || (image->width == 0) || (image->height == 0)) return;
    %%%%%: 2037-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2037-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2037-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 2037-block  3
        -: 2038:
    #####: 2039:    Color *pixels = LoadImageColors(*image);
    %%%%%: 2039-block  0
call    0 never executed
        -: 2040:
    #####: 2041:    for (int y = 0; y < image->height; y++)
    %%%%%: 2041-block  0
    %%%%%: 2041-block  1
branch  0 never executed
branch  1 never executed
        -: 2042:    {
    #####: 2043:        for (int x = 0; x < image->width; x++)
    %%%%%: 2043-block  0
    %%%%%: 2043-block  1
    %%%%%: 2043-block  2
branch  0 never executed
branch  1 never executed
        -: 2044:        {
    #####: 2045:            if ((pixels[y*image->width + x].r == color.r) &&
    %%%%%: 2045-block  0
branch  0 never executed
branch  1 never executed
    #####: 2046:                (pixels[y*image->width + x].g == color.g) &&
    %%%%%: 2046-block  0
branch  0 never executed
branch  1 never executed
    #####: 2047:                (pixels[y*image->width + x].b == color.b) &&
    %%%%%: 2047-block  0
branch  0 never executed
branch  1 never executed
    #####: 2048:                (pixels[y*image->width + x].a == color.a))
    %%%%%: 2048-block  0
branch  0 never executed
branch  1 never executed
        -: 2049:            {
    #####: 2050:                pixels[y*image->width + x].r = replace.r;
    #####: 2051:                pixels[y*image->width + x].g = replace.g;
    #####: 2052:                pixels[y*image->width + x].b = replace.b;
    #####: 2053:                pixels[y*image->width + x].a = replace.a;
    %%%%%: 2053-block  0
        -: 2054:            }
        -: 2055:        }
        -: 2056:    }
        -: 2057:
    #####: 2058:    int format = image->format;
    #####: 2059:    RL_FREE(image->data);
        -: 2060:
    #####: 2061:    image->data = pixels;
    #####: 2062:    image->format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 2063:
    #####: 2064:    ImageFormat(image, format);
    %%%%%: 2064-block  0
call    0 never executed
        -: 2065:}
        -: 2066:#endif      // SUPPORT_IMAGE_MANIPULATION
        -: 2067:
        -: 2068:// Load color data from image as a Color array (RGBA - 32bit)
        -: 2069:// NOTE: Memory allocated should be freed using UnloadImageColors();
function LoadImageColors called 0 returned 0% blocks executed 0%
    #####: 2070:Color *LoadImageColors(Image image)
        -: 2071:{
    #####: 2072:    if ((image.width == 0) || (image.height == 0)) return NULL;
    %%%%%: 2072-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2072-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2072-block  2
        -: 2073:
    #####: 2074:    Color *pixels = (Color *)RL_MALLOC(image.width*image.height*sizeof(Color));
        -: 2075:
    #####: 2076:    if (image.format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "IMAGE: Pixel data retrieval not supported for compressed image formats");
    %%%%%: 2076-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2076-block  1
call    2 never executed
        -: 2077:    else
        -: 2078:    {
    #####: 2079:        if ((image.format == PIXELFORMAT_UNCOMPRESSED_R32) ||
    %%%%%: 2079-block  0
branch  0 never executed
branch  1 never executed
    #####: 2080:            (image.format == PIXELFORMAT_UNCOMPRESSED_R32G32B32) ||
    %%%%%: 2080-block  0
branch  0 never executed
branch  1 never executed
    #####: 2081:            (image.format == PIXELFORMAT_UNCOMPRESSED_R32G32B32A32)) TRACELOG(LOG_WARNING, "IMAGE: Pixel format converted from 32bit to 8bit per channel");
    %%%%%: 2081-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2081-block  1
call    2 never executed
        -: 2082:
    #####: 2083:        for (int i = 0, k = 0; i < image.width*image.height; i++)
    %%%%%: 2083-block  0
    %%%%%: 2083-block  1
    %%%%%: 2083-block  2
branch  0 never executed
branch  1 never executed
        -: 2084:        {
    #####: 2085:            switch (image.format)
    %%%%%: 2085-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 2086:            {
    #####: 2087:                case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE:
        -: 2088:                {
    #####: 2089:                    pixels[i].r = ((unsigned char *)image.data)[i];
    #####: 2090:                    pixels[i].g = ((unsigned char *)image.data)[i];
    #####: 2091:                    pixels[i].b = ((unsigned char *)image.data)[i];
    #####: 2092:                    pixels[i].a = 255;
        -: 2093:
    #####: 2094:                } break;
    %%%%%: 2094-block  0
    #####: 2095:                case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 2096:                {
    #####: 2097:                    pixels[i].r = ((unsigned char *)image.data)[k];
    #####: 2098:                    pixels[i].g = ((unsigned char *)image.data)[k];
    #####: 2099:                    pixels[i].b = ((unsigned char *)image.data)[k];
    #####: 2100:                    pixels[i].a = ((unsigned char *)image.data)[k + 1];
        -: 2101:
    #####: 2102:                    k += 2;
    #####: 2103:                } break;
    %%%%%: 2103-block  0
    #####: 2104:                case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 2105:                {
    #####: 2106:                    unsigned short pixel = ((unsigned short *)image.data)[i];
        -: 2107:
    #####: 2108:                    pixels[i].r = (unsigned char)((float)((pixel & 0b1111100000000000) >> 11)*(255/31));
    #####: 2109:                    pixels[i].g = (unsigned char)((float)((pixel & 0b0000011111000000) >> 6)*(255/31));
    #####: 2110:                    pixels[i].b = (unsigned char)((float)((pixel & 0b0000000000111110) >> 1)*(255/31));
    #####: 2111:                    pixels[i].a = (unsigned char)((pixel & 0b0000000000000001)*255);
        -: 2112:
    #####: 2113:                } break;
    %%%%%: 2113-block  0
    #####: 2114:                case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 2115:                {
    #####: 2116:                    unsigned short pixel = ((unsigned short *)image.data)[i];
        -: 2117:
    #####: 2118:                    pixels[i].r = (unsigned char)((float)((pixel & 0b1111100000000000) >> 11)*(255/31));
    #####: 2119:                    pixels[i].g = (unsigned char)((float)((pixel & 0b0000011111100000) >> 5)*(255/63));
    #####: 2120:                    pixels[i].b = (unsigned char)((float)(pixel & 0b0000000000011111)*(255/31));
    #####: 2121:                    pixels[i].a = 255;
        -: 2122:
    #####: 2123:                } break;
    %%%%%: 2123-block  0
    #####: 2124:                case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4:
        -: 2125:                {
    #####: 2126:                    unsigned short pixel = ((unsigned short *)image.data)[i];
        -: 2127:
    #####: 2128:                    pixels[i].r = (unsigned char)((float)((pixel & 0b1111000000000000) >> 12)*(255/15));
    #####: 2129:                    pixels[i].g = (unsigned char)((float)((pixel & 0b0000111100000000) >> 8)*(255/15));
    #####: 2130:                    pixels[i].b = (unsigned char)((float)((pixel & 0b0000000011110000) >> 4)*(255/15));
    #####: 2131:                    pixels[i].a = (unsigned char)((float)(pixel & 0b0000000000001111)*(255/15));
        -: 2132:
    #####: 2133:                } break;
    %%%%%: 2133-block  0
    #####: 2134:                case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8:
        -: 2135:                {
    #####: 2136:                    pixels[i].r = ((unsigned char *)image.data)[k];
    #####: 2137:                    pixels[i].g = ((unsigned char *)image.data)[k + 1];
    #####: 2138:                    pixels[i].b = ((unsigned char *)image.data)[k + 2];
    #####: 2139:                    pixels[i].a = ((unsigned char *)image.data)[k + 3];
        -: 2140:
    #####: 2141:                    k += 4;
    #####: 2142:                } break;
    %%%%%: 2142-block  0
    #####: 2143:                case PIXELFORMAT_UNCOMPRESSED_R8G8B8:
        -: 2144:                {
    #####: 2145:                    pixels[i].r = (unsigned char)((unsigned char *)image.data)[k];
    #####: 2146:                    pixels[i].g = (unsigned char)((unsigned char *)image.data)[k + 1];
    #####: 2147:                    pixels[i].b = (unsigned char)((unsigned char *)image.data)[k + 2];
    #####: 2148:                    pixels[i].a = 255;
        -: 2149:
    #####: 2150:                    k += 3;
    #####: 2151:                } break;
    %%%%%: 2151-block  0
    #####: 2152:                case PIXELFORMAT_UNCOMPRESSED_R32:
        -: 2153:                {
    #####: 2154:                    pixels[i].r = (unsigned char)(((float *)image.data)[k]*255.0f);
    #####: 2155:                    pixels[i].g = 0;
    #####: 2156:                    pixels[i].b = 0;
    #####: 2157:                    pixels[i].a = 255;
        -: 2158:
    #####: 2159:                } break;
    %%%%%: 2159-block  0
    #####: 2160:                case PIXELFORMAT_UNCOMPRESSED_R32G32B32:
        -: 2161:                {
    #####: 2162:                    pixels[i].r = (unsigned char)(((float *)image.data)[k]*255.0f);
    #####: 2163:                    pixels[i].g = (unsigned char)(((float *)image.data)[k + 1]*255.0f);
    #####: 2164:                    pixels[i].b = (unsigned char)(((float *)image.data)[k + 2]*255.0f);
    #####: 2165:                    pixels[i].a = 255;
        -: 2166:
    #####: 2167:                    k += 3;
    #####: 2168:                } break;
    %%%%%: 2168-block  0
    #####: 2169:                case PIXELFORMAT_UNCOMPRESSED_R32G32B32A32:
        -: 2170:                {
    #####: 2171:                    pixels[i].r = (unsigned char)(((float *)image.data)[k]*255.0f);
    #####: 2172:                    pixels[i].g = (unsigned char)(((float *)image.data)[k]*255.0f);
    #####: 2173:                    pixels[i].b = (unsigned char)(((float *)image.data)[k]*255.0f);
    #####: 2174:                    pixels[i].a = (unsigned char)(((float *)image.data)[k]*255.0f);
        -: 2175:
    #####: 2176:                    k += 4;
    #####: 2177:                } break;
    %%%%%: 2177-block  0
    #####: 2178:                default: break;
    %%%%%: 2178-block  0
        -: 2179:            }
        -: 2180:        }
        -: 2181:    }
        -: 2182:
    #####: 2183:    return pixels;
    %%%%%: 2183-block  0
        -: 2184:}
        -: 2185:
        -: 2186:// Load colors palette from image as a Color array (RGBA - 32bit)
        -: 2187:// NOTE: Memory allocated should be freed using UnloadImagePalette()
function LoadImagePalette called 0 returned 0% blocks executed 0%
    #####: 2188:Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
        -: 2189:{
        -: 2190:    #define COLOR_EQUAL(col1, col2) ((col1.r == col2.r)&&(col1.g == col2.g)&&(col1.b == col2.b)&&(col1.a == col2.a))
        -: 2191:
    #####: 2192:    int palCount = 0;
    #####: 2193:    Color *palette = NULL;
    #####: 2194:    Color *pixels = LoadImageColors(image);
    %%%%%: 2194-block  0
call    0 never executed
        -: 2195:
    #####: 2196:    if (pixels != NULL)
branch  0 never executed
branch  1 never executed
        -: 2197:    {
    #####: 2198:        palette = (Color *)RL_MALLOC(maxPaletteSize*sizeof(Color));
        -: 2199:
    #####: 2200:        for (int i = 0; i < maxPaletteSize; i++) palette[i] = BLANK;   // Set all colors to BLANK
    %%%%%: 2200-block  0
    %%%%%: 2200-block  1
    %%%%%: 2200-block  2
branch  0 never executed
branch  1 never executed
        -: 2201:
    #####: 2202:        for (int i = 0; i < image.width*image.height; i++)
    %%%%%: 2202-block  0
    %%%%%: 2202-block  1
    %%%%%: 2202-block  2
branch  0 never executed
branch  1 never executed
        -: 2203:        {
    #####: 2204:            if (pixels[i].a > 0)
    %%%%%: 2204-block  0
branch  0 never executed
branch  1 never executed
        -: 2205:            {
    #####: 2206:                bool colorInPalette = false;
        -: 2207:
        -: 2208:                // Check if the color is already on palette
    #####: 2209:                for (int j = 0; j < maxPaletteSize; j++)
    %%%%%: 2209-block  0
    %%%%%: 2209-block  1
    %%%%%: 2209-block  2
branch  0 never executed
branch  1 never executed
        -: 2210:                {
    #####: 2211:                    if (COLOR_EQUAL(pixels[i], palette[j]))
    %%%%%: 2211-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2211-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2211-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 2211-block  3
branch  6 never executed
branch  7 never executed
        -: 2212:                    {
    #####: 2213:                        colorInPalette = true;
    #####: 2214:                        break;
    %%%%%: 2214-block  0
        -: 2215:                    }
        -: 2216:                }
        -: 2217:
        -: 2218:                // Store color if not on the palette
    #####: 2219:                if (!colorInPalette)
    %%%%%: 2219-block  0
branch  0 never executed
branch  1 never executed
        -: 2220:                {
    #####: 2221:                    palette[palCount] = pixels[i];      // Add pixels[i] to palette
    #####: 2222:                    palCount++;
        -: 2223:
        -: 2224:                    // We reached the limit of colors supported by palette
    #####: 2225:                    if (palCount >= maxPaletteSize)
    %%%%%: 2225-block  0
branch  0 never executed
branch  1 never executed
        -: 2226:                    {
    #####: 2227:                        i = image.width*image.height;   // Finish palette get
    #####: 2228:                        TRACELOG(LOG_WARNING, "IMAGE: Palette is greater than %i colors", maxPaletteSize);
    %%%%%: 2228-block  0
call    0 never executed
        -: 2229:                    }
        -: 2230:                }
        -: 2231:            }
        -: 2232:        }
        -: 2233:
    #####: 2234:        UnloadImageColors(pixels);
    %%%%%: 2234-block  0
call    0 never executed
        -: 2235:    }
        -: 2236:
    #####: 2237:    *colorCount = palCount;
        -: 2238:
    #####: 2239:    return palette;
    %%%%%: 2239-block  0
        -: 2240:}
        -: 2241:
        -: 2242:// Unload color data loaded with LoadImageColors()
function UnloadImageColors called 0 returned 0% blocks executed 0%
    #####: 2243:void UnloadImageColors(Color *colors)
        -: 2244:{
    #####: 2245:    RL_FREE(colors);
    #####: 2246:}
        -: 2247:
        -: 2248:// Unload colors palette loaded with LoadImagePalette()
function UnloadImagePalette called 0 returned 0% blocks executed 0%
    #####: 2249:void UnloadImagePalette(Color *colors)
        -: 2250:{
    #####: 2251:    RL_FREE(colors);
    #####: 2252:}
        -: 2253:
        -: 2254:// Get image alpha border rectangle
        -: 2255:// NOTE: Threshold is defined as a percentatge: 0.0f -> 1.0f
function GetImageAlphaBorder called 0 returned 0% blocks executed 0%
    #####: 2256:Rectangle GetImageAlphaBorder(Image image, float threshold)
        -: 2257:{
    #####: 2258:    Rectangle crop = { 0 };
        -: 2259:
    #####: 2260:    Color *pixels = LoadImageColors(image);
    %%%%%: 2260-block  0
call    0 never executed
        -: 2261:
    #####: 2262:    if (pixels != NULL)
branch  0 never executed
branch  1 never executed
        -: 2263:    {
    #####: 2264:        int xMin = 65536;   // Define a big enough number
    #####: 2265:        int xMax = 0;
    #####: 2266:        int yMin = 65536;
    #####: 2267:        int yMax = 0;
        -: 2268:
    #####: 2269:        for (int y = 0; y < image.height; y++)
    %%%%%: 2269-block  0
    %%%%%: 2269-block  1
    %%%%%: 2269-block  2
branch  0 never executed
branch  1 never executed
        -: 2270:        {
    #####: 2271:            for (int x = 0; x < image.width; x++)
    %%%%%: 2271-block  0
    %%%%%: 2271-block  1
    %%%%%: 2271-block  2
branch  0 never executed
branch  1 never executed
        -: 2272:            {
    #####: 2273:                if (pixels[y*image.width + x].a > (unsigned char)(threshold*255.0f))
    %%%%%: 2273-block  0
branch  0 never executed
branch  1 never executed
        -: 2274:                {
    #####: 2275:                    if (x < xMin) xMin = x;
    %%%%%: 2275-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2275-block  1
    #####: 2276:                    if (x > xMax) xMax = x;
    %%%%%: 2276-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2276-block  1
    #####: 2277:                    if (y < yMin) yMin = y;
    %%%%%: 2277-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2277-block  1
    #####: 2278:                    if (y > yMax) yMax = y;
    %%%%%: 2278-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2278-block  1
        -: 2279:                }
        -: 2280:            }
        -: 2281:        }
        -: 2282:
        -: 2283:        // Check for empty blank image
    #####: 2284:        if ((xMin != 65536) && (xMax != 65536))
    %%%%%: 2284-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2284-block  1
branch  2 never executed
branch  3 never executed
        -: 2285:        {
    #####: 2286:            crop = (Rectangle){ (float)xMin, (float)yMin, (float)((xMax + 1) - xMin), (float)((yMax + 1) - yMin) };
    %%%%%: 2286-block  0
        -: 2287:        }
        -: 2288:
    #####: 2289:        UnloadImageColors(pixels);
    %%%%%: 2289-block  0
call    0 never executed
        -: 2290:    }
        -: 2291:
    #####: 2292:    return crop;
    %%%%%: 2292-block  0
        -: 2293:}
        -: 2294:
        -: 2295://------------------------------------------------------------------------------------
        -: 2296:// Image drawing functions
        -: 2297://------------------------------------------------------------------------------------
        -: 2298:// Clear image background with given color
function ImageClearBackground called 0 returned 0% blocks executed 0%
    #####: 2299:void ImageClearBackground(Image *dst, Color color)
        -: 2300:{
    #####: 2301:    for (int i = 0; i < dst->width*dst->height; ++i) ImageDrawPixel(dst, i%dst->width, i/dst->width, color);
    %%%%%: 2301-block  0
    %%%%%: 2301-block  1
call    0 never executed
    %%%%%: 2301-block  2
branch  1 never executed
branch  2 never executed
    #####: 2302:}
        -: 2303:
        -: 2304:// Draw pixel within an image
        -: 2305:// NOTE: Compressed image formats not supported
function ImageDrawPixel called 0 returned 0% blocks executed 0%
    #####: 2306:void ImageDrawPixel(Image *dst, int x, int y, Color color)
        -: 2307:{
        -: 2308:    // Security check to avoid program crash
    #####: 2309:    if ((dst->data == NULL) || (x < 0) || (x >= dst->width) || (y < 0) || (y >= dst->height)) return;
    %%%%%: 2309-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2309-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2309-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 2309-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 2309-block  4
branch  8 never executed
branch  9 never executed
    %%%%%: 2309-block  5
        -: 2310:
    #####: 2311:    switch (dst->format)
    %%%%%: 2311-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 2312:    {
    #####: 2313:        case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE:
        -: 2314:        {
        -: 2315:            // NOTE: Calculate grayscale equivalent color
    #####: 2316:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
    #####: 2317:            unsigned char gray = (unsigned char)((coln.x*0.299f + coln.y*0.587f + coln.z*0.114f)*255.0f);
        -: 2318:
    #####: 2319:            ((unsigned char *)dst->data)[y*dst->width + x] = gray;
        -: 2320:
    #####: 2321:        } break;
    %%%%%: 2321-block  0
    #####: 2322:        case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 2323:        {
        -: 2324:            // NOTE: Calculate grayscale equivalent color
    #####: 2325:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
    #####: 2326:            unsigned char gray = (unsigned char)((coln.x*0.299f + coln.y*0.587f + coln.z*0.114f)*255.0f);
        -: 2327:
    #####: 2328:            ((unsigned char *)dst->data)[(y*dst->width + x)*2] = gray;
    #####: 2329:            ((unsigned char *)dst->data)[(y*dst->width + x)*2 + 1] = color.a;
        -: 2330:
    #####: 2331:        } break;
    %%%%%: 2331-block  0
    #####: 2332:        case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 2333:        {
        -: 2334:            // NOTE: Calculate R5G6B5 equivalent color
    #####: 2335:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
        -: 2336:
    #####: 2337:            unsigned char r = (unsigned char)(round(coln.x*31.0f));
    #####: 2338:            unsigned char g = (unsigned char)(round(coln.y*63.0f));
    #####: 2339:            unsigned char b = (unsigned char)(round(coln.z*31.0f));
        -: 2340:
    #####: 2341:            ((unsigned short *)dst->data)[y*dst->width + x] = (unsigned short)r << 11 | (unsigned short)g << 5 | (unsigned short)b;
        -: 2342:
    #####: 2343:        } break;
    %%%%%: 2343-block  0
    #####: 2344:        case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 2345:        {
        -: 2346:            // NOTE: Calculate R5G5B5A1 equivalent color
    #####: 2347:            Vector4 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f, (float)color.a/255.0f };
        -: 2348:
    #####: 2349:            unsigned char r = (unsigned char)(round(coln.x*31.0f));
    #####: 2350:            unsigned char g = (unsigned char)(round(coln.y*31.0f));
    #####: 2351:            unsigned char b = (unsigned char)(round(coln.z*31.0f));
    #####: 2352:            unsigned char a = (coln.w > ((float)PIXELFORMAT_UNCOMPRESSED_R5G5B5A1_ALPHA_THRESHOLD/255.0f))? 1 : 0;
        -: 2353:
    #####: 2354:            ((unsigned short *)dst->data)[y*dst->width + x] = (unsigned short)r << 11 | (unsigned short)g << 6 | (unsigned short)b << 1 | (unsigned short)a;
        -: 2355:
    #####: 2356:        } break;
    %%%%%: 2356-block  0
    #####: 2357:        case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4:
        -: 2358:        {
        -: 2359:            // NOTE: Calculate R5G5B5A1 equivalent color
    #####: 2360:            Vector4 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f, (float)color.a/255.0f };
        -: 2361:
    #####: 2362:            unsigned char r = (unsigned char)(round(coln.x*15.0f));
    #####: 2363:            unsigned char g = (unsigned char)(round(coln.y*15.0f));
    #####: 2364:            unsigned char b = (unsigned char)(round(coln.z*15.0f));
    #####: 2365:            unsigned char a = (unsigned char)(round(coln.w*15.0f));
        -: 2366:
    #####: 2367:            ((unsigned short *)dst->data)[y*dst->width + x] = (unsigned short)r << 12 | (unsigned short)g << 8 | (unsigned short)b << 4 | (unsigned short)a;
        -: 2368:
    #####: 2369:        } break;
    %%%%%: 2369-block  0
    #####: 2370:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8:
        -: 2371:        {
    #####: 2372:            ((unsigned char *)dst->data)[(y*dst->width + x)*3] = color.r;
    #####: 2373:            ((unsigned char *)dst->data)[(y*dst->width + x)*3 + 1] = color.g;
    #####: 2374:            ((unsigned char *)dst->data)[(y*dst->width + x)*3 + 2] = color.b;
        -: 2375:
    #####: 2376:        } break;
    %%%%%: 2376-block  0
    #####: 2377:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8:
        -: 2378:        {
    #####: 2379:            ((unsigned char *)dst->data)[(y*dst->width + x)*4] = color.r;
    #####: 2380:            ((unsigned char *)dst->data)[(y*dst->width + x)*4 + 1] = color.g;
    #####: 2381:            ((unsigned char *)dst->data)[(y*dst->width + x)*4 + 2] = color.b;
    #####: 2382:            ((unsigned char *)dst->data)[(y*dst->width + x)*4 + 3] = color.a;
        -: 2383:
    #####: 2384:        } break;
    %%%%%: 2384-block  0
    #####: 2385:        case PIXELFORMAT_UNCOMPRESSED_R32:
        -: 2386:        {
        -: 2387:            // NOTE: Calculate grayscale equivalent color (normalized to 32bit)
    #####: 2388:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
        -: 2389:
    #####: 2390:            ((float *)dst->data)[y*dst->width + x] = coln.x*0.299f + coln.y*0.587f + coln.z*0.114f;
        -: 2391:
    #####: 2392:        } break;
    %%%%%: 2392-block  0
    #####: 2393:        case PIXELFORMAT_UNCOMPRESSED_R32G32B32:
        -: 2394:        {
        -: 2395:            // NOTE: Calculate R32G32B32 equivalent color (normalized to 32bit)
    #####: 2396:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
        -: 2397:
    #####: 2398:            ((float *)dst->data)[(y*dst->width + x)*3] = coln.x;
    #####: 2399:            ((float *)dst->data)[(y*dst->width + x)*3 + 1] = coln.y;
    #####: 2400:            ((float *)dst->data)[(y*dst->width + x)*3 + 2] = coln.z;
    #####: 2401:        } break;
    %%%%%: 2401-block  0
    #####: 2402:        case PIXELFORMAT_UNCOMPRESSED_R32G32B32A32:
        -: 2403:        {
        -: 2404:            // NOTE: Calculate R32G32B32A32 equivalent color (normalized to 32bit)
    #####: 2405:            Vector4 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f, (float)color.a/255.0f };
        -: 2406:
    #####: 2407:            ((float *)dst->data)[(y*dst->width + x)*4] = coln.x;
    #####: 2408:            ((float *)dst->data)[(y*dst->width + x)*4 + 1] = coln.y;
    #####: 2409:            ((float *)dst->data)[(y*dst->width + x)*4 + 2] = coln.z;
    #####: 2410:            ((float *)dst->data)[(y*dst->width + x)*4 + 3] = coln.w;
        -: 2411:
    #####: 2412:        } break;
    %%%%%: 2412-block  0
    #####: 2413:        default: break;
    %%%%%: 2413-block  0
        -: 2414:    }
        -: 2415:}
        -: 2416:
        -: 2417:// Draw pixel within an image (Vector version)
function ImageDrawPixelV called 0 returned 0% blocks executed 0%
    #####: 2418:void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
        -: 2419:{
    #####: 2420:    ImageDrawPixel(dst, (int)position.x, (int)position.y, color);
    %%%%%: 2420-block  0
call    0 never executed
    #####: 2421:}
        -: 2422:
        -: 2423:// Draw line within an image
function ImageDrawLine called 0 returned 0% blocks executed 0%
    #####: 2424:void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
        -: 2425:{
        -: 2426:    // Using Bresenham's algorithm as described in
        -: 2427:    // Drawing Lines with Pixels - Joshua Scott - March 2012
        -: 2428:    // https://classic.csunplugged.org/wp-content/uploads/2014/12/Lines.pdf
        -: 2429:
    #####: 2430:    int changeInX = (endPosX - startPosX);
    #####: 2431:    int absChangeInX = (changeInX < 0)? -changeInX : changeInX;
    #####: 2432:    int changeInY = (endPosY - startPosY);
    #####: 2433:    int absChangeInY = (changeInY < 0)? -changeInY : changeInY;
        -: 2434:
        -: 2435:    int startU, startV, endU, stepV; // Substitutions, either U = X, V = Y or vice versa. See loop at end of function
        -: 2436:    //int endV;     // Not needed but left for better understanding, check code below
        -: 2437:    int A, B, P;    // See linked paper above, explained down in the main loop
    #####: 2438:    int reversedXY = (absChangeInY < absChangeInX);
        -: 2439:
    #####: 2440:    if (reversedXY)
    %%%%%: 2440-block  0
branch  0 never executed
branch  1 never executed
        -: 2441:    {
    #####: 2442:        A = 2*absChangeInY;
    #####: 2443:        B = A - 2*absChangeInX;
    #####: 2444:        P = A - absChangeInX;
        -: 2445:
    #####: 2446:        if (changeInX > 0)
    %%%%%: 2446-block  0
branch  0 never executed
branch  1 never executed
        -: 2447:        {
    #####: 2448:            startU = startPosX;
    #####: 2449:            startV = startPosY;
    #####: 2450:            endU = endPosX;
    %%%%%: 2450-block  0
        -: 2451:            //endV = endPosY;
        -: 2452:        }
        -: 2453:        else
        -: 2454:        {
    #####: 2455:            startU = endPosX;
    #####: 2456:            startV = endPosY;
    #####: 2457:            endU = startPosX;
        -: 2458:            //endV = startPosY;
        -: 2459:
        -: 2460:            // Since start and end are reversed
    #####: 2461:            changeInX = -changeInX;
    #####: 2462:            changeInY = -changeInY;
    %%%%%: 2462-block  0
        -: 2463:        }
        -: 2464:
    #####: 2465:        stepV = (changeInY < 0)? -1 : 1;
    %%%%%: 2465-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2465-block  1
    %%%%%: 2465-block  2
        -: 2466:
    #####: 2467:        ImageDrawPixel(dst, startU, startV, color);     // At this point they are correctly ordered...
    %%%%%: 2467-block  0
call    0 never executed
        -: 2468:    }
        -: 2469:    else
        -: 2470:    {
    #####: 2471:        A = 2*absChangeInX;
    #####: 2472:        B = A - 2*absChangeInY;
    #####: 2473:        P = A - absChangeInY;
        -: 2474:
    #####: 2475:        if (changeInY > 0)
    %%%%%: 2475-block  0
branch  0 never executed
branch  1 never executed
        -: 2476:        {
    #####: 2477:            startU = startPosY;
    #####: 2478:            startV = startPosX;
    #####: 2479:            endU = endPosY;
    %%%%%: 2479-block  0
        -: 2480:            //endV = endPosX;
        -: 2481:        }
        -: 2482:        else
        -: 2483:        {
    #####: 2484:            startU = endPosY;
    #####: 2485:            startV = endPosX;
    #####: 2486:            endU = startPosY;
        -: 2487:            //endV = startPosX;
        -: 2488:
        -: 2489:            // Since start and end are reversed
    #####: 2490:            changeInX = -changeInX;
    #####: 2491:            changeInY = -changeInY;
    %%%%%: 2491-block  0
        -: 2492:        }
        -: 2493:
    #####: 2494:        stepV = (changeInX < 0)? -1 : 1;
    %%%%%: 2494-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2494-block  1
    %%%%%: 2494-block  2
        -: 2495:
    #####: 2496:        ImageDrawPixel(dst, startV, startU, color);     // ... but need to be reversed here. Repeated in the main loop below
    %%%%%: 2496-block  0
call    0 never executed
        -: 2497:    }
        -: 2498:
        -: 2499:    // We already drew the start point. If we started at startU + 0, the line would be crooked and too short
    #####: 2500:    for (int u = startU + 1, v = startV; u <= endU; u++)
    %%%%%: 2500-block  0
    %%%%%: 2500-block  1
    %%%%%: 2500-block  2
branch  0 never executed
branch  1 never executed
        -: 2501:    {
    #####: 2502:        if (P >= 0)
    %%%%%: 2502-block  0
branch  0 never executed
branch  1 never executed
        -: 2503:        {
    #####: 2504:            v += stepV;     // Adjusts whenever we stray too far from the direct line. Details in the linked paper above
    #####: 2505:            P += B;         // Remembers that we corrected our path
    %%%%%: 2505-block  0
        -: 2506:        }
    #####: 2507:        else P += A;        // Remembers how far we are from the direct line
    %%%%%: 2507-block  0
        -: 2508:
    #####: 2509:        if (reversedXY) ImageDrawPixel(dst, u, v, color);
    %%%%%: 2509-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2509-block  1
call    2 never executed
    #####: 2510:        else ImageDrawPixel(dst, v, u, color);
    %%%%%: 2510-block  0
call    0 never executed
        -: 2511:    }
    #####: 2512:}
        -: 2513:
        -: 2514:// Draw line within an image (Vector version)
function ImageDrawLineV called 0 returned 0% blocks executed 0%
    #####: 2515:void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
        -: 2516:{
    #####: 2517:    ImageDrawLine(dst, (int)start.x, (int)start.y, (int)end.x, (int)end.y, color);
    %%%%%: 2517-block  0
call    0 never executed
    #####: 2518:}
        -: 2519:
        -: 2520:// Draw circle within an image
function ImageDrawCircle called 0 returned 0% blocks executed 0%
    #####: 2521:void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
        -: 2522:{
    #####: 2523:    int x = 0, y = radius;
    #####: 2524:    int decesionParameter = 3 - 2*radius;
        -: 2525:
    #####: 2526:    while (y >= x)
    %%%%%: 2526-block  0
    %%%%%: 2526-block  1
branch  0 never executed
branch  1 never executed
        -: 2527:    {
    #####: 2528:        ImageDrawPixel(dst, centerX + x, centerY + y, color);
    %%%%%: 2528-block  0
call    0 never executed
    #####: 2529:        ImageDrawPixel(dst, centerX - x, centerY + y, color);
call    0 never executed
    #####: 2530:        ImageDrawPixel(dst, centerX + x, centerY - y, color);
call    0 never executed
    #####: 2531:        ImageDrawPixel(dst, centerX - x, centerY - y, color);
call    0 never executed
    #####: 2532:        ImageDrawPixel(dst, centerX + y, centerY + x, color);
call    0 never executed
    #####: 2533:        ImageDrawPixel(dst, centerX - y, centerY + x, color);
call    0 never executed
    #####: 2534:        ImageDrawPixel(dst, centerX + y, centerY - x, color);
call    0 never executed
    #####: 2535:        ImageDrawPixel(dst, centerX - y, centerY - x, color);
call    0 never executed
    #####: 2536:        x++;
        -: 2537:
    #####: 2538:        if (decesionParameter > 0)
branch  0 never executed
branch  1 never executed
        -: 2539:        {
    #####: 2540:            y--;
    #####: 2541:            decesionParameter = decesionParameter + 4*(x - y) + 10;
    %%%%%: 2541-block  0
        -: 2542:        }
    #####: 2543:        else decesionParameter = decesionParameter + 4*x + 6;
    %%%%%: 2543-block  0
        -: 2544:    }
    #####: 2545:}
        -: 2546:
        -: 2547:// Draw circle within an image (Vector version)
function ImageDrawCircleV called 0 returned 0% blocks executed 0%
    #####: 2548:void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
        -: 2549:{
    #####: 2550:    ImageDrawCircle(dst, (int)center.x, (int)center.y, radius, color);
    %%%%%: 2550-block  0
call    0 never executed
    #####: 2551:}
        -: 2552:
        -: 2553:// Draw rectangle within an image
function ImageDrawRectangle called 0 returned 0% blocks executed 0%
    #####: 2554:void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
        -: 2555:{
    #####: 2556:    ImageDrawRectangleRec(dst, (Rectangle){ (float)posX, (float)posY, (float)width, (float)height }, color);
    %%%%%: 2556-block  0
call    0 never executed
    #####: 2557:}
        -: 2558:
        -: 2559:// Draw rectangle within an image (Vector version)
function ImageDrawRectangleV called 0 returned 0% blocks executed 0%
    #####: 2560:void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
        -: 2561:{
    #####: 2562:    ImageDrawRectangle(dst, (int)position.x, (int)position.y, (int)size.x, (int)size.y, color);
    %%%%%: 2562-block  0
call    0 never executed
    #####: 2563:}
        -: 2564:
        -: 2565:// Draw rectangle within an image
function ImageDrawRectangleRec called 0 returned 0% blocks executed 0%
    #####: 2566:void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
        -: 2567:{
        -: 2568:    // Security check to avoid program crash
    #####: 2569:    if ((dst->data == NULL) || (dst->width == 0) || (dst->height == 0)) return;
    %%%%%: 2569-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2569-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2569-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 2569-block  3
        -: 2570:
    #####: 2571:    int sy = (int)rec.y;
    #####: 2572:    int ey = sy + (int)rec.height;
        -: 2573:
    #####: 2574:    int sx = (int)rec.x;
    #####: 2575:    int ex = sx + (int)rec.width;
        -: 2576:
    #####: 2577:    for (int y = sy; y < ey; y++)
    %%%%%: 2577-block  0
    %%%%%: 2577-block  1
    %%%%%: 2577-block  2
branch  0 never executed
branch  1 never executed
        -: 2578:    {
    #####: 2579:        for (int x = sx; x < ex; x++)
    %%%%%: 2579-block  0
    %%%%%: 2579-block  1
branch  0 never executed
branch  1 never executed
        -: 2580:        {
    #####: 2581:            ImageDrawPixel(dst, x, y, color);
    %%%%%: 2581-block  0
call    0 never executed
        -: 2582:        }
        -: 2583:    }
        -: 2584:}
        -: 2585:
        -: 2586:// Draw rectangle lines within an image
function ImageDrawRectangleLines called 0 returned 0% blocks executed 0%
    #####: 2587:void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
        -: 2588:{
    #####: 2589:    ImageDrawRectangle(dst, (int)rec.x, (int)rec.y, (int)rec.width, thick, color);
    %%%%%: 2589-block  0
call    0 never executed
    #####: 2590:    ImageDrawRectangle(dst, (int)rec.x, (int)(rec.y + thick), thick, (int)(rec.height - thick*2), color);
call    0 never executed
    #####: 2591:    ImageDrawRectangle(dst, (int)(rec.x + rec.width - thick), (int)(rec.y + thick), thick, (int)(rec.height - thick*2), color);
call    0 never executed
    #####: 2592:    ImageDrawRectangle(dst, (int)rec.x, (int)(rec.y + rec.height - thick), (int)rec.width, thick, color);
call    0 never executed
    #####: 2593:}
        -: 2594:
        -: 2595:// Draw an image (source) within an image (destination)
        -: 2596:// NOTE: Color tint is applied to source image
function ImageDraw called 0 returned 0% blocks executed 0%
    #####: 2597:void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
        -: 2598:{
        -: 2599:    // Security check to avoid program crash
    #####: 2600:    if ((dst->data == NULL) || (dst->width == 0) || (dst->height == 0) ||
    %%%%%: 2600-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2600-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2600-block  2
branch  4 never executed
branch  5 never executed
    #####: 2601:        (src.data == NULL) || (src.width == 0) || (src.height == 0)) return;
    %%%%%: 2601-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2601-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2601-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 2601-block  3
        -: 2602:
    #####: 2603:    if (dst->mipmaps > 1) TRACELOG(LOG_WARNING, "Image drawing only applied to base mipmap level");
    %%%%%: 2603-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2603-block  1
call    2 never executed
    #####: 2604:    if (dst->format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "Image drawing not supported for compressed formats");
    %%%%%: 2604-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2604-block  1
call    2 never executed
        -: 2605:    else
        -: 2606:    {
    #####: 2607:        Image srcMod = { 0 };       // Source copy (in case it was required)
    #####: 2608:        Image *srcPtr = &src;       // Pointer to source image
    #####: 2609:        bool useSrcMod = false;     // Track source copy required
        -: 2610:
        -: 2611:        // Source rectangle out-of-bounds security checks
    #####: 2612:        if (srcRec.x < 0) { srcRec.width += srcRec.x; srcRec.x = 0; }
    %%%%%: 2612-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2612-block  1
    #####: 2613:        if (srcRec.y < 0) { srcRec.height += srcRec.y; srcRec.y = 0; }
    %%%%%: 2613-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2613-block  1
    #####: 2614:        if ((srcRec.x + srcRec.width) > src.width) srcRec.width = src.width - srcRec.x;
    %%%%%: 2614-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2614-block  1
    #####: 2615:        if ((srcRec.y + srcRec.height) > src.height) srcRec.height = src.height - srcRec.y;
    %%%%%: 2615-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2615-block  1
        -: 2616:
        -: 2617:        // Check if source rectangle needs to be resized to destination rectangle
        -: 2618:        // In that case, we make a copy of source and we apply all required transform
    #####: 2619:        if (((int)srcRec.width != (int)dstRec.width) || ((int)srcRec.height != (int)dstRec.height))
    %%%%%: 2619-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2619-block  1
branch  2 never executed
branch  3 never executed
        -: 2620:        {
    #####: 2621:            srcMod = ImageFromImage(src, srcRec);   // Create image from another image
    %%%%%: 2621-block  0
call    0 never executed
    #####: 2622:            ImageResize(&srcMod, (int)dstRec.width, (int)dstRec.height);   // Resize to destination rectangle
call    0 never executed
    #####: 2623:            srcRec = (Rectangle){ 0, 0, (float)srcMod.width, (float)srcMod.height };
        -: 2624:
    #####: 2625:            srcPtr = &srcMod;
    #####: 2626:            useSrcMod = true;
        -: 2627:        }
        -: 2628:
        -: 2629:        // Destination rectangle out-of-bounds security checks
    #####: 2630:        if (dstRec.x < 0)
    %%%%%: 2630-block  0
branch  0 never executed
branch  1 never executed
        -: 2631:        {
    #####: 2632:            srcRec.x = -dstRec.x;
    #####: 2633:            srcRec.width += dstRec.x;
    #####: 2634:            dstRec.x = 0;
    %%%%%: 2634-block  0
        -: 2635:        }
    #####: 2636:        else if ((dstRec.x + srcRec.width) > dst->width) srcRec.width = dst->width - dstRec.x;
    %%%%%: 2636-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2636-block  1
        -: 2637:
    #####: 2638:        if (dstRec.y < 0)
    %%%%%: 2638-block  0
branch  0 never executed
branch  1 never executed
        -: 2639:        {
    #####: 2640:            srcRec.y = -dstRec.y;
    #####: 2641:            srcRec.height += dstRec.y;
    #####: 2642:            dstRec.y = 0;
    %%%%%: 2642-block  0
        -: 2643:        }
    #####: 2644:        else if ((dstRec.y + srcRec.height) > dst->height) srcRec.height = dst->height - dstRec.y;
    %%%%%: 2644-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2644-block  1
        -: 2645:
    #####: 2646:        if (dst->width < srcRec.width) srcRec.width = (float)dst->width;
    %%%%%: 2646-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2646-block  1
    #####: 2647:        if (dst->height < srcRec.height) srcRec.height = (float)dst->height;
    %%%%%: 2647-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2647-block  1
        -: 2648:
        -: 2649:        // This blitting method is quite fast! The process followed is:
        -: 2650:        // for every pixel -> [get_src_format/get_dst_format -> blend -> format_to_dst]
        -: 2651:        // Some optimization ideas:
        -: 2652:        //    [x] Avoid creating source copy if not required (no resize required)
        -: 2653:        //    [x] Optimize ImageResize() for pixel format (alternative: ImageResizeNN())
        -: 2654:        //    [x] Optimize ColorAlphaBlend() to avoid processing (alpha = 0) and (alpha = 1)
        -: 2655:        //    [x] Optimize ColorAlphaBlend() for faster operations (maybe avoiding divs?)
        -: 2656:        //    [x] Consider fast path: no alpha blending required cases (src has no alpha)
        -: 2657:        //    [x] Consider fast path: same src/dst format with no alpha -> direct line copy
        -: 2658:        //    [-] GetPixelColor(): Get Vector4 instead of Color, easier for ColorAlphaBlend()
        -: 2659:
        -: 2660:        Color colSrc, colDst, blend;
    #####: 2661:        bool blendRequired = true;
        -: 2662:
        -: 2663:        // Fast path: Avoid blend if source has no alpha to blend
    #####: 2664:        if ((tint.a == 255) && ((srcPtr->format == PIXELFORMAT_UNCOMPRESSED_GRAYSCALE) || (srcPtr->format == PIXELFORMAT_UNCOMPRESSED_R8G8B8) || (srcPtr->format == PIXELFORMAT_UNCOMPRESSED_R5G6B5))) blendRequired = false;
    %%%%%: 2664-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2664-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2664-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 2664-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 2664-block  4
        -: 2665:
    #####: 2666:        int strideDst = GetPixelDataSize(dst->width, 1, dst->format);
    %%%%%: 2666-block  0
call    0 never executed
    #####: 2667:        int bytesPerPixelDst = strideDst/(dst->width);
        -: 2668:
    #####: 2669:        int strideSrc = GetPixelDataSize(srcPtr->width, 1, srcPtr->format);
call    0 never executed
    #####: 2670:        int bytesPerPixelSrc = strideSrc/(srcPtr->width);
        -: 2671:
    #####: 2672:        unsigned char *pSrcBase = (unsigned char *)srcPtr->data + ((int)srcRec.y*srcPtr->width + (int)srcRec.x)*bytesPerPixelSrc;
    #####: 2673:        unsigned char *pDstBase = (unsigned char *)dst->data + ((int)dstRec.y*dst->width + (int)dstRec.x)*bytesPerPixelDst;
        -: 2674:
    #####: 2675:        for (int y = 0; y < (int)srcRec.height; y++)
    %%%%%: 2675-block  0
branch  0 never executed
branch  1 never executed
        -: 2676:        {
    #####: 2677:            unsigned char *pSrc = pSrcBase;
    #####: 2678:            unsigned char *pDst = pDstBase;
        -: 2679:
        -: 2680:            // Fast path: Avoid moving pixel by pixel if no blend required and same format
    #####: 2681:            if (!blendRequired && (srcPtr->format == dst->format)) memcpy(pDst, pSrc, (int)(srcRec.width)*bytesPerPixelSrc);
    %%%%%: 2681-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2681-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2681-block  2
        -: 2682:            else
        -: 2683:            {
    #####: 2684:                for (int x = 0; x < (int)srcRec.width; x++)
    %%%%%: 2684-block  0
    %%%%%: 2684-block  1
branch  0 never executed
branch  1 never executed
        -: 2685:                {
    #####: 2686:                    colSrc = GetPixelColor(pSrc, srcPtr->format);
    %%%%%: 2686-block  0
call    0 never executed
    #####: 2687:                    colDst = GetPixelColor(pDst, dst->format);
call    0 never executed
        -: 2688:
        -: 2689:                    // Fast path: Avoid blend if source has no alpha to blend
    #####: 2690:                    if (blendRequired) blend = ColorAlphaBlend(colDst, colSrc, tint);
branch  0 never executed
branch  1 never executed
    %%%%%: 2690-block  0
call    2 never executed
    #####: 2691:                    else blend = colSrc;
    %%%%%: 2691-block  0
        -: 2692:
    #####: 2693:                    SetPixelColor(pDst, blend, dst->format);
    %%%%%: 2693-block  0
call    0 never executed
        -: 2694:
    #####: 2695:                    pDst += bytesPerPixelDst;
    #####: 2696:                    pSrc += bytesPerPixelSrc;
        -: 2697:                }
        -: 2698:            }
        -: 2699:
    #####: 2700:            pSrcBase += strideSrc;
    #####: 2701:            pDstBase += strideDst;
    %%%%%: 2701-block  0
        -: 2702:        }
        -: 2703:
    #####: 2704:        if (useSrcMod) UnloadImage(srcMod);     // Unload source modified image
    %%%%%: 2704-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2704-block  1
call    2 never executed
        -: 2705:    }
        -: 2706:}
        -: 2707:
        -: 2708:// Draw text (default font) within an image (destination)
function ImageDrawText called 0 returned 0% blocks executed 0%
    #####: 2709:void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
        -: 2710:{
    #####: 2711:    Vector2 position = { (float)posX, (float)posY };
        -: 2712:
        -: 2713:    // NOTE: For default font, sapcing is set to desired font size / default font size (10)
    #####: 2714:    ImageDrawTextEx(dst, GetFontDefault(), text, position, (float)fontSize, (float)fontSize/10, color);
    %%%%%: 2714-block  0
call    0 never executed
call    1 never executed
    #####: 2715:}
        -: 2716:
        -: 2717:// Draw text (custom sprite font) within an image (destination)
function ImageDrawTextEx called 0 returned 0% blocks executed 0%
    #####: 2718:void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
        -: 2719:{
    #####: 2720:    Image imText = ImageTextEx(font, text, fontSize, spacing, tint);
    %%%%%: 2720-block  0
call    0 never executed
        -: 2721:
    #####: 2722:    Rectangle srcRec = { 0.0f, 0.0f, (float)imText.width, (float)imText.height };
    #####: 2723:    Rectangle dstRec = { position.x, position.y, (float)imText.width, (float)imText.height };
        -: 2724:
    #####: 2725:    ImageDraw(dst, imText, srcRec, dstRec, WHITE);
call    0 never executed
        -: 2726:
    #####: 2727:    UnloadImage(imText);
call    0 never executed
    #####: 2728:}
        -: 2729:
        -: 2730://------------------------------------------------------------------------------------
        -: 2731:// Texture loading functions
        -: 2732://------------------------------------------------------------------------------------
        -: 2733:// Load texture from file into GPU memory (VRAM)
function LoadTexture called 0 returned 0% blocks executed 0%
    #####: 2734:Texture2D LoadTexture(const char *fileName)
        -: 2735:{
    #####: 2736:    Texture2D texture = { 0 };
        -: 2737:
    #####: 2738:    Image image = LoadImage(fileName);
    %%%%%: 2738-block  0
call    0 never executed
        -: 2739:
    #####: 2740:    if (image.data != NULL)
branch  0 never executed
branch  1 never executed
        -: 2741:    {
    #####: 2742:        texture = LoadTextureFromImage(image);
    %%%%%: 2742-block  0
call    0 never executed
    #####: 2743:        UnloadImage(image);
call    0 never executed
        -: 2744:    }
        -: 2745:
    #####: 2746:    return texture;
    %%%%%: 2746-block  0
        -: 2747:}
        -: 2748:
        -: 2749:// Load a texture from image data
        -: 2750:// NOTE: image is not unloaded, it must be done manually
function LoadTextureFromImage called 1 returned 100% blocks executed 88%
        1: 2751:Texture2D LoadTextureFromImage(Image image)
        -: 2752:{
        1: 2753:    Texture2D texture = { 0 };
        -: 2754:
        1: 2755:    if ((image.data != NULL) && (image.width != 0) && (image.height != 0))
        1: 2755-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2755-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2755-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        -: 2756:    {
        1: 2757:        texture.id = rlLoadTexture(image.data, image.width, image.height, image.format, image.mipmaps);
        1: 2757-block  0
call    0 returned 1
        -: 2758:    }
    #####: 2759:    else TRACELOG(LOG_WARNING, "IMAGE: Data is not valid to load texture");
    %%%%%: 2759-block  0
call    0 never executed
        -: 2760:
        1: 2761:    texture.width = image.width;
        1: 2762:    texture.height = image.height;
        1: 2763:    texture.mipmaps = image.mipmaps;
        1: 2764:    texture.format = image.format;
        -: 2765:
        1: 2766:    return texture;
        1: 2766-block  0
        -: 2767:}
        -: 2768:
        -: 2769:// Load cubemap from image, multiple image cubemap layouts supported
function LoadTextureCubemap called 0 returned 0% blocks executed 0%
    #####: 2770:TextureCubemap LoadTextureCubemap(Image image, int layout)
        -: 2771:{
    #####: 2772:    TextureCubemap cubemap = { 0 };
        -: 2773:
    #####: 2774:    if (layout == CUBEMAP_LAYOUT_AUTO_DETECT)      // Try to automatically guess layout type
    %%%%%: 2774-block  0
branch  0 never executed
branch  1 never executed
        -: 2775:    {
        -: 2776:        // Check image width/height to determine the type of cubemap provided
    #####: 2777:        if (image.width > image.height)
    %%%%%: 2777-block  0
branch  0 never executed
branch  1 never executed
        -: 2778:        {
    #####: 2779:            if ((image.width/6) == image.height) { layout = CUBEMAP_LAYOUT_LINE_HORIZONTAL; cubemap.width = image.width/6; }
    %%%%%: 2779-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2779-block  1
    #####: 2780:            else if ((image.width/4) == (image.height/3)) { layout = CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE; cubemap.width = image.width/4; }
    %%%%%: 2780-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2780-block  1
    #####: 2781:            else if (image.width >= (int)((float)image.height*1.85f)) { layout = CUBEMAP_LAYOUT_PANORAMA; cubemap.width = image.width/4; }
    %%%%%: 2781-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2781-block  1
        -: 2782:        }
    #####: 2783:        else if (image.height > image.width)
    %%%%%: 2783-block  0
branch  0 never executed
branch  1 never executed
        -: 2784:        {
    #####: 2785:            if ((image.height/6) == image.width) { layout = CUBEMAP_LAYOUT_LINE_VERTICAL; cubemap.width = image.height/6; }
    %%%%%: 2785-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2785-block  1
    #####: 2786:            else if ((image.width/3) == (image.height/4)) { layout = CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR; cubemap.width = image.width/3; }
    %%%%%: 2786-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2786-block  1
        -: 2787:        }
        -: 2788:
    #####: 2789:        cubemap.height = cubemap.width;
    %%%%%: 2789-block  0
        -: 2790:    }
        -: 2791:
    #####: 2792:    if (layout != CUBEMAP_LAYOUT_AUTO_DETECT)
    %%%%%: 2792-block  0
branch  0 never executed
branch  1 never executed
        -: 2793:    {
    #####: 2794:        int size = cubemap.width;
        -: 2795:
    #####: 2796:        Image faces = { 0 };                // Vertical column image
    #####: 2797:        Rectangle faceRecs[6] = { 0 };      // Face source rectangles
    #####: 2798:        for (int i = 0; i < 6; i++) faceRecs[i] = (Rectangle){ 0, 0, (float)size, (float)size };
    %%%%%: 2798-block  0
    %%%%%: 2798-block  1
    %%%%%: 2798-block  2
branch  0 never executed
branch  1 never executed
        -: 2799:
    #####: 2800:        if (layout == CUBEMAP_LAYOUT_LINE_VERTICAL)
    %%%%%: 2800-block  0
branch  0 never executed
branch  1 never executed
        -: 2801:        {
    #####: 2802:            faces = image;
    #####: 2803:            for (int i = 0; i < 6; i++) faceRecs[i].y = (float)size*i;
    %%%%%: 2803-block  0
    %%%%%: 2803-block  1
    %%%%%: 2803-block  2
branch  0 never executed
branch  1 never executed
        -: 2804:        }
    #####: 2805:        else if (layout == CUBEMAP_LAYOUT_PANORAMA)
    %%%%%: 2805-block  0
branch  0 never executed
branch  1 never executed
        -: 2806:        {
        -: 2807:            // TODO: Convert panorama image to square faces...
        -: 2808:            // Ref: https://github.com/denivip/panorama/blob/master/panorama.cpp
        -: 2809:        }
        -: 2810:        else
        -: 2811:        {
    #####: 2812:            if (layout == CUBEMAP_LAYOUT_LINE_HORIZONTAL) for (int i = 0; i < 6; i++) faceRecs[i].x = (float)size*i;
    %%%%%: 2812-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2812-block  1
    %%%%%: 2812-block  2
    %%%%%: 2812-block  3
branch  2 never executed
branch  3 never executed
    #####: 2813:            else if (layout == CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR)
    %%%%%: 2813-block  0
branch  0 never executed
branch  1 never executed
        -: 2814:            {
    #####: 2815:                faceRecs[0].x = (float)size; faceRecs[0].y = (float)size;
    #####: 2816:                faceRecs[1].x = (float)size; faceRecs[1].y = (float)size*3;
    #####: 2817:                faceRecs[2].x = (float)size; faceRecs[2].y = 0;
    #####: 2818:                faceRecs[3].x = (float)size; faceRecs[3].y = (float)size*2;
    #####: 2819:                faceRecs[4].x = 0; faceRecs[4].y = (float)size;
    #####: 2820:                faceRecs[5].x = (float)size*2; faceRecs[5].y = (float)size;
    %%%%%: 2820-block  0
        -: 2821:            }
    #####: 2822:            else if (layout == CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE)
    %%%%%: 2822-block  0
branch  0 never executed
branch  1 never executed
        -: 2823:            {
    #####: 2824:                faceRecs[0].x = (float)size*2; faceRecs[0].y = (float)size;
    #####: 2825:                faceRecs[1].x = 0; faceRecs[1].y = (float)size;
    #####: 2826:                faceRecs[2].x = (float)size; faceRecs[2].y = 0;
    #####: 2827:                faceRecs[3].x = (float)size; faceRecs[3].y = (float)size*2;
    #####: 2828:                faceRecs[4].x = (float)size; faceRecs[4].y = (float)size;
    #####: 2829:                faceRecs[5].x = (float)size*3; faceRecs[5].y = (float)size;
    %%%%%: 2829-block  0
        -: 2830:            }
        -: 2831:
        -: 2832:            // Convert image data to 6 faces in a vertical column, that's the optimum layout for loading
    #####: 2833:            faces = GenImageColor(size, size*6, MAGENTA);
    %%%%%: 2833-block  0
call    0 never executed
    #####: 2834:            ImageFormat(&faces, image.format);
call    0 never executed
        -: 2835:
        -: 2836:            // TODO: Image formating does not work with compressed textures!
        -: 2837:        }
        -: 2838:
    #####: 2839:        for (int i = 0; i < 6; i++) ImageDraw(&faces, image, faceRecs[i], (Rectangle){ 0, (float)size*i, (float)size, (float)size }, WHITE);
    %%%%%: 2839-block  0
    %%%%%: 2839-block  1
call    0 never executed
    %%%%%: 2839-block  2
branch  1 never executed
branch  2 never executed
        -: 2840:
    #####: 2841:        cubemap.id = rlLoadTextureCubemap(faces.data, size, faces.format);
    %%%%%: 2841-block  0
call    0 never executed
    #####: 2842:        if (cubemap.id == 0) TRACELOG(LOG_WARNING, "IMAGE: Failed to load cubemap image");
branch  0 never executed
branch  1 never executed
    %%%%%: 2842-block  0
call    2 never executed
        -: 2843:
    #####: 2844:        UnloadImage(faces);
    %%%%%: 2844-block  0
call    0 never executed
        -: 2845:    }
    #####: 2846:    else TRACELOG(LOG_WARNING, "IMAGE: Failed to detect cubemap image layout");
    %%%%%: 2846-block  0
call    0 never executed
        -: 2847:
    #####: 2848:    return cubemap;
    %%%%%: 2848-block  0
        -: 2849:}
        -: 2850:
        -: 2851:// Load texture for rendering (framebuffer)
        -: 2852:// NOTE: Render texture is loaded by default with RGBA color attachment and depth RenderBuffer
function LoadRenderTexture called 0 returned 0% blocks executed 0%
    #####: 2853:RenderTexture2D LoadRenderTexture(int width, int height)
        -: 2854:{
    #####: 2855:    RenderTexture2D target = { 0 };
        -: 2856:
    #####: 2857:    target.id = rlLoadFramebuffer(width, height);   // Load an empty framebuffer
    %%%%%: 2857-block  0
call    0 never executed
        -: 2858:
    #####: 2859:    if (target.id > 0)
branch  0 never executed
branch  1 never executed
        -: 2860:    {
    #####: 2861:        rlEnableFramebuffer(target.id);
    %%%%%: 2861-block  0
call    0 never executed
        -: 2862:
        -: 2863:        // Create color texture (default to RGBA)
    #####: 2864:        target.texture.id = rlLoadTexture(NULL, width, height, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8, 1);
call    0 never executed
    #####: 2865:        target.texture.width = width;
    #####: 2866:        target.texture.height = height;
    #####: 2867:        target.texture.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
    #####: 2868:        target.texture.mipmaps = 1;
        -: 2869:
        -: 2870:        // Create depth renderbuffer/texture
    #####: 2871:        target.depth.id = rlLoadTextureDepth(width, height, true);
call    0 never executed
    #####: 2872:        target.depth.width = width;
    #####: 2873:        target.depth.height = height;
    #####: 2874:        target.depth.format = 19;       //DEPTH_COMPONENT_24BIT?
    #####: 2875:        target.depth.mipmaps = 1;
        -: 2876:
        -: 2877:        // Attach color texture and depth renderbuffer/texture to FBO
    #####: 2878:        rlFramebufferAttach(target.id, target.texture.id, RL_ATTACHMENT_COLOR_CHANNEL0, RL_ATTACHMENT_TEXTURE2D, 0);
call    0 never executed
    #####: 2879:        rlFramebufferAttach(target.id, target.depth.id, RL_ATTACHMENT_DEPTH, RL_ATTACHMENT_RENDERBUFFER, 0);
call    0 never executed
        -: 2880:
        -: 2881:        // Check if fbo is complete with attachments (valid)
    #####: 2882:        if (rlFramebufferComplete(target.id)) TRACELOG(LOG_INFO, "FBO: [ID %i] Framebuffer object created successfully", target.id);
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 2882-block  0
call    3 never executed
        -: 2883:
    #####: 2884:        rlDisableFramebuffer();
    %%%%%: 2884-block  0
call    0 never executed
        -: 2885:    }
    #####: 2886:    else TRACELOG(LOG_WARNING, "FBO: Framebuffer object can not be created");
    %%%%%: 2886-block  0
call    0 never executed
        -: 2887:
    #####: 2888:    return target;
    %%%%%: 2888-block  0
        -: 2889:}
        -: 2890:
        -: 2891:// Unload texture from GPU memory (VRAM)
function UnloadTexture called 1 returned 100% blocks executed 100%
        1: 2892:void UnloadTexture(Texture2D texture)
        -: 2893:{
        1: 2894:    if (texture.id > 0)
        1: 2894-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2895:    {
        1: 2896:        rlUnloadTexture(texture.id);
        1: 2896-block  0
call    0 returned 1
        -: 2897:
        1: 2898:        TRACELOG(LOG_INFO, "TEXTURE: [ID %i] Unloaded texture data from VRAM (GPU)", texture.id);
call    0 returned 1
        -: 2899:    }
        1: 2900:}
        -: 2901:
        -: 2902:// Unload render texture from GPU memory (VRAM)
function UnloadRenderTexture called 0 returned 0% blocks executed 0%
    #####: 2903:void UnloadRenderTexture(RenderTexture2D target)
        -: 2904:{
    #####: 2905:    if (target.id > 0)
    %%%%%: 2905-block  0
branch  0 never executed
branch  1 never executed
        -: 2906:    {
        -: 2907:        // Color texture attached to FBO is deleted
    #####: 2908:        rlUnloadTexture(target.texture.id);
    %%%%%: 2908-block  0
call    0 never executed
        -: 2909:
        -: 2910:        // NOTE: Depth texture/renderbuffer is automatically
        -: 2911:        // queried and deleted before deleting framebuffer
    #####: 2912:        rlUnloadFramebuffer(target.id);
call    0 never executed
        -: 2913:    }
    #####: 2914:}
        -: 2915:
        -: 2916:// Update GPU texture with new data
        -: 2917:// NOTE: pixels data must match texture.format
function UpdateTexture called 0 returned 0% blocks executed 0%
    #####: 2918:void UpdateTexture(Texture2D texture, const void *pixels)
        -: 2919:{
    #####: 2920:    rlUpdateTexture(texture.id, 0, 0, texture.width, texture.height, texture.format, pixels);
    %%%%%: 2920-block  0
call    0 never executed
    #####: 2921:}
        -: 2922:
        -: 2923:// Update GPU texture rectangle with new data
        -: 2924:// NOTE: pixels data must match texture.format
function UpdateTextureRec called 0 returned 0% blocks executed 0%
    #####: 2925:void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
        -: 2926:{
    #####: 2927:    rlUpdateTexture(texture.id, (int)rec.x, (int)rec.y, (int)rec.width, (int)rec.height, texture.format, pixels);
    %%%%%: 2927-block  0
call    0 never executed
    #####: 2928:}
        -: 2929:
        -: 2930://------------------------------------------------------------------------------------
        -: 2931:// Texture configuration functions
        -: 2932://------------------------------------------------------------------------------------
        -: 2933:// Generate GPU mipmaps for a texture
function GenTextureMipmaps called 0 returned 0% blocks executed 0%
    #####: 2934:void GenTextureMipmaps(Texture2D *texture)
        -: 2935:{
        -: 2936:    // NOTE: NPOT textures support check inside function
        -: 2937:    // On WebGL (OpenGL ES 2.0) NPOT textures support is limited
    #####: 2938:    rlGenTextureMipmaps(texture->id, texture->width, texture->height, texture->format, &texture->mipmaps);
    %%%%%: 2938-block  0
call    0 never executed
    #####: 2939:}
        -: 2940:
        -: 2941:// Set texture scaling filter mode
function SetTextureFilter called 0 returned 0% blocks executed 0%
    #####: 2942:void SetTextureFilter(Texture2D texture, int filter)
        -: 2943:{
    #####: 2944:    switch (filter)
    %%%%%: 2944-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 2945:    {
    #####: 2946:        case TEXTURE_FILTER_POINT:
        -: 2947:        {
    #####: 2948:            if (texture.mipmaps > 1)
    %%%%%: 2948-block  0
branch  0 never executed
branch  1 never executed
        -: 2949:            {
        -: 2950:                // RL_TEXTURE_FILTER_MIP_NEAREST - tex filter: POINT, mipmaps filter: POINT (sharp switching between mipmaps)
    #####: 2951:                rlTextureParameters(texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_MIP_NEAREST);
    %%%%%: 2951-block  0
call    0 never executed
        -: 2952:
        -: 2953:                // RL_TEXTURE_FILTER_NEAREST - tex filter: POINT (no filter), no mipmaps
    #####: 2954:                rlTextureParameters(texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_NEAREST);
call    0 never executed
        -: 2955:            }
        -: 2956:            else
        -: 2957:            {
        -: 2958:                // RL_TEXTURE_FILTER_NEAREST - tex filter: POINT (no filter), no mipmaps
    #####: 2959:                rlTextureParameters(texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_NEAREST);
    %%%%%: 2959-block  0
call    0 never executed
    #####: 2960:                rlTextureParameters(texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_NEAREST);
call    0 never executed
        -: 2961:            }
    #####: 2962:        } break;
    %%%%%: 2962-block  0
    #####: 2963:        case TEXTURE_FILTER_BILINEAR:
        -: 2964:        {
    #####: 2965:            if (texture.mipmaps > 1)
    %%%%%: 2965-block  0
branch  0 never executed
branch  1 never executed
        -: 2966:            {
        -: 2967:                // RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST - tex filter: BILINEAR, mipmaps filter: POINT (sharp switching between mipmaps)
        -: 2968:                // Alternative: RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR - tex filter: POINT, mipmaps filter: BILINEAR (smooth transition between mipmaps)
    #####: 2969:                rlTextureParameters(texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST);
    %%%%%: 2969-block  0
call    0 never executed
        -: 2970:
        -: 2971:                // RL_TEXTURE_FILTER_LINEAR - tex filter: BILINEAR, no mipmaps
    #####: 2972:                rlTextureParameters(texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);
call    0 never executed
        -: 2973:            }
        -: 2974:            else
        -: 2975:            {
        -: 2976:                // RL_TEXTURE_FILTER_LINEAR - tex filter: BILINEAR, no mipmaps
    #####: 2977:                rlTextureParameters(texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);
    %%%%%: 2977-block  0
call    0 never executed
    #####: 2978:                rlTextureParameters(texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);
call    0 never executed
        -: 2979:            }
    #####: 2980:        } break;
    %%%%%: 2980-block  0
    #####: 2981:        case TEXTURE_FILTER_TRILINEAR:
        -: 2982:        {
    #####: 2983:            if (texture.mipmaps > 1)
    %%%%%: 2983-block  0
branch  0 never executed
branch  1 never executed
        -: 2984:            {
        -: 2985:                // RL_TEXTURE_FILTER_MIP_LINEAR - tex filter: BILINEAR, mipmaps filter: BILINEAR (smooth transition between mipmaps)
    #####: 2986:                rlTextureParameters(texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_MIP_LINEAR);
    %%%%%: 2986-block  0
call    0 never executed
        -: 2987:
        -: 2988:                // RL_TEXTURE_FILTER_LINEAR - tex filter: BILINEAR, no mipmaps
    #####: 2989:                rlTextureParameters(texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);
call    0 never executed
        -: 2990:            }
        -: 2991:            else
        -: 2992:            {
    #####: 2993:                TRACELOG(LOG_WARNING, "TEXTURE: [ID %i] No mipmaps available for TRILINEAR texture filtering", texture.id);
    %%%%%: 2993-block  0
call    0 never executed
        -: 2994:
        -: 2995:                // RL_TEXTURE_FILTER_LINEAR - tex filter: BILINEAR, no mipmaps
    #####: 2996:                rlTextureParameters(texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);
call    0 never executed
    #####: 2997:                rlTextureParameters(texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);
call    0 never executed
        -: 2998:            }
    #####: 2999:        } break;
    %%%%%: 2999-block  0
    #####: 3000:        case TEXTURE_FILTER_ANISOTROPIC_4X: rlTextureParameters(texture.id, RL_TEXTURE_FILTER_ANISOTROPIC, 4); break;
    %%%%%: 3000-block  0
call    0 never executed
    #####: 3001:        case TEXTURE_FILTER_ANISOTROPIC_8X: rlTextureParameters(texture.id, RL_TEXTURE_FILTER_ANISOTROPIC, 8); break;
    %%%%%: 3001-block  0
call    0 never executed
    #####: 3002:        case TEXTURE_FILTER_ANISOTROPIC_16X: rlTextureParameters(texture.id, RL_TEXTURE_FILTER_ANISOTROPIC, 16); break;
    %%%%%: 3002-block  0
call    0 never executed
    #####: 3003:        default: break;
    %%%%%: 3003-block  0
        -: 3004:    }
    #####: 3005:}
        -: 3006:
        -: 3007:// Set texture wrapping mode
function SetTextureWrap called 0 returned 0% blocks executed 0%
    #####: 3008:void SetTextureWrap(Texture2D texture, int wrap)
        -: 3009:{
    #####: 3010:    switch (wrap)
    %%%%%: 3010-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 3011:    {
    #####: 3012:        case TEXTURE_WRAP_REPEAT:
        -: 3013:        {
    #####: 3014:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_S, RL_TEXTURE_WRAP_REPEAT);
    %%%%%: 3014-block  0
call    0 never executed
    #####: 3015:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_T, RL_TEXTURE_WRAP_REPEAT);
call    0 never executed
    #####: 3016:        } break;
    #####: 3017:        case TEXTURE_WRAP_CLAMP:
        -: 3018:        {
    #####: 3019:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_S, RL_TEXTURE_WRAP_CLAMP);
    %%%%%: 3019-block  0
call    0 never executed
    #####: 3020:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_T, RL_TEXTURE_WRAP_CLAMP);
call    0 never executed
    #####: 3021:        } break;
    #####: 3022:        case TEXTURE_WRAP_MIRROR_REPEAT:
        -: 3023:        {
    #####: 3024:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_S, RL_TEXTURE_WRAP_MIRROR_REPEAT);
    %%%%%: 3024-block  0
call    0 never executed
    #####: 3025:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_T, RL_TEXTURE_WRAP_MIRROR_REPEAT);
call    0 never executed
    #####: 3026:        } break;
    #####: 3027:        case TEXTURE_WRAP_MIRROR_CLAMP:
        -: 3028:        {
    #####: 3029:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_S, RL_TEXTURE_WRAP_MIRROR_CLAMP);
    %%%%%: 3029-block  0
call    0 never executed
    #####: 3030:            rlTextureParameters(texture.id, RL_TEXTURE_WRAP_T, RL_TEXTURE_WRAP_MIRROR_CLAMP);
call    0 never executed
    #####: 3031:        } break;
    #####: 3032:        default: break;
    %%%%%: 3032-block  0
        -: 3033:    }
    #####: 3034:}
        -: 3035:
        -: 3036://------------------------------------------------------------------------------------
        -: 3037:// Texture drawing functions
        -: 3038://------------------------------------------------------------------------------------
        -: 3039:// Draw a Texture2D
function DrawTexture called 0 returned 0% blocks executed 0%
    #####: 3040:void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
        -: 3041:{
    #####: 3042:    DrawTextureEx(texture, (Vector2){ (float)posX, (float)posY }, 0.0f, 1.0f, tint);
    %%%%%: 3042-block  0
call    0 never executed
    #####: 3043:}
        -: 3044:
        -: 3045:// Draw a Texture2D with position defined as Vector2
function DrawTextureV called 0 returned 0% blocks executed 0%
    #####: 3046:void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
        -: 3047:{
    #####: 3048:    DrawTextureEx(texture, position, 0, 1.0f, tint);
    %%%%%: 3048-block  0
call    0 never executed
    #####: 3049:}
        -: 3050:
        -: 3051:// Draw a Texture2D with extended parameters
function DrawTextureEx called 0 returned 0% blocks executed 0%
    #####: 3052:void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
        -: 3053:{
    #####: 3054:    Rectangle source = { 0.0f, 0.0f, (float)texture.width, (float)texture.height };
    #####: 3055:    Rectangle dest = { position.x, position.y, (float)texture.width*scale, (float)texture.height*scale };
    #####: 3056:    Vector2 origin = { 0.0f, 0.0f };
        -: 3057:
    #####: 3058:    DrawTexturePro(texture, source, dest, origin, rotation, tint);
    %%%%%: 3058-block  0
call    0 never executed
    #####: 3059:}
        -: 3060:
        -: 3061:// Draw a part of a texture (defined by a rectangle)
function DrawTextureRec called 0 returned 0% blocks executed 0%
    #####: 3062:void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
        -: 3063:{
    #####: 3064:    Rectangle dest = { position.x, position.y, fabsf(source.width), fabsf(source.height) };
    #####: 3065:    Vector2 origin = { 0.0f, 0.0f };
        -: 3066:
    #####: 3067:    DrawTexturePro(texture, source, dest, origin, 0.0f, tint);
    %%%%%: 3067-block  0
call    0 never executed
    #####: 3068:}
        -: 3069:
        -: 3070:// Draw texture quad with tiling and offset parameters
        -: 3071:// NOTE: Tiling and offset should be provided considering normalized texture values [0..1]
        -: 3072:// i.e tiling = { 1.0f, 1.0f } refers to all texture, offset = { 0.5f, 0.5f } moves texture origin to center
function DrawTextureQuad called 0 returned 0% blocks executed 0%
    #####: 3073:void DrawTextureQuad(Texture2D texture, Vector2 tiling, Vector2 offset, Rectangle quad, Color tint)
        -: 3074:{
    #####: 3075:    Rectangle source = { offset.x*texture.width, offset.y*texture.height, tiling.x*texture.width, tiling.y*texture.height };
    #####: 3076:    Vector2 origin = { 0.0f, 0.0f };
        -: 3077:
    #####: 3078:    DrawTexturePro(texture, source, quad, origin, 0.0f, tint);
    %%%%%: 3078-block  0
call    0 never executed
    #####: 3079:}
        -: 3080:
        -: 3081:// Draw part of a texture (defined by a rectangle) with rotation and scale tiled into dest.
        -: 3082:// NOTE: For tilling a whole texture DrawTextureQuad() is better
function DrawTextureTiled called 0 returned 0% blocks executed 0%
    #####: 3083:void DrawTextureTiled(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, float scale, Color tint)
        -: 3084:{
    #####: 3085:    if ((texture.id <= 0) || (scale <= 0.0f)) return;  // Wanna see a infinite loop?!...just delete this line!
    %%%%%: 3085-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3085-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3085-block  2
        -: 3086:
    #####: 3087:    int tileWidth = (int)(source.width*scale), tileHeight = (int)(source.height*scale);
    #####: 3088:    if ((dest.width < tileWidth) && (dest.height < tileHeight))
    %%%%%: 3088-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3088-block  1
branch  2 never executed
branch  3 never executed
    #####: 3089:    {
        -: 3090:        // Can fit only one tile
    #####: 3091:        DrawTexturePro(texture, (Rectangle){source.x, source.y, ((float)dest.width/tileWidth)*source.width, ((float)dest.height/tileHeight)*source.height},
    #####: 3092:                    (Rectangle){dest.x, dest.y, dest.width, dest.height}, origin, rotation, tint);
    %%%%%: 3092-block  0
call    0 never executed
        -: 3093:    }
    #####: 3094:    else if (dest.width <= tileWidth)
    %%%%%: 3094-block  0
branch  0 never executed
branch  1 never executed
        -: 3095:    {
        -: 3096:        // Tiled vertically (one column)
    #####: 3097:        int dy = 0;
    #####: 3098:        for (;dy+tileHeight < dest.height; dy += tileHeight)
    %%%%%: 3098-block  0
    %%%%%: 3098-block  1
branch  0 never executed
branch  1 never executed
        -: 3099:        {
    #####: 3100:            DrawTexturePro(texture, (Rectangle){source.x, source.y, ((float)dest.width/tileWidth)*source.width, source.height}, (Rectangle){dest.x, dest.y + dy, dest.width, (float)tileHeight}, origin, rotation, tint);
    %%%%%: 3100-block  0
call    0 never executed
        -: 3101:        }
        -: 3102:
        -: 3103:        // Fit last tile
    #####: 3104:        if (dy < dest.height)
    %%%%%: 3104-block  0
branch  0 never executed
branch  1 never executed
        -: 3105:        {
    #####: 3106:            DrawTexturePro(texture, (Rectangle){source.x, source.y, ((float)dest.width/tileWidth)*source.width, ((float)(dest.height - dy)/tileHeight)*source.height},
    #####: 3107:                        (Rectangle){dest.x, dest.y + dy, dest.width, dest.height - dy}, origin, rotation, tint);
    %%%%%: 3107-block  0
call    0 never executed
        -: 3108:        }
        -: 3109:    }
    #####: 3110:    else if (dest.height <= tileHeight)
    %%%%%: 3110-block  0
branch  0 never executed
branch  1 never executed
        -: 3111:    {
        -: 3112:        // Tiled horizontally (one row)
    #####: 3113:        int dx = 0;
    #####: 3114:        for (;dx+tileWidth < dest.width; dx += tileWidth)
    %%%%%: 3114-block  0
    %%%%%: 3114-block  1
branch  0 never executed
branch  1 never executed
        -: 3115:        {
    #####: 3116:            DrawTexturePro(texture, (Rectangle){source.x, source.y, source.width, ((float)dest.height/tileHeight)*source.height}, (Rectangle){dest.x + dx, dest.y, (float)tileWidth, dest.height}, origin, rotation, tint);
    %%%%%: 3116-block  0
call    0 never executed
        -: 3117:        }
        -: 3118:
        -: 3119:        // Fit last tile
    #####: 3120:        if (dx < dest.width)
    %%%%%: 3120-block  0
branch  0 never executed
branch  1 never executed
        -: 3121:        {
    #####: 3122:            DrawTexturePro(texture, (Rectangle){source.x, source.y, ((float)(dest.width - dx)/tileWidth)*source.width, ((float)dest.height/tileHeight)*source.height},
    #####: 3123:                        (Rectangle){dest.x + dx, dest.y, dest.width - dx, dest.height}, origin, rotation, tint);
    %%%%%: 3123-block  0
call    0 never executed
        -: 3124:        }
        -: 3125:    }
        -: 3126:    else
        -: 3127:    {
        -: 3128:        // Tiled both horizontally and vertically (rows and columns)
    #####: 3129:        int dx = 0;
    #####: 3130:        for (;dx+tileWidth < dest.width; dx += tileWidth)
    %%%%%: 3130-block  0
    %%%%%: 3130-block  1
    %%%%%: 3130-block  2
branch  0 never executed
branch  1 never executed
        -: 3131:        {
    #####: 3132:            int dy = 0;
    #####: 3133:            for (;dy+tileHeight < dest.height; dy += tileHeight)
    %%%%%: 3133-block  0
    %%%%%: 3133-block  1
branch  0 never executed
branch  1 never executed
        -: 3134:            {
    #####: 3135:                DrawTexturePro(texture, source, (Rectangle){dest.x + dx, dest.y + dy, (float)tileWidth, (float)tileHeight}, origin, rotation, tint);
    %%%%%: 3135-block  0
call    0 never executed
        -: 3136:            }
        -: 3137:
    #####: 3138:            if (dy < dest.height)
    %%%%%: 3138-block  0
branch  0 never executed
branch  1 never executed
        -: 3139:            {
    #####: 3140:                DrawTexturePro(texture, (Rectangle){source.x, source.y, source.width, ((float)(dest.height - dy)/tileHeight)*source.height},
    #####: 3141:                    (Rectangle){dest.x + dx, dest.y + dy, (float)tileWidth, dest.height - dy}, origin, rotation, tint);
    %%%%%: 3141-block  0
call    0 never executed
        -: 3142:            }
        -: 3143:        }
        -: 3144:
        -: 3145:        // Fit last column of tiles
    #####: 3146:        if (dx < dest.width)
    %%%%%: 3146-block  0
branch  0 never executed
branch  1 never executed
        -: 3147:        {
    #####: 3148:            int dy = 0;
    #####: 3149:            for (;dy+tileHeight < dest.height; dy += tileHeight)
    %%%%%: 3149-block  0
    %%%%%: 3149-block  1
branch  0 never executed
branch  1 never executed
        -: 3150:            {
    #####: 3151:                DrawTexturePro(texture, (Rectangle){source.x, source.y, ((float)(dest.width - dx)/tileWidth)*source.width, source.height},
    #####: 3152:                        (Rectangle){dest.x + dx, dest.y + dy, dest.width - dx, (float)tileHeight}, origin, rotation, tint);
    %%%%%: 3152-block  0
call    0 never executed
        -: 3153:            }
        -: 3154:
        -: 3155:            // Draw final tile in the bottom right corner
    #####: 3156:            if (dy < dest.height)
    %%%%%: 3156-block  0
branch  0 never executed
branch  1 never executed
        -: 3157:            {
    #####: 3158:                DrawTexturePro(texture, (Rectangle){source.x, source.y, ((float)(dest.width - dx)/tileWidth)*source.width, ((float)(dest.height - dy)/tileHeight)*source.height},
    #####: 3159:                    (Rectangle){dest.x + dx, dest.y + dy, dest.width - dx, dest.height - dy}, origin, rotation, tint);
    %%%%%: 3159-block  0
call    0 never executed
        -: 3160:            }
        -: 3161:        }
        -: 3162:    }
        -: 3163:}
        -: 3164:
        -: 3165:// Draw a part of a texture (defined by a rectangle) with 'pro' parameters
        -: 3166:// NOTE: origin is relative to destination rectangle size
function DrawTexturePro called 0 returned 0% blocks executed 0%
    #####: 3167:void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
        -: 3168:{
        -: 3169:    // Check if texture is valid
    #####: 3170:    if (texture.id > 0)
    %%%%%: 3170-block  0
branch  0 never executed
branch  1 never executed
        -: 3171:    {
    #####: 3172:        float width = (float)texture.width;
    #####: 3173:        float height = (float)texture.height;
        -: 3174:
    #####: 3175:        bool flipX = false;
        -: 3176:
    #####: 3177:        if (source.width < 0) { flipX = true; source.width *= -1; }
    %%%%%: 3177-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3177-block  1
    #####: 3178:        if (source.height < 0) source.y -= source.height;
    %%%%%: 3178-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3178-block  1
        -: 3179:
    #####: 3180:        Vector2 topLeft = { 0 };
    #####: 3181:        Vector2 topRight = { 0 };
    #####: 3182:        Vector2 bottomLeft = { 0 };
    #####: 3183:        Vector2 bottomRight = { 0 };
        -: 3184:
        -: 3185:        // Only calculate rotation if needed
    #####: 3186:        if (rotation == 0.0f)
    %%%%%: 3186-block  0
branch  0 never executed
branch  1 never executed
        -: 3187:        {
    #####: 3188:            float x = dest.x - origin.x;
    #####: 3189:            float y = dest.y - origin.y;
    #####: 3190:            topLeft = (Vector2){ x, y };
    #####: 3191:            topRight = (Vector2){ x + dest.width, y };
    #####: 3192:            bottomLeft = (Vector2){ x, y + dest.height };
    #####: 3193:            bottomRight = (Vector2){ x + dest.width, y + dest.height };
    %%%%%: 3193-block  0
        -: 3194:        }
        -: 3195:        else
        -: 3196:        {
    #####: 3197:            float sinRotation = sinf(rotation*DEG2RAD);
    #####: 3198:            float cosRotation = cosf(rotation*DEG2RAD);
    #####: 3199:            float x = dest.x;
    #####: 3200:            float y = dest.y;
    #####: 3201:            float dx = -origin.x;
    #####: 3202:            float dy = -origin.y;
        -: 3203:
    #####: 3204:            topLeft.x = x + dx*cosRotation - dy*sinRotation;
    #####: 3205:            topLeft.y = y + dx*sinRotation + dy*cosRotation;
        -: 3206:
    #####: 3207:            topRight.x = x + (dx + dest.width)*cosRotation - dy*sinRotation;
    #####: 3208:            topRight.y = y + (dx + dest.width)*sinRotation + dy*cosRotation;
        -: 3209:
    #####: 3210:            bottomLeft.x = x + dx*cosRotation - (dy + dest.height)*sinRotation;
    #####: 3211:            bottomLeft.y = y + dx*sinRotation + (dy + dest.height)*cosRotation;
        -: 3212:
    #####: 3213:            bottomRight.x = x + (dx + dest.width)*cosRotation - (dy + dest.height)*sinRotation;
    #####: 3214:            bottomRight.y = y + (dx + dest.width)*sinRotation + (dy + dest.height)*cosRotation;
    %%%%%: 3214-block  0
        -: 3215:        }
        -: 3216:
    #####: 3217:        rlCheckRenderBatchLimit(4);     // Make sure there is enough free space on the batch buffer
    %%%%%: 3217-block  0
call    0 never executed
        -: 3218:
    #####: 3219:        rlSetTexture(texture.id);
call    0 never executed
    #####: 3220:        rlBegin(RL_QUADS);
call    0 never executed
        -: 3221:
    #####: 3222:            rlColor4ub(tint.r, tint.g, tint.b, tint.a);
call    0 never executed
    #####: 3223:            rlNormal3f(0.0f, 0.0f, 1.0f);                          // Normal vector pointing towards viewer
call    0 never executed
        -: 3224:
        -: 3225:            // Top-left corner for texture and quad
    #####: 3226:            if (flipX) rlTexCoord2f((source.x + source.width)/width, source.y/height);
branch  0 never executed
branch  1 never executed
    %%%%%: 3226-block  0
call    2 never executed
    #####: 3227:            else rlTexCoord2f(source.x/width, source.y/height);
    %%%%%: 3227-block  0
call    0 never executed
    #####: 3228:            rlVertex2f(topLeft.x, topLeft.y);
    %%%%%: 3228-block  0
call    0 never executed
        -: 3229:
        -: 3230:            // Bottom-left corner for texture and quad
    #####: 3231:            if (flipX) rlTexCoord2f((source.x + source.width)/width, (source.y + source.height)/height);
branch  0 never executed
branch  1 never executed
    %%%%%: 3231-block  0
call    2 never executed
    #####: 3232:            else rlTexCoord2f(source.x/width, (source.y + source.height)/height);
    %%%%%: 3232-block  0
call    0 never executed
    #####: 3233:            rlVertex2f(bottomLeft.x, bottomLeft.y);
    %%%%%: 3233-block  0
call    0 never executed
        -: 3234:
        -: 3235:            // Bottom-right corner for texture and quad
    #####: 3236:            if (flipX) rlTexCoord2f(source.x/width, (source.y + source.height)/height);
branch  0 never executed
branch  1 never executed
    %%%%%: 3236-block  0
call    2 never executed
    #####: 3237:            else rlTexCoord2f((source.x + source.width)/width, (source.y + source.height)/height);
    %%%%%: 3237-block  0
call    0 never executed
    #####: 3238:            rlVertex2f(bottomRight.x, bottomRight.y);
    %%%%%: 3238-block  0
call    0 never executed
        -: 3239:
        -: 3240:            // Top-right corner for texture and quad
    #####: 3241:            if (flipX) rlTexCoord2f(source.x/width, source.y/height);
branch  0 never executed
branch  1 never executed
    %%%%%: 3241-block  0
call    2 never executed
    #####: 3242:            else rlTexCoord2f((source.x + source.width)/width, source.y/height);
    %%%%%: 3242-block  0
call    0 never executed
    #####: 3243:            rlVertex2f(topRight.x, topRight.y);
    %%%%%: 3243-block  0
call    0 never executed
        -: 3244:
    #####: 3245:        rlEnd();
call    0 never executed
    #####: 3246:        rlSetTexture(0);
call    0 never executed
        -: 3247:
        -: 3248:        // NOTE: Vertex position can be transformed using matrices
        -: 3249:        // but the process is way more costly than just calculating
        -: 3250:        // the vertex positions manually, like done above.
        -: 3251:        // I leave here the old implementation for educational pourposes,
        -: 3252:        // just in case someone wants to do some performance test
        -: 3253:        /*
        -: 3254:        rlSetTexture(texture.id);
        -: 3255:        rlPushMatrix();
        -: 3256:            rlTranslatef(dest.x, dest.y, 0.0f);
        -: 3257:            if (rotation != 0.0f) rlRotatef(rotation, 0.0f, 0.0f, 1.0f);
        -: 3258:            rlTranslatef(-origin.x, -origin.y, 0.0f);
        -: 3259:
        -: 3260:            rlBegin(RL_QUADS);
        -: 3261:                rlColor4ub(tint.r, tint.g, tint.b, tint.a);
        -: 3262:                rlNormal3f(0.0f, 0.0f, 1.0f);                          // Normal vector pointing towards viewer
        -: 3263:
        -: 3264:                // Bottom-left corner for texture and quad
        -: 3265:                if (flipX) rlTexCoord2f((source.x + source.width)/width, source.y/height);
        -: 3266:                else rlTexCoord2f(source.x/width, source.y/height);
        -: 3267:                rlVertex2f(0.0f, 0.0f);
        -: 3268:
        -: 3269:                // Bottom-right corner for texture and quad
        -: 3270:                if (flipX) rlTexCoord2f((source.x + source.width)/width, (source.y + source.height)/height);
        -: 3271:                else rlTexCoord2f(source.x/width, (source.y + source.height)/height);
        -: 3272:                rlVertex2f(0.0f, dest.height);
        -: 3273:
        -: 3274:                // Top-right corner for texture and quad
        -: 3275:                if (flipX) rlTexCoord2f(source.x/width, (source.y + source.height)/height);
        -: 3276:                else rlTexCoord2f((source.x + source.width)/width, (source.y + source.height)/height);
        -: 3277:                rlVertex2f(dest.width, dest.height);
        -: 3278:
        -: 3279:                // Top-left corner for texture and quad
        -: 3280:                if (flipX) rlTexCoord2f(source.x/width, source.y/height);
        -: 3281:                else rlTexCoord2f((source.x + source.width)/width, source.y/height);
        -: 3282:                rlVertex2f(dest.width, 0.0f);
        -: 3283:            rlEnd();
        -: 3284:        rlPopMatrix();
        -: 3285:        rlSetTexture(0);
        -: 3286:        */
        -: 3287:    }
    #####: 3288:}
        -: 3289:
        -: 3290:// Draws a texture (or part of it) that stretches or shrinks nicely using n-patch info
function DrawTextureNPatch called 0 returned 0% blocks executed 0%
    #####: 3291:void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
        -: 3292:{
    #####: 3293:    if (texture.id > 0)
    %%%%%: 3293-block  0
branch  0 never executed
branch  1 never executed
        -: 3294:    {
    #####: 3295:        float width = (float)texture.width;
    #####: 3296:        float height = (float)texture.height;
        -: 3297:
    #####: 3298:        float patchWidth = ((int)dest.width <= 0)? 0.0f : dest.width;
    %%%%%: 3298-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3298-block  1
    %%%%%: 3298-block  2
    #####: 3299:        float patchHeight = ((int)dest.height <= 0)? 0.0f : dest.height;
    %%%%%: 3299-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3299-block  1
    %%%%%: 3299-block  2
        -: 3300:
    #####: 3301:        if (nPatchInfo.source.width < 0) nPatchInfo.source.x -= nPatchInfo.source.width;
    %%%%%: 3301-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3301-block  1
    #####: 3302:        if (nPatchInfo.source.height < 0) nPatchInfo.source.y -= nPatchInfo.source.height;
    %%%%%: 3302-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3302-block  1
    #####: 3303:        if (nPatchInfo.layout == NPATCH_THREE_PATCH_HORIZONTAL) patchHeight = nPatchInfo.source.height;
    %%%%%: 3303-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3303-block  1
    #####: 3304:        if (nPatchInfo.layout == NPATCH_THREE_PATCH_VERTICAL) patchWidth = nPatchInfo.source.width;
    %%%%%: 3304-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3304-block  1
        -: 3305:
    #####: 3306:        bool drawCenter = true;
    #####: 3307:        bool drawMiddle = true;
    #####: 3308:        float leftBorder = (float)nPatchInfo.left;
    #####: 3309:        float topBorder = (float)nPatchInfo.top;
    #####: 3310:        float rightBorder = (float)nPatchInfo.right;
    #####: 3311:        float bottomBorder = (float)nPatchInfo.bottom;
        -: 3312:
        -: 3313:        // Adjust the lateral (left and right) border widths in case patchWidth < texture.width
    #####: 3314:        if (patchWidth <= (leftBorder + rightBorder) && nPatchInfo.layout != NPATCH_THREE_PATCH_VERTICAL)
    %%%%%: 3314-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3314-block  1
branch  2 never executed
branch  3 never executed
        -: 3315:        {
    #####: 3316:            drawCenter = false;
    #####: 3317:            leftBorder = (leftBorder/(leftBorder + rightBorder))*patchWidth;
    #####: 3318:            rightBorder = patchWidth - leftBorder;
    %%%%%: 3318-block  0
        -: 3319:        }
        -: 3320:
        -: 3321:        // Adjust the lateral (top and bottom) border heights in case patchHeight < texture.height
    #####: 3322:        if (patchHeight <= (topBorder + bottomBorder) && nPatchInfo.layout != NPATCH_THREE_PATCH_HORIZONTAL)
    %%%%%: 3322-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3322-block  1
branch  2 never executed
branch  3 never executed
        -: 3323:        {
    #####: 3324:            drawMiddle = false;
    #####: 3325:            topBorder = (topBorder/(topBorder + bottomBorder))*patchHeight;
    #####: 3326:            bottomBorder = patchHeight - topBorder;
    %%%%%: 3326-block  0
        -: 3327:        }
        -: 3328:
        -: 3329:        Vector2 vertA, vertB, vertC, vertD;
    #####: 3330:        vertA.x = 0.0f;                             // outer left
    #####: 3331:        vertA.y = 0.0f;                             // outer top
    #####: 3332:        vertB.x = leftBorder;                       // inner left
    #####: 3333:        vertB.y = topBorder;                        // inner top
    #####: 3334:        vertC.x = patchWidth  - rightBorder;        // inner right
    #####: 3335:        vertC.y = patchHeight - bottomBorder;       // inner bottom
    #####: 3336:        vertD.x = patchWidth;                       // outer right
    #####: 3337:        vertD.y = patchHeight;                      // outer bottom
        -: 3338:
        -: 3339:        Vector2 coordA, coordB, coordC, coordD;
    #####: 3340:        coordA.x = nPatchInfo.source.x/width;
    #####: 3341:        coordA.y = nPatchInfo.source.y/height;
    #####: 3342:        coordB.x = (nPatchInfo.source.x + leftBorder)/width;
    #####: 3343:        coordB.y = (nPatchInfo.source.y + topBorder)/height;
    #####: 3344:        coordC.x = (nPatchInfo.source.x + nPatchInfo.source.width  - rightBorder)/width;
    #####: 3345:        coordC.y = (nPatchInfo.source.y + nPatchInfo.source.height - bottomBorder)/height;
    #####: 3346:        coordD.x = (nPatchInfo.source.x + nPatchInfo.source.width)/width;
    #####: 3347:        coordD.y = (nPatchInfo.source.y + nPatchInfo.source.height)/height;
        -: 3348:
    #####: 3349:        rlSetTexture(texture.id);
    %%%%%: 3349-block  0
call    0 never executed
        -: 3350:
    #####: 3351:        rlPushMatrix();
call    0 never executed
    #####: 3352:            rlTranslatef(dest.x, dest.y, 0.0f);
call    0 never executed
    #####: 3353:            rlRotatef(rotation, 0.0f, 0.0f, 1.0f);
call    0 never executed
    #####: 3354:            rlTranslatef(-origin.x, -origin.y, 0.0f);
call    0 never executed
        -: 3355:
    #####: 3356:            rlBegin(RL_QUADS);
call    0 never executed
    #####: 3357:                rlColor4ub(tint.r, tint.g, tint.b, tint.a);
call    0 never executed
    #####: 3358:                rlNormal3f(0.0f, 0.0f, 1.0f);               // Normal vector pointing towards viewer
call    0 never executed
        -: 3359:
    #####: 3360:                if (nPatchInfo.layout == NPATCH_NINE_PATCH)
branch  0 never executed
branch  1 never executed
        -: 3361:                {
        -: 3362:                    // ------------------------------------------------------------
        -: 3363:                    // TOP-LEFT QUAD
    #####: 3364:                    rlTexCoord2f(coordA.x, coordB.y); rlVertex2f(vertA.x, vertB.y);  // Bottom-left corner for texture and quad
    %%%%%: 3364-block  0
call    0 never executed
call    1 never executed
    #####: 3365:                    rlTexCoord2f(coordB.x, coordB.y); rlVertex2f(vertB.x, vertB.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3366:                    rlTexCoord2f(coordB.x, coordA.y); rlVertex2f(vertB.x, vertA.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3367:                    rlTexCoord2f(coordA.x, coordA.y); rlVertex2f(vertA.x, vertA.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3368:                    if (drawCenter)
branch  0 never executed
branch  1 never executed
        -: 3369:                    {
        -: 3370:                        // TOP-CENTER QUAD
    #####: 3371:                        rlTexCoord2f(coordB.x, coordB.y); rlVertex2f(vertB.x, vertB.y);  // Bottom-left corner for texture and quad
    %%%%%: 3371-block  0
call    0 never executed
call    1 never executed
    #####: 3372:                        rlTexCoord2f(coordC.x, coordB.y); rlVertex2f(vertC.x, vertB.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3373:                        rlTexCoord2f(coordC.x, coordA.y); rlVertex2f(vertC.x, vertA.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3374:                        rlTexCoord2f(coordB.x, coordA.y); rlVertex2f(vertB.x, vertA.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3375:                    }
        -: 3376:                    // TOP-RIGHT QUAD
    #####: 3377:                    rlTexCoord2f(coordC.x, coordB.y); rlVertex2f(vertC.x, vertB.y);  // Bottom-left corner for texture and quad
    %%%%%: 3377-block  0
call    0 never executed
call    1 never executed
    #####: 3378:                    rlTexCoord2f(coordD.x, coordB.y); rlVertex2f(vertD.x, vertB.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3379:                    rlTexCoord2f(coordD.x, coordA.y); rlVertex2f(vertD.x, vertA.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3380:                    rlTexCoord2f(coordC.x, coordA.y); rlVertex2f(vertC.x, vertA.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3381:                    if (drawMiddle)
branch  0 never executed
branch  1 never executed
        -: 3382:                    {
        -: 3383:                        // ------------------------------------------------------------
        -: 3384:                        // MIDDLE-LEFT QUAD
    #####: 3385:                        rlTexCoord2f(coordA.x, coordC.y); rlVertex2f(vertA.x, vertC.y);  // Bottom-left corner for texture and quad
    %%%%%: 3385-block  0
call    0 never executed
call    1 never executed
    #####: 3386:                        rlTexCoord2f(coordB.x, coordC.y); rlVertex2f(vertB.x, vertC.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3387:                        rlTexCoord2f(coordB.x, coordB.y); rlVertex2f(vertB.x, vertB.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3388:                        rlTexCoord2f(coordA.x, coordB.y); rlVertex2f(vertA.x, vertB.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3389:                        if (drawCenter)
branch  0 never executed
branch  1 never executed
        -: 3390:                        {
        -: 3391:                            // MIDDLE-CENTER QUAD
    #####: 3392:                            rlTexCoord2f(coordB.x, coordC.y); rlVertex2f(vertB.x, vertC.y);  // Bottom-left corner for texture and quad
    %%%%%: 3392-block  0
call    0 never executed
call    1 never executed
    #####: 3393:                            rlTexCoord2f(coordC.x, coordC.y); rlVertex2f(vertC.x, vertC.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3394:                            rlTexCoord2f(coordC.x, coordB.y); rlVertex2f(vertC.x, vertB.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3395:                            rlTexCoord2f(coordB.x, coordB.y); rlVertex2f(vertB.x, vertB.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3396:                        }
        -: 3397:
        -: 3398:                        // MIDDLE-RIGHT QUAD
    #####: 3399:                        rlTexCoord2f(coordC.x, coordC.y); rlVertex2f(vertC.x, vertC.y);  // Bottom-left corner for texture and quad
    %%%%%: 3399-block  0
call    0 never executed
call    1 never executed
    #####: 3400:                        rlTexCoord2f(coordD.x, coordC.y); rlVertex2f(vertD.x, vertC.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3401:                        rlTexCoord2f(coordD.x, coordB.y); rlVertex2f(vertD.x, vertB.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3402:                        rlTexCoord2f(coordC.x, coordB.y); rlVertex2f(vertC.x, vertB.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3403:                    }
        -: 3404:
        -: 3405:                    // ------------------------------------------------------------
        -: 3406:                    // BOTTOM-LEFT QUAD
    #####: 3407:                    rlTexCoord2f(coordA.x, coordD.y); rlVertex2f(vertA.x, vertD.y);  // Bottom-left corner for texture and quad
    %%%%%: 3407-block  0
call    0 never executed
call    1 never executed
    #####: 3408:                    rlTexCoord2f(coordB.x, coordD.y); rlVertex2f(vertB.x, vertD.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3409:                    rlTexCoord2f(coordB.x, coordC.y); rlVertex2f(vertB.x, vertC.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3410:                    rlTexCoord2f(coordA.x, coordC.y); rlVertex2f(vertA.x, vertC.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3411:                    if (drawCenter)
branch  0 never executed
branch  1 never executed
        -: 3412:                    {
        -: 3413:                        // BOTTOM-CENTER QUAD
    #####: 3414:                        rlTexCoord2f(coordB.x, coordD.y); rlVertex2f(vertB.x, vertD.y);  // Bottom-left corner for texture and quad
    %%%%%: 3414-block  0
call    0 never executed
call    1 never executed
    #####: 3415:                        rlTexCoord2f(coordC.x, coordD.y); rlVertex2f(vertC.x, vertD.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3416:                        rlTexCoord2f(coordC.x, coordC.y); rlVertex2f(vertC.x, vertC.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3417:                        rlTexCoord2f(coordB.x, coordC.y); rlVertex2f(vertB.x, vertC.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3418:                    }
        -: 3419:
        -: 3420:                    // BOTTOM-RIGHT QUAD
    #####: 3421:                    rlTexCoord2f(coordC.x, coordD.y); rlVertex2f(vertC.x, vertD.y);  // Bottom-left corner for texture and quad
    %%%%%: 3421-block  0
call    0 never executed
call    1 never executed
    #####: 3422:                    rlTexCoord2f(coordD.x, coordD.y); rlVertex2f(vertD.x, vertD.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3423:                    rlTexCoord2f(coordD.x, coordC.y); rlVertex2f(vertD.x, vertC.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3424:                    rlTexCoord2f(coordC.x, coordC.y); rlVertex2f(vertC.x, vertC.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3425:                }
    #####: 3426:                else if (nPatchInfo.layout == NPATCH_THREE_PATCH_VERTICAL)
    %%%%%: 3426-block  0
branch  0 never executed
branch  1 never executed
        -: 3427:                {
        -: 3428:                    // TOP QUAD
        -: 3429:                    // -----------------------------------------------------------
        -: 3430:                    // Texture coords                 Vertices
    #####: 3431:                    rlTexCoord2f(coordA.x, coordB.y); rlVertex2f(vertA.x, vertB.y);  // Bottom-left corner for texture and quad
    %%%%%: 3431-block  0
call    0 never executed
call    1 never executed
    #####: 3432:                    rlTexCoord2f(coordD.x, coordB.y); rlVertex2f(vertD.x, vertB.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3433:                    rlTexCoord2f(coordD.x, coordA.y); rlVertex2f(vertD.x, vertA.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3434:                    rlTexCoord2f(coordA.x, coordA.y); rlVertex2f(vertA.x, vertA.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3435:                    if (drawCenter)
branch  0 never executed
branch  1 never executed
        -: 3436:                    {
        -: 3437:                        // MIDDLE QUAD
        -: 3438:                        // -----------------------------------------------------------
        -: 3439:                        // Texture coords                 Vertices
    #####: 3440:                        rlTexCoord2f(coordA.x, coordC.y); rlVertex2f(vertA.x, vertC.y);  // Bottom-left corner for texture and quad
    %%%%%: 3440-block  0
call    0 never executed
call    1 never executed
    #####: 3441:                        rlTexCoord2f(coordD.x, coordC.y); rlVertex2f(vertD.x, vertC.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3442:                        rlTexCoord2f(coordD.x, coordB.y); rlVertex2f(vertD.x, vertB.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3443:                        rlTexCoord2f(coordA.x, coordB.y); rlVertex2f(vertA.x, vertB.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3444:                    }
        -: 3445:                    // BOTTOM QUAD
        -: 3446:                    // -----------------------------------------------------------
        -: 3447:                    // Texture coords                 Vertices
    #####: 3448:                    rlTexCoord2f(coordA.x, coordD.y); rlVertex2f(vertA.x, vertD.y);  // Bottom-left corner for texture and quad
    %%%%%: 3448-block  0
call    0 never executed
call    1 never executed
    #####: 3449:                    rlTexCoord2f(coordD.x, coordD.y); rlVertex2f(vertD.x, vertD.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3450:                    rlTexCoord2f(coordD.x, coordC.y); rlVertex2f(vertD.x, vertC.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3451:                    rlTexCoord2f(coordA.x, coordC.y); rlVertex2f(vertA.x, vertC.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3452:                }
    #####: 3453:                else if (nPatchInfo.layout == NPATCH_THREE_PATCH_HORIZONTAL)
    %%%%%: 3453-block  0
branch  0 never executed
branch  1 never executed
        -: 3454:                {
        -: 3455:                    // LEFT QUAD
        -: 3456:                    // -----------------------------------------------------------
        -: 3457:                    // Texture coords                 Vertices
    #####: 3458:                    rlTexCoord2f(coordA.x, coordD.y); rlVertex2f(vertA.x, vertD.y);  // Bottom-left corner for texture and quad
    %%%%%: 3458-block  0
call    0 never executed
call    1 never executed
    #####: 3459:                    rlTexCoord2f(coordB.x, coordD.y); rlVertex2f(vertB.x, vertD.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3460:                    rlTexCoord2f(coordB.x, coordA.y); rlVertex2f(vertB.x, vertA.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3461:                    rlTexCoord2f(coordA.x, coordA.y); rlVertex2f(vertA.x, vertA.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3462:                    if (drawCenter)
branch  0 never executed
branch  1 never executed
        -: 3463:                    {
        -: 3464:                        // CENTER QUAD
        -: 3465:                        // -----------------------------------------------------------
        -: 3466:                        // Texture coords                 Vertices
    #####: 3467:                        rlTexCoord2f(coordB.x, coordD.y); rlVertex2f(vertB.x, vertD.y);  // Bottom-left corner for texture and quad
    %%%%%: 3467-block  0
call    0 never executed
call    1 never executed
    #####: 3468:                        rlTexCoord2f(coordC.x, coordD.y); rlVertex2f(vertC.x, vertD.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3469:                        rlTexCoord2f(coordC.x, coordA.y); rlVertex2f(vertC.x, vertA.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3470:                        rlTexCoord2f(coordB.x, coordA.y); rlVertex2f(vertB.x, vertA.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3471:                    }
        -: 3472:                    // RIGHT QUAD
        -: 3473:                    // -----------------------------------------------------------
        -: 3474:                    // Texture coords                 Vertices
    #####: 3475:                    rlTexCoord2f(coordC.x, coordD.y); rlVertex2f(vertC.x, vertD.y);  // Bottom-left corner for texture and quad
    %%%%%: 3475-block  0
call    0 never executed
call    1 never executed
    #####: 3476:                    rlTexCoord2f(coordD.x, coordD.y); rlVertex2f(vertD.x, vertD.y);  // Bottom-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3477:                    rlTexCoord2f(coordD.x, coordA.y); rlVertex2f(vertD.x, vertA.y);  // Top-right corner for texture and quad
call    0 never executed
call    1 never executed
    #####: 3478:                    rlTexCoord2f(coordC.x, coordA.y); rlVertex2f(vertC.x, vertA.y);  // Top-left corner for texture and quad
call    0 never executed
call    1 never executed
        -: 3479:                }
    #####: 3480:            rlEnd();
    %%%%%: 3480-block  0
call    0 never executed
    #####: 3481:        rlPopMatrix();
call    0 never executed
        -: 3482:
    #####: 3483:        rlSetTexture(0);
call    0 never executed
        -: 3484:    }
    #####: 3485:}
        -: 3486:
        -: 3487:// Draw textured polygon, defined by vertex and texturecoordinates
        -: 3488:// NOTE: Polygon center must have straight line path to all points
        -: 3489:// without crossing perimeter, points must be in anticlockwise order
function DrawTexturePoly called 0 returned 0% blocks executed 0%
    #####: 3490:void DrawTexturePoly(Texture2D texture, Vector2 center, Vector2 *points, Vector2 *texcoords, int pointCount, Color tint)
        -: 3491:{
    #####: 3492:    rlCheckRenderBatchLimit((pointCount - 1)*4);
    %%%%%: 3492-block  0
call    0 never executed
        -: 3493:
    #####: 3494:    rlSetTexture(texture.id);
call    0 never executed
        -: 3495:
        -: 3496:    // Texturing is only supported on QUADs
    #####: 3497:    rlBegin(RL_QUADS);
call    0 never executed
        -: 3498:
    #####: 3499:        rlColor4ub(tint.r, tint.g, tint.b, tint.a);
call    0 never executed
        -: 3500:
    #####: 3501:        for (int i = 0; i < pointCount - 1; i++)
    %%%%%: 3501-block  0
branch  0 never executed
branch  1 never executed
        -: 3502:        {
    #####: 3503:            rlTexCoord2f(0.5f, 0.5f);
    %%%%%: 3503-block  0
call    0 never executed
    #####: 3504:            rlVertex2f(center.x, center.y);
call    0 never executed
        -: 3505:
    #####: 3506:            rlTexCoord2f(texcoords[i].x, texcoords[i].y);
call    0 never executed
    #####: 3507:            rlVertex2f(points[i].x + center.x, points[i].y + center.y);
call    0 never executed
        -: 3508:
    #####: 3509:            rlTexCoord2f(texcoords[i + 1].x, texcoords[i + 1].y);
call    0 never executed
    #####: 3510:            rlVertex2f(points[i + 1].x + center.x, points[i + 1].y + center.y);
call    0 never executed
        -: 3511:
    #####: 3512:            rlTexCoord2f(texcoords[i + 1].x, texcoords[i + 1].y);
call    0 never executed
    #####: 3513:            rlVertex2f(points[i + 1].x + center.x, points[i + 1].y + center.y);
call    0 never executed
        -: 3514:        }
    #####: 3515:    rlEnd();
    %%%%%: 3515-block  0
call    0 never executed
        -: 3516:
    #####: 3517:    rlSetTexture(0);
call    0 never executed
    #####: 3518:}
        -: 3519:
        -: 3520:// Get color with alpha applied, alpha goes from 0.0f to 1.0f
function Fade called 0 returned 0% blocks executed 0%
    #####: 3521:Color Fade(Color color, float alpha)
        -: 3522:{
    #####: 3523:    if (alpha < 0.0f) alpha = 0.0f;
    %%%%%: 3523-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3523-block  1
    #####: 3524:    else if (alpha > 1.0f) alpha = 1.0f;
    %%%%%: 3524-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3524-block  1
        -: 3525:
    #####: 3526:    return (Color){color.r, color.g, color.b, (unsigned char)(255.0f*alpha)};
    %%%%%: 3526-block  0
        -: 3527:}
        -: 3528:
        -: 3529:// Get hexadecimal value for a Color
function ColorToInt called 0 returned 0% blocks executed 0%
    #####: 3530:int ColorToInt(Color color)
        -: 3531:{
    #####: 3532:    return (((int)color.r << 24) | ((int)color.g << 16) | ((int)color.b << 8) | (int)color.a);
    %%%%%: 3532-block  0
        -: 3533:}
        -: 3534:
        -: 3535:// Get color normalized as float [0..1]
function ColorNormalize called 0 returned 0% blocks executed 0%
    #####: 3536:Vector4 ColorNormalize(Color color)
        -: 3537:{
        -: 3538:    Vector4 result;
        -: 3539:
    #####: 3540:    result.x = (float)color.r/255.0f;
    #####: 3541:    result.y = (float)color.g/255.0f;
    #####: 3542:    result.z = (float)color.b/255.0f;
    #####: 3543:    result.w = (float)color.a/255.0f;
        -: 3544:
    #####: 3545:    return result;
    %%%%%: 3545-block  0
        -: 3546:}
        -: 3547:
        -: 3548:// Get color from normalized values [0..1]
function ColorFromNormalized called 0 returned 0% blocks executed 0%
    #####: 3549:Color ColorFromNormalized(Vector4 normalized)
        -: 3550:{
        -: 3551:    Color result;
        -: 3552:
    #####: 3553:    result.r = (unsigned char)(normalized.x*255.0f);
    #####: 3554:    result.g = (unsigned char)(normalized.y*255.0f);
    #####: 3555:    result.b = (unsigned char)(normalized.z*255.0f);
    #####: 3556:    result.a = (unsigned char)(normalized.w*255.0f);
        -: 3557:
    #####: 3558:    return result;
    %%%%%: 3558-block  0
        -: 3559:}
        -: 3560:
        -: 3561:// Get HSV values for a Color
        -: 3562:// NOTE: Hue is returned as degrees [0..360]
function ColorToHSV called 0 returned 0% blocks executed 0%
    #####: 3563:Vector3 ColorToHSV(Color color)
        -: 3564:{
    #####: 3565:    Vector3 hsv = { 0 };
    #####: 3566:    Vector3 rgb = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
        -: 3567:    float min, max, delta;
        -: 3568:
    #####: 3569:    min = rgb.x < rgb.y? rgb.x : rgb.y;
    %%%%%: 3569-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3569-block  1
    %%%%%: 3569-block  2
    #####: 3570:    min = min  < rgb.z? min  : rgb.z;
    %%%%%: 3570-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3570-block  1
    %%%%%: 3570-block  2
        -: 3571:
    #####: 3572:    max = rgb.x > rgb.y? rgb.x : rgb.y;
    %%%%%: 3572-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3572-block  1
    %%%%%: 3572-block  2
    #####: 3573:    max = max  > rgb.z? max  : rgb.z;
    %%%%%: 3573-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3573-block  1
    %%%%%: 3573-block  2
        -: 3574:
    #####: 3575:    hsv.z = max;            // Value
    #####: 3576:    delta = max - min;
        -: 3577:
    #####: 3578:    if (delta < 0.00001f)
    %%%%%: 3578-block  0
branch  0 never executed
branch  1 never executed
        -: 3579:    {
    #####: 3580:        hsv.y = 0.0f;
    #####: 3581:        hsv.x = 0.0f;       // Undefined, maybe NAN?
    #####: 3582:        return hsv;
    %%%%%: 3582-block  0
        -: 3583:    }
        -: 3584:
    #####: 3585:    if (max > 0.0f)
    %%%%%: 3585-block  0
branch  0 never executed
branch  1 never executed
        -: 3586:    {
        -: 3587:        // NOTE: If max is 0, this divide would cause a crash
    #####: 3588:        hsv.y = (delta/max);    // Saturation
    %%%%%: 3588-block  0
        -: 3589:    }
        -: 3590:    else
        -: 3591:    {
        -: 3592:        // NOTE: If max is 0, then r = g = b = 0, s = 0, h is undefined
    #####: 3593:        hsv.y = 0.0f;
    #####: 3594:        hsv.x = NAN;        // Undefined
    #####: 3595:        return hsv;
    %%%%%: 3595-block  0
        -: 3596:    }
        -: 3597:
        -: 3598:    // NOTE: Comparing float values could not work properly
    #####: 3599:    if (rgb.x >= max) hsv.x = (rgb.y - rgb.z)/delta;    // Between yellow & magenta
    %%%%%: 3599-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3599-block  1
        -: 3600:    else
        -: 3601:    {
    #####: 3602:        if (rgb.y >= max) hsv.x = 2.0f + (rgb.z - rgb.x)/delta;  // Between cyan & yellow
    %%%%%: 3602-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3602-block  1
    #####: 3603:        else hsv.x = 4.0f + (rgb.x - rgb.y)/delta;      // Between magenta & cyan
    %%%%%: 3603-block  0
        -: 3604:    }
        -: 3605:
    #####: 3606:    hsv.x *= 60.0f;     // Convert to degrees
        -: 3607:
    #####: 3608:    if (hsv.x < 0.0f) hsv.x += 360.0f;
    %%%%%: 3608-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3608-block  1
        -: 3609:
    #####: 3610:    return hsv;
    %%%%%: 3610-block  0
        -: 3611:}
        -: 3612:
        -: 3613:// Get a Color from HSV values
        -: 3614:// Implementation reference: https://en.wikipedia.org/wiki/HSL_and_HSV#Alternative_HSV_conversion
        -: 3615:// NOTE: Color->HSV->Color conversion will not yield exactly the same color due to rounding errors
        -: 3616:// Hue is provided in degrees: [0..360]
        -: 3617:// Saturation/Value are provided normalized: [0.0f..1.0f]
function ColorFromHSV called 0 returned 0% blocks executed 0%
    #####: 3618:Color ColorFromHSV(float hue, float saturation, float value)
        -: 3619:{
    #####: 3620:    Color color = { 0, 0, 0, 255 };
        -: 3621:
        -: 3622:    // Red channel
    #####: 3623:    float k = fmodf((5.0f + hue/60.0f), 6);
    #####: 3624:    float t = 4.0f - k;
    #####: 3625:    k = (t < k)? t : k;
    %%%%%: 3625-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3625-block  1
    %%%%%: 3625-block  2
    #####: 3626:    k = (k < 1)? k : 1;
    %%%%%: 3626-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3626-block  1
    %%%%%: 3626-block  2
    #####: 3627:    k = (k > 0)? k : 0;
    %%%%%: 3627-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3627-block  1
    %%%%%: 3627-block  2
    #####: 3628:    color.r = (unsigned char)((value - value*saturation*k)*255.0f);
        -: 3629:
        -: 3630:    // Green channel
    #####: 3631:    k = fmodf((3.0f + hue/60.0f), 6);
    #####: 3632:    t = 4.0f - k;
    #####: 3633:    k = (t < k)? t : k;
    %%%%%: 3633-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3633-block  1
    %%%%%: 3633-block  2
    #####: 3634:    k = (k < 1)? k : 1;
    %%%%%: 3634-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3634-block  1
    %%%%%: 3634-block  2
    #####: 3635:    k = (k > 0)? k : 0;
    %%%%%: 3635-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3635-block  1
    %%%%%: 3635-block  2
    #####: 3636:    color.g = (unsigned char)((value - value*saturation*k)*255.0f);
        -: 3637:
        -: 3638:    // Blue channel
    #####: 3639:    k = fmodf((1.0f + hue/60.0f), 6);
    #####: 3640:    t = 4.0f - k;
    #####: 3641:    k = (t < k)? t : k;
    %%%%%: 3641-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3641-block  1
    %%%%%: 3641-block  2
    #####: 3642:    k = (k < 1)? k : 1;
    %%%%%: 3642-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3642-block  1
    %%%%%: 3642-block  2
    #####: 3643:    k = (k > 0)? k : 0;
    %%%%%: 3643-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3643-block  1
    %%%%%: 3643-block  2
    #####: 3644:    color.b = (unsigned char)((value - value*saturation*k)*255.0f);
        -: 3645:
    #####: 3646:    return color;
    %%%%%: 3646-block  0
        -: 3647:}
        -: 3648:
        -: 3649:// Get color with alpha applied, alpha goes from 0.0f to 1.0f
function ColorAlpha called 0 returned 0% blocks executed 0%
    #####: 3650:Color ColorAlpha(Color color, float alpha)
        -: 3651:{
    #####: 3652:    if (alpha < 0.0f) alpha = 0.0f;
    %%%%%: 3652-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3652-block  1
    #####: 3653:    else if (alpha > 1.0f) alpha = 1.0f;
    %%%%%: 3653-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3653-block  1
        -: 3654:
    #####: 3655:    return (Color){color.r, color.g, color.b, (unsigned char)(255.0f*alpha)};
    %%%%%: 3655-block  0
        -: 3656:}
        -: 3657:
        -: 3658:// Get src alpha-blended into dst color with tint
function ColorAlphaBlend called 0 returned 0% blocks executed 0%
    #####: 3659:Color ColorAlphaBlend(Color dst, Color src, Color tint)
        -: 3660:{
    #####: 3661:    Color out = WHITE;
        -: 3662:
        -: 3663:    // Apply color tint to source color
    #####: 3664:    src.r = (unsigned char)(((unsigned int)src.r*(unsigned int)tint.r) >> 8);
    #####: 3665:    src.g = (unsigned char)(((unsigned int)src.g*(unsigned int)tint.g) >> 8);
    #####: 3666:    src.b = (unsigned char)(((unsigned int)src.b*(unsigned int)tint.b) >> 8);
    #####: 3667:    src.a = (unsigned char)(((unsigned int)src.a*(unsigned int)tint.a) >> 8);
        -: 3668:
        -: 3669://#define COLORALPHABLEND_FLOAT
        -: 3670:#define COLORALPHABLEND_INTEGERS
        -: 3671:#if defined(COLORALPHABLEND_INTEGERS)
    #####: 3672:    if (src.a == 0) out = dst;
    %%%%%: 3672-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3672-block  1
    #####: 3673:    else if (src.a == 255) out = src;
    %%%%%: 3673-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3673-block  1
        -: 3674:    else
        -: 3675:    {
    #####: 3676:        unsigned int alpha = (unsigned int)src.a + 1;     // We are shifting by 8 (dividing by 256), so we need to take that excess into account
    #####: 3677:        out.a = (unsigned char)(((unsigned int)alpha*256 + (unsigned int)dst.a*(256 - alpha)) >> 8);
        -: 3678:
    #####: 3679:        if (out.a > 0)
    %%%%%: 3679-block  0
branch  0 never executed
branch  1 never executed
        -: 3680:        {
    #####: 3681:            out.r = (unsigned char)((((unsigned int)src.r*alpha*256 + (unsigned int)dst.r*(unsigned int)dst.a*(256 - alpha))/out.a) >> 8);
    #####: 3682:            out.g = (unsigned char)((((unsigned int)src.g*alpha*256 + (unsigned int)dst.g*(unsigned int)dst.a*(256 - alpha))/out.a) >> 8);
    #####: 3683:            out.b = (unsigned char)((((unsigned int)src.b*alpha*256 + (unsigned int)dst.b*(unsigned int)dst.a*(256 - alpha))/out.a) >> 8);
    %%%%%: 3683-block  0
        -: 3684:        }
        -: 3685:    }
        -: 3686:#endif
        -: 3687:#if defined(COLORALPHABLEND_FLOAT)
        -: 3688:    if (src.a == 0) out = dst;
        -: 3689:    else if (src.a == 255) out = src;
        -: 3690:    else
        -: 3691:    {
        -: 3692:        Vector4 fdst = ColorNormalize(dst);
        -: 3693:        Vector4 fsrc = ColorNormalize(src);
        -: 3694:        Vector4 ftint = ColorNormalize(tint);
        -: 3695:        Vector4 fout = { 0 };
        -: 3696:
        -: 3697:        fout.w = fsrc.w + fdst.w*(1.0f - fsrc.w);
        -: 3698:
        -: 3699:        if (fout.w > 0.0f)
        -: 3700:        {
        -: 3701:            fout.x = (fsrc.x*fsrc.w + fdst.x*fdst.w*(1 - fsrc.w))/fout.w;
        -: 3702:            fout.y = (fsrc.y*fsrc.w + fdst.y*fdst.w*(1 - fsrc.w))/fout.w;
        -: 3703:            fout.z = (fsrc.z*fsrc.w + fdst.z*fdst.w*(1 - fsrc.w))/fout.w;
        -: 3704:        }
        -: 3705:
        -: 3706:        out = (Color){ (unsigned char)(fout.x*255.0f), (unsigned char)(fout.y*255.0f), (unsigned char)(fout.z*255.0f), (unsigned char)(fout.w*255.0f) };
        -: 3707:    }
        -: 3708:#endif
        -: 3709:
    #####: 3710:    return out;
    %%%%%: 3710-block  0
        -: 3711:}
        -: 3712:
        -: 3713:// Get a Color struct from hexadecimal value
function GetColor called 0 returned 0% blocks executed 0%
    #####: 3714:Color GetColor(unsigned int hexValue)
        -: 3715:{
        -: 3716:    Color color;
        -: 3717:
    #####: 3718:    color.r = (unsigned char)(hexValue >> 24) & 0xFF;
    #####: 3719:    color.g = (unsigned char)(hexValue >> 16) & 0xFF;
    #####: 3720:    color.b = (unsigned char)(hexValue >> 8) & 0xFF;
    #####: 3721:    color.a = (unsigned char)hexValue & 0xFF;
        -: 3722:
    #####: 3723:    return color;
    %%%%%: 3723-block  0
        -: 3724:}
        -: 3725:
        -: 3726:// Get color from a pixel from certain format
function GetPixelColor called 0 returned 0% blocks executed 0%
    #####: 3727:Color GetPixelColor(void *srcPtr, int format)
        -: 3728:{
    #####: 3729:    Color col = { 0 };
        -: 3730:
    #####: 3731:    switch (format)
    %%%%%: 3731-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 3732:    {
    #####: 3733:        case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: col = (Color){ ((unsigned char *)srcPtr)[0], ((unsigned char *)srcPtr)[0], ((unsigned char *)srcPtr)[0], 255 }; break;
    %%%%%: 3733-block  0
    #####: 3734:        case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: col = (Color){ ((unsigned char *)srcPtr)[0], ((unsigned char *)srcPtr)[0], ((unsigned char *)srcPtr)[0], ((unsigned char *)srcPtr)[1] }; break;
    %%%%%: 3734-block  0
    #####: 3735:        case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 3736:        {
    #####: 3737:            col.r = (unsigned char)((((unsigned short *)srcPtr)[0] >> 11)*255/31);
    #####: 3738:            col.g = (unsigned char)(((((unsigned short *)srcPtr)[0] >> 5) & 0b0000000000111111)*255/63);
    #####: 3739:            col.b = (unsigned char)((((unsigned short *)srcPtr)[0] & 0b0000000000011111)*255/31);
    #####: 3740:            col.a = 255;
        -: 3741:
    #####: 3742:        } break;
    %%%%%: 3742-block  0
    #####: 3743:        case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 3744:        {
    #####: 3745:            col.r = (unsigned char)((((unsigned short *)srcPtr)[0] >> 11)*255/31);
    #####: 3746:            col.g = (unsigned char)(((((unsigned short *)srcPtr)[0] >> 6) & 0b0000000000011111)*255/31);
    #####: 3747:            col.b = (unsigned char)((((unsigned short *)srcPtr)[0] & 0b0000000000011111)*255/31);
    #####: 3748:            col.a = (((unsigned short *)srcPtr)[0] & 0b0000000000000001)? 255 : 0;
    %%%%%: 3748-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3748-block  1
    %%%%%: 3748-block  2
        -: 3749:
    #####: 3750:        } break;
    %%%%%: 3750-block  0
    #####: 3751:        case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4:
        -: 3752:        {
    #####: 3753:            col.r = (unsigned char)((((unsigned short *)srcPtr)[0] >> 12)*255/15);
    #####: 3754:            col.g = (unsigned char)(((((unsigned short *)srcPtr)[0] >> 8) & 0b0000000000001111)*255/15);
    #####: 3755:            col.b = (unsigned char)(((((unsigned short *)srcPtr)[0] >> 4) & 0b0000000000001111)*255/15);
    #####: 3756:            col.a = (unsigned char)((((unsigned short *)srcPtr)[0] & 0b0000000000001111)*255/15);
        -: 3757:
    #####: 3758:        } break;
    %%%%%: 3758-block  0
    #####: 3759:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: col = (Color){ ((unsigned char *)srcPtr)[0], ((unsigned char *)srcPtr)[1], ((unsigned char *)srcPtr)[2], ((unsigned char *)srcPtr)[3] }; break;
    %%%%%: 3759-block  0
    #####: 3760:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8: col = (Color){ ((unsigned char *)srcPtr)[0], ((unsigned char *)srcPtr)[1], ((unsigned char *)srcPtr)[2], 255 }; break;
    %%%%%: 3760-block  0
        -: 3761:        // TODO: case PIXELFORMAT_UNCOMPRESSED_R32: break;
        -: 3762:        // TODO: case PIXELFORMAT_UNCOMPRESSED_R32G32B32: break;
        -: 3763:        // TODO: case PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: break;
    #####: 3764:        default: break;
    %%%%%: 3764-block  0
        -: 3765:    }
        -: 3766:
    #####: 3767:    return col;
    %%%%%: 3767-block  0
        -: 3768:}
        -: 3769:
        -: 3770:// Set pixel color formatted into destination pointer
function SetPixelColor called 0 returned 0% blocks executed 0%
    #####: 3771:void SetPixelColor(void *dstPtr, Color color, int format)
        -: 3772:{
    #####: 3773:    switch (format)
    %%%%%: 3773-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 3774:    {
    #####: 3775:        case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE:
        -: 3776:        {
        -: 3777:            // NOTE: Calculate grayscale equivalent color
    #####: 3778:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
    #####: 3779:            unsigned char gray = (unsigned char)((coln.x*0.299f + coln.y*0.587f + coln.z*0.114f)*255.0f);
        -: 3780:
    #####: 3781:            ((unsigned char *)dstPtr)[0] = gray;
        -: 3782:
    #####: 3783:        } break;
    %%%%%: 3783-block  0
    #####: 3784:        case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 3785:        {
        -: 3786:            // NOTE: Calculate grayscale equivalent color
    #####: 3787:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
    #####: 3788:            unsigned char gray = (unsigned char)((coln.x*0.299f + coln.y*0.587f + coln.z*0.114f)*255.0f);
        -: 3789:
    #####: 3790:            ((unsigned char *)dstPtr)[0] = gray;
    #####: 3791:            ((unsigned char *)dstPtr)[1] = color.a;
        -: 3792:
    #####: 3793:        } break;
    %%%%%: 3793-block  0
    #####: 3794:        case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 3795:        {
        -: 3796:            // NOTE: Calculate R5G6B5 equivalent color
    #####: 3797:            Vector3 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f };
        -: 3798:
    #####: 3799:            unsigned char r = (unsigned char)(round(coln.x*31.0f));
    #####: 3800:            unsigned char g = (unsigned char)(round(coln.y*63.0f));
    #####: 3801:            unsigned char b = (unsigned char)(round(coln.z*31.0f));
        -: 3802:
    #####: 3803:            ((unsigned short *)dstPtr)[0] = (unsigned short)r << 11 | (unsigned short)g << 5 | (unsigned short)b;
        -: 3804:
    #####: 3805:        } break;
    %%%%%: 3805-block  0
    #####: 3806:        case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 3807:        {
        -: 3808:            // NOTE: Calculate R5G5B5A1 equivalent color
    #####: 3809:            Vector4 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f, (float)color.a/255.0f };
        -: 3810:
    #####: 3811:            unsigned char r = (unsigned char)(round(coln.x*31.0f));
    #####: 3812:            unsigned char g = (unsigned char)(round(coln.y*31.0f));
    #####: 3813:            unsigned char b = (unsigned char)(round(coln.z*31.0f));
    #####: 3814:            unsigned char a = (coln.w > ((float)PIXELFORMAT_UNCOMPRESSED_R5G5B5A1_ALPHA_THRESHOLD/255.0f))? 1 : 0;
        -: 3815:
    #####: 3816:            ((unsigned short *)dstPtr)[0] = (unsigned short)r << 11 | (unsigned short)g << 6 | (unsigned short)b << 1 | (unsigned short)a;
        -: 3817:
    #####: 3818:        } break;
    %%%%%: 3818-block  0
    #####: 3819:        case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4:
        -: 3820:        {
        -: 3821:            // NOTE: Calculate R5G5B5A1 equivalent color
    #####: 3822:            Vector4 coln = { (float)color.r/255.0f, (float)color.g/255.0f, (float)color.b/255.0f, (float)color.a/255.0f };
        -: 3823:
    #####: 3824:            unsigned char r = (unsigned char)(round(coln.x*15.0f));
    #####: 3825:            unsigned char g = (unsigned char)(round(coln.y*15.0f));
    #####: 3826:            unsigned char b = (unsigned char)(round(coln.z*15.0f));
    #####: 3827:            unsigned char a = (unsigned char)(round(coln.w*15.0f));
        -: 3828:
    #####: 3829:            ((unsigned short *)dstPtr)[0] = (unsigned short)r << 12 | (unsigned short)g << 8 | (unsigned short)b << 4 | (unsigned short)a;
        -: 3830:
    #####: 3831:        } break;
    %%%%%: 3831-block  0
    #####: 3832:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8:
        -: 3833:        {
    #####: 3834:            ((unsigned char *)dstPtr)[0] = color.r;
    #####: 3835:            ((unsigned char *)dstPtr)[1] = color.g;
    #####: 3836:            ((unsigned char *)dstPtr)[2] = color.b;
        -: 3837:
    #####: 3838:        } break;
    %%%%%: 3838-block  0
    #####: 3839:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8:
        -: 3840:        {
    #####: 3841:            ((unsigned char *)dstPtr)[0] = color.r;
    #####: 3842:            ((unsigned char *)dstPtr)[1] = color.g;
    #####: 3843:            ((unsigned char *)dstPtr)[2] = color.b;
    #####: 3844:            ((unsigned char *)dstPtr)[3] = color.a;
        -: 3845:
    #####: 3846:        } break;
    %%%%%: 3846-block  0
    #####: 3847:        default: break;
    %%%%%: 3847-block  0
        -: 3848:    }
    #####: 3849:}
        -: 3850:
        -: 3851:// Get pixel data size in bytes for certain format
        -: 3852:// NOTE: Size can be requested for Image or Texture data
function GetPixelDataSize called 224 returned 100% blocks executed 36%
      224: 3853:int GetPixelDataSize(int width, int height, int format)
        -: 3854:{
      224: 3855:    int dataSize = 0;       // Size in bytes
      224: 3856:    int bpp = 0;            // Bits per pixel
        -: 3857:
      224: 3858:    switch (format)
      224: 3858-block  0
branch  0 taken 0
branch  1 taken 224
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
        -: 3859:    {
    #####: 3860:        case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: bpp = 8; break;
    %%%%%: 3860-block  0
      224: 3861:        case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 3862:        case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 3863:        case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
      224: 3864:        case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: bpp = 16; break;
      224: 3864-block  0
    #####: 3865:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: bpp = 32; break;
    %%%%%: 3865-block  0
    #####: 3866:        case PIXELFORMAT_UNCOMPRESSED_R8G8B8: bpp = 24; break;
    %%%%%: 3866-block  0
    #####: 3867:        case PIXELFORMAT_UNCOMPRESSED_R32: bpp = 32; break;
    %%%%%: 3867-block  0
    #####: 3868:        case PIXELFORMAT_UNCOMPRESSED_R32G32B32: bpp = 32*3; break;
    %%%%%: 3868-block  0
    #####: 3869:        case PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: bpp = 32*4; break;
    %%%%%: 3869-block  0
    #####: 3870:        case PIXELFORMAT_COMPRESSED_DXT1_RGB:
        -: 3871:        case PIXELFORMAT_COMPRESSED_DXT1_RGBA:
        -: 3872:        case PIXELFORMAT_COMPRESSED_ETC1_RGB:
        -: 3873:        case PIXELFORMAT_COMPRESSED_ETC2_RGB:
        -: 3874:        case PIXELFORMAT_COMPRESSED_PVRT_RGB:
    #####: 3875:        case PIXELFORMAT_COMPRESSED_PVRT_RGBA: bpp = 4; break;
    %%%%%: 3875-block  0
    #####: 3876:        case PIXELFORMAT_COMPRESSED_DXT3_RGBA:
        -: 3877:        case PIXELFORMAT_COMPRESSED_DXT5_RGBA:
        -: 3878:        case PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA:
    #####: 3879:        case PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: bpp = 8; break;
    %%%%%: 3879-block  0
    #####: 3880:        case PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: bpp = 2; break;
    %%%%%: 3880-block  0
    #####: 3881:        default: break;
    %%%%%: 3881-block  0
        -: 3882:    }
        -: 3883:
      224: 3884:    dataSize = width*height*bpp/8;  // Total data size in bytes
        -: 3885:
        -: 3886:    // Most compressed formats works on 4x4 blocks,
        -: 3887:    // if texture is smaller, minimum dataSize is 8 or 16
      224: 3888:    if ((width < 4) && (height < 4))
      224: 3888-block  0
branch  0 taken 224 (fallthrough)
branch  1 taken 0
      224: 3888-block  1
branch  2 taken 224 (fallthrough)
branch  3 taken 0
        -: 3889:    {
     224*: 3890:        if ((format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) && (format < PIXELFORMAT_COMPRESSED_DXT3_RGBA)) dataSize = 8;
      224: 3890-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 224
    %%%%%: 3890-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3890-block  2
     224*: 3891:        else if ((format >= PIXELFORMAT_COMPRESSED_DXT3_RGBA) && (format < PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA)) dataSize = 16;
      224: 3891-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 224
    %%%%%: 3891-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3891-block  2
        -: 3892:    }
        -: 3893:
      224: 3894:    return dataSize;
      224: 3894-block  0
        -: 3895:}
        -: 3896:
        -: 3897://----------------------------------------------------------------------------------
        -: 3898:// Module specific Functions Definition
        -: 3899://----------------------------------------------------------------------------------
        -: 3900:#if defined(SUPPORT_FILEFORMAT_DDS)
        -: 3901:// Loading DDS image data (compressed or uncompressed)
function LoadDDS called 0 returned 0% blocks executed 0%
    #####: 3902:static Image LoadDDS(const unsigned char *fileData, unsigned int fileSize)
        -: 3903:{
    #####: 3904:    unsigned char *fileDataPtr = (unsigned char *)fileData;
        -: 3905:
        -: 3906:    // Required extension:
        -: 3907:    // GL_EXT_texture_compression_s3tc
        -: 3908:
        -: 3909:    // Supported tokens (defined by extensions)
        -: 3910:    // GL_COMPRESSED_RGB_S3TC_DXT1_EXT      0x83F0
        -: 3911:    // GL_COMPRESSED_RGBA_S3TC_DXT1_EXT     0x83F1
        -: 3912:    // GL_COMPRESSED_RGBA_S3TC_DXT3_EXT     0x83F2
        -: 3913:    // GL_COMPRESSED_RGBA_S3TC_DXT5_EXT     0x83F3
        -: 3914:
        -: 3915:    #define FOURCC_DXT1 0x31545844  // Equivalent to "DXT1" in ASCII
        -: 3916:    #define FOURCC_DXT3 0x33545844  // Equivalent to "DXT3" in ASCII
        -: 3917:    #define FOURCC_DXT5 0x35545844  // Equivalent to "DXT5" in ASCII
        -: 3918:
        -: 3919:    // DDS Pixel Format
        -: 3920:    typedef struct {
        -: 3921:        unsigned int size;
        -: 3922:        unsigned int flags;
        -: 3923:        unsigned int fourCC;
        -: 3924:        unsigned int rgbBitCount;
        -: 3925:        unsigned int rBitMask;
        -: 3926:        unsigned int gBitMask;
        -: 3927:        unsigned int bBitMask;
        -: 3928:        unsigned int aBitMask;
        -: 3929:    } DDSPixelFormat;
        -: 3930:
        -: 3931:    // DDS Header (124 bytes)
        -: 3932:    typedef struct {
        -: 3933:        unsigned int size;
        -: 3934:        unsigned int flags;
        -: 3935:        unsigned int height;
        -: 3936:        unsigned int width;
        -: 3937:        unsigned int pitchOrLinearSize;
        -: 3938:        unsigned int depth;
        -: 3939:        unsigned int mipmapCount;
        -: 3940:        unsigned int reserved1[11];
        -: 3941:        DDSPixelFormat ddspf;
        -: 3942:        unsigned int caps;
        -: 3943:        unsigned int caps2;
        -: 3944:        unsigned int caps3;
        -: 3945:        unsigned int caps4;
        -: 3946:        unsigned int reserved2;
        -: 3947:    } DDSHeader;
        -: 3948:
    #####: 3949:    Image image = { 0 };
        -: 3950:
    #####: 3951:    if (fileDataPtr != NULL)
    %%%%%: 3951-block  0
branch  0 never executed
branch  1 never executed
        -: 3952:    {
        -: 3953:        // Verify the type of file
    #####: 3954:        unsigned char *ddsHeaderId = fileDataPtr;
    #####: 3955:        fileDataPtr += 4;
        -: 3956:
    #####: 3957:        if ((ddsHeaderId[0] != 'D') || (ddsHeaderId[1] != 'D') || (ddsHeaderId[2] != 'S') || (ddsHeaderId[3] != ' '))
    %%%%%: 3957-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3957-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3957-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 3957-block  3
branch  6 never executed
branch  7 never executed
        -: 3958:        {
    #####: 3959:            TRACELOG(LOG_WARNING, "IMAGE: DDS file data not valid");
    %%%%%: 3959-block  0
call    0 never executed
        -: 3960:        }
        -: 3961:        else
        -: 3962:        {
    #####: 3963:            DDSHeader *ddsHeader = (DDSHeader *)fileDataPtr;
        -: 3964:
        -: 3965:            TRACELOGD("IMAGE: DDS file data info:");
        -: 3966:            TRACELOGD("    > Header size:        %i", sizeof(DDSHeader));
        -: 3967:            TRACELOGD("    > Pixel format size:  %i", ddsHeader->ddspf.size);
        -: 3968:            TRACELOGD("    > Pixel format flags: 0x%x", ddsHeader->ddspf.flags);
        -: 3969:            TRACELOGD("    > File format:        0x%x", ddsHeader->ddspf.fourCC);
        -: 3970:            TRACELOGD("    > File bit count:     0x%x", ddsHeader->ddspf.rgbBitCount);
        -: 3971:
    #####: 3972:            fileDataPtr += sizeof(DDSHeader);   // Skip header
        -: 3973:
    #####: 3974:            image.width = ddsHeader->width;
    #####: 3975:            image.height = ddsHeader->height;
        -: 3976:
    #####: 3977:            if (ddsHeader->mipmapCount == 0) image.mipmaps = 1;      // Parameter not used
    %%%%%: 3977-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3977-block  1
    #####: 3978:            else image.mipmaps = ddsHeader->mipmapCount;
    %%%%%: 3978-block  0
        -: 3979:
    #####: 3980:            if (ddsHeader->ddspf.rgbBitCount == 16)     // 16bit mode, no compressed
    %%%%%: 3980-block  0
branch  0 never executed
branch  1 never executed
        -: 3981:            {
    #####: 3982:                if (ddsHeader->ddspf.flags == 0x40)         // no alpha channel
    %%%%%: 3982-block  0
branch  0 never executed
branch  1 never executed
        -: 3983:                {
    #####: 3984:                    int dataSize = image.width*image.height*sizeof(unsigned short);
    #####: 3985:                    image.data = (unsigned short *)RL_MALLOC(dataSize);
        -: 3986:
    #####: 3987:                    memcpy(image.data, fileDataPtr, dataSize);
        -: 3988:
    #####: 3989:                    image.format = PIXELFORMAT_UNCOMPRESSED_R5G6B5;
    %%%%%: 3989-block  0
        -: 3990:                }
    #####: 3991:                else if (ddsHeader->ddspf.flags == 0x41)        // with alpha channel
    %%%%%: 3991-block  0
branch  0 never executed
branch  1 never executed
        -: 3992:                {
    #####: 3993:                    if (ddsHeader->ddspf.aBitMask == 0x8000)    // 1bit alpha
    %%%%%: 3993-block  0
branch  0 never executed
branch  1 never executed
        -: 3994:                    {
    #####: 3995:                        int dataSize = image.width*image.height*sizeof(unsigned short);
    #####: 3996:                        image.data = (unsigned short *)RL_MALLOC(dataSize);
        -: 3997:
    #####: 3998:                        memcpy(image.data, fileDataPtr, dataSize);
        -: 3999:
    #####: 4000:                        unsigned char alpha = 0;
        -: 4001:
        -: 4002:                        // NOTE: Data comes as A1R5G5B5, it must be reordered to R5G5B5A1
    #####: 4003:                        for (int i = 0; i < image.width*image.height; i++)
    %%%%%: 4003-block  0
    %%%%%: 4003-block  1
branch  0 never executed
branch  1 never executed
        -: 4004:                        {
    #####: 4005:                            alpha = ((unsigned short *)image.data)[i] >> 15;
    #####: 4006:                            ((unsigned short *)image.data)[i] = ((unsigned short *)image.data)[i] << 1;
    #####: 4007:                            ((unsigned short *)image.data)[i] += alpha;
    %%%%%: 4007-block  0
        -: 4008:                        }
        -: 4009:
    #####: 4010:                        image.format = PIXELFORMAT_UNCOMPRESSED_R5G5B5A1;
    %%%%%: 4010-block  0
        -: 4011:                    }
    #####: 4012:                    else if (ddsHeader->ddspf.aBitMask == 0xf000)   // 4bit alpha
    %%%%%: 4012-block  0
branch  0 never executed
branch  1 never executed
        -: 4013:                    {
    #####: 4014:                        int dataSize = image.width*image.height*sizeof(unsigned short);
    #####: 4015:                        image.data = (unsigned short *)RL_MALLOC(dataSize);
        -: 4016:
    #####: 4017:                        memcpy(image.data, fileDataPtr, dataSize);
        -: 4018:
    #####: 4019:                        unsigned char alpha = 0;
        -: 4020:
        -: 4021:                        // NOTE: Data comes as A4R4G4B4, it must be reordered R4G4B4A4
    #####: 4022:                        for (int i = 0; i < image.width*image.height; i++)
    %%%%%: 4022-block  0
    %%%%%: 4022-block  1
branch  0 never executed
branch  1 never executed
        -: 4023:                        {
    #####: 4024:                            alpha = ((unsigned short *)image.data)[i] >> 12;
    #####: 4025:                            ((unsigned short *)image.data)[i] = ((unsigned short *)image.data)[i] << 4;
    #####: 4026:                            ((unsigned short *)image.data)[i] += alpha;
    %%%%%: 4026-block  0
        -: 4027:                        }
        -: 4028:
    #####: 4029:                        image.format = PIXELFORMAT_UNCOMPRESSED_R4G4B4A4;
    %%%%%: 4029-block  0
        -: 4030:                    }
        -: 4031:                }
        -: 4032:            }
    #####: 4033:            else if (ddsHeader->ddspf.flags == 0x40 && ddsHeader->ddspf.rgbBitCount == 24)   // DDS_RGB, no compressed
    %%%%%: 4033-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4033-block  1
branch  2 never executed
branch  3 never executed
    #####: 4034:            {
    #####: 4035:                int dataSize = image.width*image.height*3*sizeof(unsigned char);
    #####: 4036:                image.data = (unsigned short *)RL_MALLOC(dataSize);
        -: 4037:
    #####: 4038:                memcpy(image.data, fileDataPtr, dataSize);
        -: 4039:
    #####: 4040:                image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8;
    %%%%%: 4040-block  0
        -: 4041:            }
    #####: 4042:            else if (ddsHeader->ddspf.flags == 0x41 && ddsHeader->ddspf.rgbBitCount == 32) // DDS_RGBA, no compressed
    %%%%%: 4042-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4042-block  1
branch  2 never executed
branch  3 never executed
    #####: 4043:            {
    #####: 4044:                int dataSize = image.width*image.height*4*sizeof(unsigned char);
    #####: 4045:                image.data = (unsigned short *)RL_MALLOC(dataSize);
        -: 4046:
    #####: 4047:                memcpy(image.data, fileDataPtr, dataSize);
        -: 4048:
    #####: 4049:                unsigned char blue = 0;
        -: 4050:
        -: 4051:                // NOTE: Data comes as A8R8G8B8, it must be reordered R8G8B8A8 (view next comment)
        -: 4052:                // DirecX understand ARGB as a 32bit DWORD but the actual memory byte alignment is BGRA
        -: 4053:                // So, we must realign B8G8R8A8 to R8G8B8A8
    #####: 4054:                for (int i = 0; i < image.width*image.height*4; i += 4)
    %%%%%: 4054-block  0
    %%%%%: 4054-block  1
branch  0 never executed
branch  1 never executed
        -: 4055:                {
    #####: 4056:                    blue = ((unsigned char *)image.data)[i];
    #####: 4057:                    ((unsigned char *)image.data)[i] = ((unsigned char *)image.data)[i + 2];
    #####: 4058:                    ((unsigned char *)image.data)[i + 2] = blue;
    %%%%%: 4058-block  0
        -: 4059:                }
        -: 4060:
    #####: 4061:                image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
    %%%%%: 4061-block  0
        -: 4062:            }
    #####: 4063:            else if (((ddsHeader->ddspf.flags == 0x04) || (ddsHeader->ddspf.flags == 0x05)) && (ddsHeader->ddspf.fourCC > 0)) // Compressed
    %%%%%: 4063-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4063-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 4063-block  2
branch  4 never executed
branch  5 never executed
        -: 4064:            {
    #####: 4065:                int dataSize = 0;
        -: 4066:
        -: 4067:                // Calculate data size, including all mipmaps
    #####: 4068:                if (ddsHeader->mipmapCount > 1) dataSize = ddsHeader->pitchOrLinearSize*2;
    %%%%%: 4068-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4068-block  1
    #####: 4069:                else dataSize = ddsHeader->pitchOrLinearSize;
    %%%%%: 4069-block  0
        -: 4070:
    #####: 4071:                image.data = (unsigned char *)RL_MALLOC(dataSize*sizeof(unsigned char));
        -: 4072:
    #####: 4073:                memcpy(image.data, fileDataPtr, dataSize);
        -: 4074:
    #####: 4075:                switch (ddsHeader->ddspf.fourCC)
    %%%%%: 4075-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4076:                {
    #####: 4077:                    case FOURCC_DXT1:
        -: 4078:                    {
    #####: 4079:                        if (ddsHeader->ddspf.flags == 0x04) image.format = PIXELFORMAT_COMPRESSED_DXT1_RGB;
    %%%%%: 4079-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4079-block  1
    #####: 4080:                        else image.format = PIXELFORMAT_COMPRESSED_DXT1_RGBA;
    %%%%%: 4080-block  0
    #####: 4081:                    } break;
    %%%%%: 4081-block  0
    #####: 4082:                    case FOURCC_DXT3: image.format = PIXELFORMAT_COMPRESSED_DXT3_RGBA; break;
    %%%%%: 4082-block  0
    #####: 4083:                    case FOURCC_DXT5: image.format = PIXELFORMAT_COMPRESSED_DXT5_RGBA; break;
    %%%%%: 4083-block  0
    #####: 4084:                    default: break;
    %%%%%: 4084-block  0
        -: 4085:                }
    #####: 4086:            }
    %%%%%: 4086-block  0
    %%%%%: 4086-block  1
    %%%%%: 4086-block  2
        -: 4087:        }
        -: 4088:    }
        -: 4089:
    #####: 4090:    return image;
    %%%%%: 4090-block  0
        -: 4091:}
        -: 4092:#endif
        -: 4093:
        -: 4094:#if defined(SUPPORT_FILEFORMAT_PKM)
        -: 4095:// Loading PKM image data (ETC1/ETC2 compression)
        -: 4096:// NOTE: KTX is the standard Khronos Group compression format (ETC1/ETC2, mipmaps)
        -: 4097:// PKM is a much simpler file format used mainly to contain a single ETC1/ETC2 compressed image (no mipmaps)
        -: 4098:static Image LoadPKM(const unsigned char *fileData, unsigned int fileSize)
        -: 4099:{
        -: 4100:    unsigned char *fileDataPtr = (unsigned char *)fileData;
        -: 4101:
        -: 4102:    // Required extensions:
        -: 4103:    // GL_OES_compressed_ETC1_RGB8_texture  (ETC1) (OpenGL ES 2.0)
        -: 4104:    // GL_ARB_ES3_compatibility  (ETC2/EAC) (OpenGL ES 3.0)
        -: 4105:
        -: 4106:    // Supported tokens (defined by extensions)
        -: 4107:    // GL_ETC1_RGB8_OES                 0x8D64
        -: 4108:    // GL_COMPRESSED_RGB8_ETC2          0x9274
        -: 4109:    // GL_COMPRESSED_RGBA8_ETC2_EAC     0x9278
        -: 4110:
        -: 4111:    // PKM file (ETC1) Header (16 bytes)
        -: 4112:    typedef struct {
        -: 4113:        char id[4];                 // "PKM "
        -: 4114:        char version[2];            // "10" or "20"
        -: 4115:        unsigned short format;      // Data format (big-endian) (Check list below)
        -: 4116:        unsigned short width;       // Texture width (big-endian) (origWidth rounded to multiple of 4)
        -: 4117:        unsigned short height;      // Texture height (big-endian) (origHeight rounded to multiple of 4)
        -: 4118:        unsigned short origWidth;   // Original width (big-endian)
        -: 4119:        unsigned short origHeight;  // Original height (big-endian)
        -: 4120:    } PKMHeader;
        -: 4121:
        -: 4122:    // Formats list
        -: 4123:    // version 10: format: 0=ETC1_RGB, [1=ETC1_RGBA, 2=ETC1_RGB_MIP, 3=ETC1_RGBA_MIP] (not used)
        -: 4124:    // version 20: format: 0=ETC1_RGB, 1=ETC2_RGB, 2=ETC2_RGBA_OLD, 3=ETC2_RGBA, 4=ETC2_RGBA1, 5=ETC2_R, 6=ETC2_RG, 7=ETC2_SIGNED_R, 8=ETC2_SIGNED_R
        -: 4125:
        -: 4126:    // NOTE: The extended width and height are the widths rounded up to a multiple of 4.
        -: 4127:    // NOTE: ETC is always 4bit per pixel (64 bit for each 4x4 block of pixels)
        -: 4128:
        -: 4129:    Image image = { 0 };
        -: 4130:
        -: 4131:    if (fileDataPtr != NULL)
        -: 4132:    {
        -: 4133:        PKMHeader *pkmHeader = (PKMHeader *)fileDataPtr;
        -: 4134:
        -: 4135:        if ((pkmHeader->id[0] != 'P') || (pkmHeader->id[1] != 'K') || (pkmHeader->id[2] != 'M') || (pkmHeader->id[3] != ' '))
        -: 4136:        {
        -: 4137:            TRACELOG(LOG_WARNING, "IMAGE: PKM file data not valid");
        -: 4138:        }
        -: 4139:        else
        -: 4140:        {
        -: 4141:            fileDataPtr += sizeof(PKMHeader);   // Skip header
        -: 4142:
        -: 4143:            // NOTE: format, width and height come as big-endian, data must be swapped to little-endian
        -: 4144:            pkmHeader->format = ((pkmHeader->format & 0x00FF) << 8) | ((pkmHeader->format & 0xFF00) >> 8);
        -: 4145:            pkmHeader->width = ((pkmHeader->width & 0x00FF) << 8) | ((pkmHeader->width & 0xFF00) >> 8);
        -: 4146:            pkmHeader->height = ((pkmHeader->height & 0x00FF) << 8) | ((pkmHeader->height & 0xFF00) >> 8);
        -: 4147:
        -: 4148:            TRACELOGD("IMAGE: PKM file data info:");
        -: 4149:            TRACELOGD("    > Image width:  %i", pkmHeader->width);
        -: 4150:            TRACELOGD("    > Image height: %i", pkmHeader->height);
        -: 4151:            TRACELOGD("    > Image format: %i", pkmHeader->format);
        -: 4152:
        -: 4153:            image.width = pkmHeader->width;
        -: 4154:            image.height = pkmHeader->height;
        -: 4155:            image.mipmaps = 1;
        -: 4156:
        -: 4157:            int bpp = 4;
        -: 4158:            if (pkmHeader->format == 3) bpp = 8;
        -: 4159:
        -: 4160:            int dataSize = image.width*image.height*bpp/8;  // Total data size in bytes
        -: 4161:
        -: 4162:            image.data = (unsigned char *)RL_MALLOC(dataSize*sizeof(unsigned char));
        -: 4163:
        -: 4164:            memcpy(image.data, fileDataPtr, dataSize);
        -: 4165:
        -: 4166:            if (pkmHeader->format == 0) image.format = PIXELFORMAT_COMPRESSED_ETC1_RGB;
        -: 4167:            else if (pkmHeader->format == 1) image.format = PIXELFORMAT_COMPRESSED_ETC2_RGB;
        -: 4168:            else if (pkmHeader->format == 3) image.format = PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA;
        -: 4169:        }
        -: 4170:    }
        -: 4171:
        -: 4172:    return image;
        -: 4173:}
        -: 4174:#endif
        -: 4175:
        -: 4176:#if defined(SUPPORT_FILEFORMAT_KTX)
        -: 4177:// Load KTX compressed image data (ETC1/ETC2 compression)
        -: 4178:static Image LoadKTX(const unsigned char *fileData, unsigned int fileSize)
        -: 4179:{
        -: 4180:    unsigned char *fileDataPtr = (unsigned char *)fileData;
        -: 4181:
        -: 4182:    // Required extensions:
        -: 4183:    // GL_OES_compressed_ETC1_RGB8_texture  (ETC1)
        -: 4184:    // GL_ARB_ES3_compatibility  (ETC2/EAC)
        -: 4185:
        -: 4186:    // Supported tokens (defined by extensions)
        -: 4187:    // GL_ETC1_RGB8_OES                 0x8D64
        -: 4188:    // GL_COMPRESSED_RGB8_ETC2          0x9274
        -: 4189:    // GL_COMPRESSED_RGBA8_ETC2_EAC     0x9278
        -: 4190:
        -: 4191:    // KTX file Header (64 bytes)
        -: 4192:    // v1.1 - https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
        -: 4193:    // v2.0 - http://github.khronos.org/KTX-Specification/
        -: 4194:
        -: 4195:    // TODO: Support KTX 2.2 specs!
        -: 4196:
        -: 4197:    typedef struct {
        -: 4198:        char id[12];                        // Identifier: "KTX 11\r\n\x1A\n"
        -: 4199:        unsigned int endianness;            // Little endian: 0x01 0x02 0x03 0x04
        -: 4200:        unsigned int glType;                // For compressed textures, glType must equal 0
        -: 4201:        unsigned int glTypeSize;            // For compressed texture data, usually 1
        -: 4202:        unsigned int glFormat;              // For compressed textures is 0
        -: 4203:        unsigned int glInternalFormat;      // Compressed internal format
        -: 4204:        unsigned int glBaseInternalFormat;  // Same as glFormat (RGB, RGBA, ALPHA...)
        -: 4205:        unsigned int width;                 // Texture image width in pixels
        -: 4206:        unsigned int height;                // Texture image height in pixels
        -: 4207:        unsigned int depth;                 // For 2D textures is 0
        -: 4208:        unsigned int elements;              // Number of array elements, usually 0
        -: 4209:        unsigned int faces;                 // Cubemap faces, for no-cubemap = 1
        -: 4210:        unsigned int mipmapLevels;          // Non-mipmapped textures = 1
        -: 4211:        unsigned int keyValueDataSize;      // Used to encode any arbitrary data...
        -: 4212:    } KTXHeader;
        -: 4213:
        -: 4214:    // NOTE: Before start of every mipmap data block, we have: unsigned int dataSize
        -: 4215:
        -: 4216:    Image image = { 0 };
        -: 4217:
        -: 4218:    if (fileDataPtr != NULL)
        -: 4219:    {
        -: 4220:        KTXHeader *ktxHeader = (KTXHeader *)fileDataPtr;
        -: 4221:
        -: 4222:        if ((ktxHeader->id[1] != 'K') || (ktxHeader->id[2] != 'T') || (ktxHeader->id[3] != 'X') ||
        -: 4223:            (ktxHeader->id[4] != ' ') || (ktxHeader->id[5] != '1') || (ktxHeader->id[6] != '1'))
        -: 4224:        {
        -: 4225:            TRACELOG(LOG_WARNING, "IMAGE: KTX file data not valid");
        -: 4226:        }
        -: 4227:        else
        -: 4228:        {
        -: 4229:            fileDataPtr += sizeof(KTXHeader);           // Move file data pointer
        -: 4230:
        -: 4231:            image.width = ktxHeader->width;
        -: 4232:            image.height = ktxHeader->height;
        -: 4233:            image.mipmaps = ktxHeader->mipmapLevels;
        -: 4234:
        -: 4235:            TRACELOGD("IMAGE: KTX file data info:");
        -: 4236:            TRACELOGD("    > Image width:  %i", ktxHeader->width);
        -: 4237:            TRACELOGD("    > Image height: %i", ktxHeader->height);
        -: 4238:            TRACELOGD("    > Image format: 0x%x", ktxHeader->glInternalFormat);
        -: 4239:
        -: 4240:            fileDataPtr += ktxHeader->keyValueDataSize; // Skip value data size
        -: 4241:
        -: 4242:            int dataSize = ((int *)fileDataPtr)[0];
        -: 4243:            fileDataPtr += sizeof(int);
        -: 4244:
        -: 4245:            image.data = (unsigned char *)RL_MALLOC(dataSize*sizeof(unsigned char));
        -: 4246:
        -: 4247:            memcpy(image.data, fileDataPtr, dataSize);
        -: 4248:
        -: 4249:            if (ktxHeader->glInternalFormat == 0x8D64) image.format = PIXELFORMAT_COMPRESSED_ETC1_RGB;
        -: 4250:            else if (ktxHeader->glInternalFormat == 0x9274) image.format = PIXELFORMAT_COMPRESSED_ETC2_RGB;
        -: 4251:            else if (ktxHeader->glInternalFormat == 0x9278) image.format = PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA;
        -: 4252:        }
        -: 4253:    }
        -: 4254:
        -: 4255:    return image;
        -: 4256:}
        -: 4257:
        -: 4258:// Save image data as KTX file
        -: 4259:// NOTE: By default KTX 1.1 spec is used, 2.0 is still on draft (01Oct2018)
        -: 4260:static int SaveKTX(Image image, const char *fileName)
        -: 4261:{
        -: 4262:    // KTX file Header (64 bytes)
        -: 4263:    // v1.1 - https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
        -: 4264:    // v2.0 - http://github.khronos.org/KTX-Specification/ - still on draft, not ready for implementation
        -: 4265:    typedef struct {
        -: 4266:        char id[12];                        // Identifier: "KTX 11\r\n\x1A\n"             // KTX 2.0: "KTX 22\r\n\x1A\n"
        -: 4267:        unsigned int endianness;            // Little endian: 0x01 0x02 0x03 0x04
        -: 4268:        unsigned int glType;                // For compressed textures, glType must equal 0
        -: 4269:        unsigned int glTypeSize;            // For compressed texture data, usually 1
        -: 4270:        unsigned int glFormat;              // For compressed textures is 0
        -: 4271:        unsigned int glInternalFormat;      // Compressed internal format
        -: 4272:        unsigned int glBaseInternalFormat;  // Same as glFormat (RGB, RGBA, ALPHA...)       // KTX 2.0: UInt32 vkFormat
        -: 4273:        unsigned int width;                 // Texture image width in pixels
        -: 4274:        unsigned int height;                // Texture image height in pixels
        -: 4275:        unsigned int depth;                 // For 2D textures is 0
        -: 4276:        unsigned int elements;              // Number of array elements, usually 0
        -: 4277:        unsigned int faces;                 // Cubemap faces, for no-cubemap = 1
        -: 4278:        unsigned int mipmapLevels;          // Non-mipmapped textures = 1
        -: 4279:        unsigned int keyValueDataSize;      // Used to encode any arbitrary data...         // KTX 2.0: UInt32 levelOrder - ordering of the mipmap levels, usually 0
        -: 4280:                                                                                            // KTX 2.0: UInt32 supercompressionScheme - 0 (None), 1 (Crunch CRN), 2 (Zlib DEFLATE)...
        -: 4281:        // KTX 2.0 defines additional header elements...
        -: 4282:    } KTXHeader;
        -: 4283:
        -: 4284:    // Calculate file dataSize required
        -: 4285:    int dataSize = sizeof(KTXHeader);
        -: 4286:
        -: 4287:    for (int i = 0, width = image.width, height = image.height; i < image.mipmaps; i++)
        -: 4288:    {
        -: 4289:        dataSize += GetPixelDataSize(width, height, image.format);
        -: 4290:        width /= 2; height /= 2;
        -: 4291:    }
        -: 4292:
        -: 4293:    unsigned char *fileData = RL_CALLOC(dataSize, 1);
        -: 4294:    unsigned char *fileDataPtr = fileData;
        -: 4295:
        -: 4296:    KTXHeader ktxHeader = { 0 };
        -: 4297:
        -: 4298:    // KTX identifier (v1.1)
        -: 4299:    //unsigned char id[12] = { '', 'K', 'T', 'X', ' ', '1', '1', '', '\r', '\n', '\x1A', '\n' };
        -: 4300:    //unsigned char id[12] = { 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A };
        -: 4301:
        -: 4302:    const char ktxIdentifier[12] = { 0xAB, 'K', 'T', 'X', ' ', '1', '1', 0xBB, '\r', '\n', 0x1A, '\n' };
        -: 4303:
        -: 4304:    // Get the image header
        -: 4305:    memcpy(ktxHeader.id, ktxIdentifier, 12);  // KTX 1.1 signature
        -: 4306:    ktxHeader.endianness = 0;
        -: 4307:    ktxHeader.glType = 0;                     // Obtained from image.format
        -: 4308:    ktxHeader.glTypeSize = 1;
        -: 4309:    ktxHeader.glFormat = 0;                   // Obtained from image.format
        -: 4310:    ktxHeader.glInternalFormat = 0;           // Obtained from image.format
        -: 4311:    ktxHeader.glBaseInternalFormat = 0;
        -: 4312:    ktxHeader.width = image.width;
        -: 4313:    ktxHeader.height = image.height;
        -: 4314:    ktxHeader.depth = 0;
        -: 4315:    ktxHeader.elements = 0;
        -: 4316:    ktxHeader.faces = 1;
        -: 4317:    ktxHeader.mipmapLevels = image.mipmaps;   // If it was 0, it means mipmaps should be generated on loading (not for compressed formats)
        -: 4318:    ktxHeader.keyValueDataSize = 0;           // No extra data after the header
        -: 4319:
        -: 4320:    rlGetGlTextureFormats(image.format, &ktxHeader.glInternalFormat, &ktxHeader.glFormat, &ktxHeader.glType);   // rlgl module function
        -: 4321:    ktxHeader.glBaseInternalFormat = ktxHeader.glFormat;    // KTX 1.1 only
        -: 4322:
        -: 4323:    // NOTE: We can save into a .ktx all PixelFormats supported by raylib, including compressed formats like DXT, ETC or ASTC
        -: 4324:
        -: 4325:    if (ktxHeader.glFormat == -1) TRACELOG(LOG_WARNING, "IMAGE: GL format not supported for KTX export (%i)", ktxHeader.glFormat);
        -: 4326:    else
        -: 4327:    {
        -: 4328:        memcpy(fileDataPtr, &ktxHeader, sizeof(KTXHeader));
        -: 4329:        fileDataPtr += sizeof(KTXHeader);
        -: 4330:
        -: 4331:        int width = image.width;
        -: 4332:        int height = image.height;
        -: 4333:        int dataOffset = 0;
        -: 4334:
        -: 4335:        // Save all mipmaps data
        -: 4336:        for (int i = 0; i < image.mipmaps; i++)
        -: 4337:        {
        -: 4338:            unsigned int dataSize = GetPixelDataSize(width, height, image.format);
        -: 4339:
        -: 4340:            memcpy(fileDataPtr, &dataSize, sizeof(unsigned int));
        -: 4341:            memcpy(fileDataPtr + 4, (unsigned char *)image.data + dataOffset, dataSize);
        -: 4342:
        -: 4343:            width /= 2;
        -: 4344:            height /= 2;
        -: 4345:            dataOffset += dataSize;
        -: 4346:            fileDataPtr += (4 + dataSize);
        -: 4347:        }
        -: 4348:    }
        -: 4349:
        -: 4350:    int success = SaveFileData(fileName, fileData, dataSize);
        -: 4351:
        -: 4352:    RL_FREE(fileData);    // Free file data buffer
        -: 4353:
        -: 4354:    // If all data has been written correctly to file, success = 1
        -: 4355:    return success;
        -: 4356:}
        -: 4357:#endif
        -: 4358:
        -: 4359:#if defined(SUPPORT_FILEFORMAT_PVR)
        -: 4360:// Loading PVR image data (uncompressed or PVRT compression)
        -: 4361:// NOTE: PVR v2 not supported, use PVR v3 instead
        -: 4362:static Image LoadPVR(const unsigned char *fileData, unsigned int fileSize)
        -: 4363:{
        -: 4364:    unsigned char *fileDataPtr = (unsigned char *)fileData;
        -: 4365:
        -: 4366:    // Required extension:
        -: 4367:    // GL_IMG_texture_compression_pvrtc
        -: 4368:
        -: 4369:    // Supported tokens (defined by extensions)
        -: 4370:    // GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG       0x8C00
        -: 4371:    // GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG      0x8C02
        -: 4372:
        -: 4373:#if 0   // Not used...
        -: 4374:    // PVR file v2 Header (52 bytes)
        -: 4375:    typedef struct {
        -: 4376:        unsigned int headerLength;
        -: 4377:        unsigned int height;
        -: 4378:        unsigned int width;
        -: 4379:        unsigned int numMipmaps;
        -: 4380:        unsigned int flags;
        -: 4381:        unsigned int dataLength;
        -: 4382:        unsigned int bpp;
        -: 4383:        unsigned int bitmaskRed;
        -: 4384:        unsigned int bitmaskGreen;
        -: 4385:        unsigned int bitmaskBlue;
        -: 4386:        unsigned int bitmaskAlpha;
        -: 4387:        unsigned int pvrTag;
        -: 4388:        unsigned int numSurfs;
        -: 4389:    } PVRHeaderV2;
        -: 4390:#endif
        -: 4391:
        -: 4392:    // PVR file v3 Header (52 bytes)
        -: 4393:    // NOTE: After it could be metadata (15 bytes?)
        -: 4394:    typedef struct {
        -: 4395:        char id[4];
        -: 4396:        unsigned int flags;
        -: 4397:        unsigned char channels[4];      // pixelFormat high part
        -: 4398:        unsigned char channelDepth[4];  // pixelFormat low part
        -: 4399:        unsigned int colourSpace;
        -: 4400:        unsigned int channelType;
        -: 4401:        unsigned int height;
        -: 4402:        unsigned int width;
        -: 4403:        unsigned int depth;
        -: 4404:        unsigned int numSurfaces;
        -: 4405:        unsigned int numFaces;
        -: 4406:        unsigned int numMipmaps;
        -: 4407:        unsigned int metaDataSize;
        -: 4408:    } PVRHeaderV3;
        -: 4409:
        -: 4410:#if 0   // Not used...
        -: 4411:    // Metadata (usually 15 bytes)
        -: 4412:    typedef struct {
        -: 4413:        unsigned int devFOURCC;
        -: 4414:        unsigned int key;
        -: 4415:        unsigned int dataSize;      // Not used?
        -: 4416:        unsigned char *data;        // Not used?
        -: 4417:    } PVRMetadata;
        -: 4418:#endif
        -: 4419:
        -: 4420:    Image image = { 0 };
        -: 4421:
        -: 4422:    if (fileDataPtr != NULL)
        -: 4423:    {
        -: 4424:        // Check PVR image version
        -: 4425:        unsigned char pvrVersion = fileDataPtr[0];
        -: 4426:
        -: 4427:        // Load different PVR data formats
        -: 4428:        if (pvrVersion == 0x50)
        -: 4429:        {
        -: 4430:            PVRHeaderV3 *pvrHeader = (PVRHeaderV3 *)fileDataPtr;
        -: 4431:
        -: 4432:            if ((pvrHeader->id[0] != 'P') || (pvrHeader->id[1] != 'V') || (pvrHeader->id[2] != 'R') || (pvrHeader->id[3] != 3))
        -: 4433:            {
        -: 4434:                TRACELOG(LOG_WARNING, "IMAGE: PVR file data not valid");
        -: 4435:            }
        -: 4436:            else
        -: 4437:            {
        -: 4438:                fileDataPtr += sizeof(PVRHeaderV3);   // Skip header
        -: 4439:
        -: 4440:                image.width = pvrHeader->width;
        -: 4441:                image.height = pvrHeader->height;
        -: 4442:                image.mipmaps = pvrHeader->numMipmaps;
        -: 4443:
        -: 4444:                // Check data format
        -: 4445:                if (((pvrHeader->channels[0] == 'l') && (pvrHeader->channels[1] == 0)) && (pvrHeader->channelDepth[0] == 8)) image.format = PIXELFORMAT_UNCOMPRESSED_GRAYSCALE;
        -: 4446:                else if (((pvrHeader->channels[0] == 'l') && (pvrHeader->channels[1] == 'a')) && ((pvrHeader->channelDepth[0] == 8) && (pvrHeader->channelDepth[1] == 8))) image.format = PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA;
        -: 4447:                else if ((pvrHeader->channels[0] == 'r') && (pvrHeader->channels[1] == 'g') && (pvrHeader->channels[2] == 'b'))
        -: 4448:                {
        -: 4449:                    if (pvrHeader->channels[3] == 'a')
        -: 4450:                    {
        -: 4451:                        if ((pvrHeader->channelDepth[0] == 5) && (pvrHeader->channelDepth[1] == 5) && (pvrHeader->channelDepth[2] == 5) && (pvrHeader->channelDepth[3] == 1)) image.format = PIXELFORMAT_UNCOMPRESSED_R5G5B5A1;
        -: 4452:                        else if ((pvrHeader->channelDepth[0] == 4) && (pvrHeader->channelDepth[1] == 4) && (pvrHeader->channelDepth[2] == 4) && (pvrHeader->channelDepth[3] == 4)) image.format = PIXELFORMAT_UNCOMPRESSED_R4G4B4A4;
        -: 4453:                        else if ((pvrHeader->channelDepth[0] == 8) && (pvrHeader->channelDepth[1] == 8) && (pvrHeader->channelDepth[2] == 8) && (pvrHeader->channelDepth[3] == 8)) image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
        -: 4454:                    }
        -: 4455:                    else if (pvrHeader->channels[3] == 0)
        -: 4456:                    {
        -: 4457:                        if ((pvrHeader->channelDepth[0] == 5) && (pvrHeader->channelDepth[1] == 6) && (pvrHeader->channelDepth[2] == 5)) image.format = PIXELFORMAT_UNCOMPRESSED_R5G6B5;
        -: 4458:                        else if ((pvrHeader->channelDepth[0] == 8) && (pvrHeader->channelDepth[1] == 8) && (pvrHeader->channelDepth[2] == 8)) image.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8;
        -: 4459:                    }
        -: 4460:                }
        -: 4461:                else if (pvrHeader->channels[0] == 2) image.format = PIXELFORMAT_COMPRESSED_PVRT_RGB;
        -: 4462:                else if (pvrHeader->channels[0] == 3) image.format = PIXELFORMAT_COMPRESSED_PVRT_RGBA;
        -: 4463:
        -: 4464:                fileDataPtr += pvrHeader->metaDataSize;    // Skip meta data header
        -: 4465:
        -: 4466:                // Calculate data size (depends on format)
        -: 4467:                int bpp = 0;
        -: 4468:                switch (image.format)
        -: 4469:                {
        -: 4470:                    case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: bpp = 8; break;
        -: 4471:                    case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 4472:                    case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 4473:                    case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 4474:                    case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: bpp = 16; break;
        -: 4475:                    case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: bpp = 32; break;
        -: 4476:                    case PIXELFORMAT_UNCOMPRESSED_R8G8B8: bpp = 24; break;
        -: 4477:                    case PIXELFORMAT_COMPRESSED_PVRT_RGB:
        -: 4478:                    case PIXELFORMAT_COMPRESSED_PVRT_RGBA: bpp = 4; break;
        -: 4479:                    default: break;
        -: 4480:                }
        -: 4481:
        -: 4482:                int dataSize = image.width*image.height*bpp/8;  // Total data size in bytes
        -: 4483:                image.data = (unsigned char *)RL_MALLOC(dataSize*sizeof(unsigned char));
        -: 4484:
        -: 4485:                memcpy(image.data, fileDataPtr, dataSize);
        -: 4486:            }
        -: 4487:        }
        -: 4488:        else if (pvrVersion == 52) TRACELOG(LOG_INFO, "IMAGE: PVRv2 format not supported, update your files to PVRv3");
        -: 4489:    }
        -: 4490:
        -: 4491:    return image;
        -: 4492:}
        -: 4493:#endif
        -: 4494:
        -: 4495:#if defined(SUPPORT_FILEFORMAT_ASTC)
        -: 4496:// Load ASTC compressed image data (ASTC compression)
        -: 4497:static Image LoadASTC(const unsigned char *fileData, unsigned int fileSize)
        -: 4498:{
        -: 4499:    unsigned char *fileDataPtr = (unsigned char *)fileData;
        -: 4500:
        -: 4501:    // Required extensions:
        -: 4502:    // GL_KHR_texture_compression_astc_hdr
        -: 4503:    // GL_KHR_texture_compression_astc_ldr
        -: 4504:
        -: 4505:    // Supported tokens (defined by extensions)
        -: 4506:    // GL_COMPRESSED_RGBA_ASTC_4x4_KHR      0x93b0
        -: 4507:    // GL_COMPRESSED_RGBA_ASTC_8x8_KHR      0x93b7
        -: 4508:
        -: 4509:    // ASTC file Header (16 bytes)
        -: 4510:    typedef struct {
        -: 4511:        unsigned char id[4];        // Signature: 0x13 0xAB 0xA1 0x5C
        -: 4512:        unsigned char blockX;       // Block X dimensions
        -: 4513:        unsigned char blockY;       // Block Y dimensions
        -: 4514:        unsigned char blockZ;       // Block Z dimensions (1 for 2D images)
        -: 4515:        unsigned char width[3];     // Image width in pixels (24bit value)
        -: 4516:        unsigned char height[3];    // Image height in pixels (24bit value)
        -: 4517:        unsigned char length[3];    // Image Z-size (1 for 2D images)
        -: 4518:    } ASTCHeader;
        -: 4519:
        -: 4520:    Image image = { 0 };
        -: 4521:
        -: 4522:    if (fileDataPtr != NULL)
        -: 4523:    {
        -: 4524:        ASTCHeader *astcHeader = (ASTCHeader *)fileDataPtr;
        -: 4525:
        -: 4526:        if ((astcHeader->id[3] != 0x5c) || (astcHeader->id[2] != 0xa1) || (astcHeader->id[1] != 0xab) || (astcHeader->id[0] != 0x13))
        -: 4527:        {
        -: 4528:            TRACELOG(LOG_WARNING, "IMAGE: ASTC file data not valid");
        -: 4529:        }
        -: 4530:        else
        -: 4531:        {
        -: 4532:            fileDataPtr += sizeof(ASTCHeader);   // Skip header
        -: 4533:
        -: 4534:            // NOTE: Assuming Little Endian (could it be wrong?)
        -: 4535:            image.width = 0x00000000 | ((int)astcHeader->width[2] << 16) | ((int)astcHeader->width[1] << 8) | ((int)astcHeader->width[0]);
        -: 4536:            image.height = 0x00000000 | ((int)astcHeader->height[2] << 16) | ((int)astcHeader->height[1] << 8) | ((int)astcHeader->height[0]);
        -: 4537:
        -: 4538:            TRACELOGD("IMAGE: ASTC file data info:");
        -: 4539:            TRACELOGD("    > Image width:  %i", image.width);
        -: 4540:            TRACELOGD("    > Image height: %i", image.height);
        -: 4541:            TRACELOGD("    > Image blocks: %ix%i", astcHeader->blockX, astcHeader->blockY);
        -: 4542:
        -: 4543:            image.mipmaps = 1;      // NOTE: ASTC format only contains one mipmap level
        -: 4544:
        -: 4545:            // NOTE: Each block is always stored in 128bit so we can calculate the bpp
        -: 4546:            int bpp = 128/(astcHeader->blockX*astcHeader->blockY);
        -: 4547:
        -: 4548:            // NOTE: Currently we only support 2 blocks configurations: 4x4 and 8x8
        -: 4549:            if ((bpp == 8) || (bpp == 2))
        -: 4550:            {
        -: 4551:                int dataSize = image.width*image.height*bpp/8;  // Data size in bytes
        -: 4552:
        -: 4553:                image.data = (unsigned char *)RL_MALLOC(dataSize*sizeof(unsigned char));
        -: 4554:
        -: 4555:                memcpy(image.data, fileDataPtr, dataSize);
        -: 4556:
        -: 4557:                if (bpp == 8) image.format = PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA;
        -: 4558:                else if (bpp == 2) image.format = PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA;
        -: 4559:            }
        -: 4560:            else TRACELOG(LOG_WARNING, "IMAGE: ASTC block size configuration not supported");
        -: 4561:        }
        -: 4562:    }
        -: 4563:
        -: 4564:    return image;
        -: 4565:}
        -: 4566:#endif
        -: 4567:
        -: 4568:// Get pixel data from image as Vector4 array (float normalized)
function LoadImageDataNormalized called 0 returned 0% blocks executed 0%
    #####: 4569:static Vector4 *LoadImageDataNormalized(Image image)
        -: 4570:{
    #####: 4571:    Vector4 *pixels = (Vector4 *)RL_MALLOC(image.width*image.height*sizeof(Vector4));
        -: 4572:
    #####: 4573:    if (image.format >= PIXELFORMAT_COMPRESSED_DXT1_RGB) TRACELOG(LOG_WARNING, "IMAGE: Pixel data retrieval not supported for compressed image formats");
    %%%%%: 4573-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4573-block  1
call    2 never executed
        -: 4574:    else
        -: 4575:    {
    #####: 4576:        for (int i = 0, k = 0; i < image.width*image.height; i++)
    %%%%%: 4576-block  0
    %%%%%: 4576-block  1
    %%%%%: 4576-block  2
branch  0 never executed
branch  1 never executed
        -: 4577:        {
    #####: 4578:            switch (image.format)
    %%%%%: 4578-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 4579:            {
    #####: 4580:                case PIXELFORMAT_UNCOMPRESSED_GRAYSCALE:
        -: 4581:                {
    #####: 4582:                    pixels[i].x = (float)((unsigned char *)image.data)[i]/255.0f;
    #####: 4583:                    pixels[i].y = (float)((unsigned char *)image.data)[i]/255.0f;
    #####: 4584:                    pixels[i].z = (float)((unsigned char *)image.data)[i]/255.0f;
    #####: 4585:                    pixels[i].w = 1.0f;
        -: 4586:
    #####: 4587:                } break;
    %%%%%: 4587-block  0
    #####: 4588:                case PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA:
        -: 4589:                {
    #####: 4590:                    pixels[i].x = (float)((unsigned char *)image.data)[k]/255.0f;
    #####: 4591:                    pixels[i].y = (float)((unsigned char *)image.data)[k]/255.0f;
    #####: 4592:                    pixels[i].z = (float)((unsigned char *)image.data)[k]/255.0f;
    #####: 4593:                    pixels[i].w = (float)((unsigned char *)image.data)[k + 1]/255.0f;
        -: 4594:
    #####: 4595:                    k += 2;
    #####: 4596:                } break;
    %%%%%: 4596-block  0
    #####: 4597:                case PIXELFORMAT_UNCOMPRESSED_R5G5B5A1:
        -: 4598:                {
    #####: 4599:                    unsigned short pixel = ((unsigned short *)image.data)[i];
        -: 4600:
    #####: 4601:                    pixels[i].x = (float)((pixel & 0b1111100000000000) >> 11)*(1.0f/31);
    #####: 4602:                    pixels[i].y = (float)((pixel & 0b0000011111000000) >> 6)*(1.0f/31);
    #####: 4603:                    pixels[i].z = (float)((pixel & 0b0000000000111110) >> 1)*(1.0f/31);
    #####: 4604:                    pixels[i].w = ((pixel & 0b0000000000000001) == 0)? 0.0f : 1.0f;
    %%%%%: 4604-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4604-block  1
    %%%%%: 4604-block  2
        -: 4605:
    #####: 4606:                } break;
    %%%%%: 4606-block  0
    #####: 4607:                case PIXELFORMAT_UNCOMPRESSED_R5G6B5:
        -: 4608:                {
    #####: 4609:                    unsigned short pixel = ((unsigned short *)image.data)[i];
        -: 4610:
    #####: 4611:                    pixels[i].x = (float)((pixel & 0b1111100000000000) >> 11)*(1.0f/31);
    #####: 4612:                    pixels[i].y = (float)((pixel & 0b0000011111100000) >> 5)*(1.0f/63);
    #####: 4613:                    pixels[i].z = (float)(pixel & 0b0000000000011111)*(1.0f/31);
    #####: 4614:                    pixels[i].w = 1.0f;
        -: 4615:
    #####: 4616:                } break;
    %%%%%: 4616-block  0
    #####: 4617:                case PIXELFORMAT_UNCOMPRESSED_R4G4B4A4:
        -: 4618:                {
    #####: 4619:                    unsigned short pixel = ((unsigned short *)image.data)[i];
        -: 4620:
    #####: 4621:                    pixels[i].x = (float)((pixel & 0b1111000000000000) >> 12)*(1.0f/15);
    #####: 4622:                    pixels[i].y = (float)((pixel & 0b0000111100000000) >> 8)*(1.0f/15);
    #####: 4623:                    pixels[i].z = (float)((pixel & 0b0000000011110000) >> 4)*(1.0f/15);
    #####: 4624:                    pixels[i].w = (float)(pixel & 0b0000000000001111)*(1.0f/15);
        -: 4625:
    #####: 4626:                } break;
    %%%%%: 4626-block  0
    #####: 4627:                case PIXELFORMAT_UNCOMPRESSED_R8G8B8A8:
        -: 4628:                {
    #####: 4629:                    pixels[i].x = (float)((unsigned char *)image.data)[k]/255.0f;
    #####: 4630:                    pixels[i].y = (float)((unsigned char *)image.data)[k + 1]/255.0f;
    #####: 4631:                    pixels[i].z = (float)((unsigned char *)image.data)[k + 2]/255.0f;
    #####: 4632:                    pixels[i].w = (float)((unsigned char *)image.data)[k + 3]/255.0f;
        -: 4633:
    #####: 4634:                    k += 4;
    #####: 4635:                } break;
    %%%%%: 4635-block  0
    #####: 4636:                case PIXELFORMAT_UNCOMPRESSED_R8G8B8:
        -: 4637:                {
    #####: 4638:                    pixels[i].x = (float)((unsigned char *)image.data)[k]/255.0f;
    #####: 4639:                    pixels[i].y = (float)((unsigned char *)image.data)[k + 1]/255.0f;
    #####: 4640:                    pixels[i].z = (float)((unsigned char *)image.data)[k + 2]/255.0f;
    #####: 4641:                    pixels[i].w = 1.0f;
        -: 4642:
    #####: 4643:                    k += 3;
    #####: 4644:                } break;
    %%%%%: 4644-block  0
    #####: 4645:                case PIXELFORMAT_UNCOMPRESSED_R32:
        -: 4646:                {
    #####: 4647:                    pixels[i].x = ((float *)image.data)[k];
    #####: 4648:                    pixels[i].y = 0.0f;
    #####: 4649:                    pixels[i].z = 0.0f;
    #####: 4650:                    pixels[i].w = 1.0f;
        -: 4651:
    #####: 4652:                } break;
    %%%%%: 4652-block  0
    #####: 4653:                case PIXELFORMAT_UNCOMPRESSED_R32G32B32:
        -: 4654:                {
    #####: 4655:                    pixels[i].x = ((float *)image.data)[k];
    #####: 4656:                    pixels[i].y = ((float *)image.data)[k + 1];
    #####: 4657:                    pixels[i].z = ((float *)image.data)[k + 2];
    #####: 4658:                    pixels[i].w = 1.0f;
        -: 4659:
    #####: 4660:                    k += 3;
    #####: 4661:                } break;
    %%%%%: 4661-block  0
    #####: 4662:                case PIXELFORMAT_UNCOMPRESSED_R32G32B32A32:
        -: 4663:                {
    #####: 4664:                    pixels[i].x = ((float *)image.data)[k];
    #####: 4665:                    pixels[i].y = ((float *)image.data)[k + 1];
    #####: 4666:                    pixels[i].z = ((float *)image.data)[k + 2];
    #####: 4667:                    pixels[i].w = ((float *)image.data)[k + 3];
        -: 4668:
    #####: 4669:                    k += 4;
    %%%%%: 4669-block  0
        -: 4670:                }
    #####: 4671:                default: break;
    %%%%%: 4671-block  0
        -: 4672:            }
        -: 4673:        }
        -: 4674:    }
        -: 4675:
    #####: 4676:    return pixels;
    %%%%%: 4676-block  0
        -: 4677:}
