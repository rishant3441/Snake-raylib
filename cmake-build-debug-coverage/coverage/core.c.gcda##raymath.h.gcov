        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/raymath.h
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\core.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\CMakeFiles\raylib.dir\core.c.gcda
        -:    0:Runs:1
        -:    1:/**********************************************************************************************
        -:    2:*
        -:    3:*   raymath v1.3 - Math functions to work with Vector3, Matrix and Quaternions
        -:    4:*
        -:    5:*   CONFIGURATION:
        -:    6:*
        -:    7:*   #define RAYMATH_IMPLEMENTATION
        -:    8:*       Generates the implementation of the library into the included file.
        -:    9:*       If not defined, the library is in header only mode and can be included in other headers
        -:   10:*       or source files without problems. But only ONE file should hold the implementation.
        -:   11:*
        -:   12:*   #define RAYMATH_STATIC_INLINE
        -:   13:*       Define static inline functions code, so #include header suffices for use.
        -:   14:*       This may use up lots of memory.
        -:   15:*
        -:   16:*
        -:   17:*   LICENSE: zlib/libpng
        -:   18:*
        -:   19:*   Copyright (c) 2015-2021 Ramon Santamaria (@raysan5)
        -:   20:*
        -:   21:*   This software is provided "as-is", without any express or implied warranty. In no event
        -:   22:*   will the authors be held liable for any damages arising from the use of this software.
        -:   23:*
        -:   24:*   Permission is granted to anyone to use this software for any purpose, including commercial
        -:   25:*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
        -:   26:*
        -:   27:*     1. The origin of this software must not be misrepresented; you must not claim that you
        -:   28:*     wrote the original software. If you use this software in a product, an acknowledgment
        -:   29:*     in the product documentation would be appreciated but is not required.
        -:   30:*
        -:   31:*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
        -:   32:*     as being the original software.
        -:   33:*
        -:   34:*     3. This notice may not be removed or altered from any source distribution.
        -:   35:*
        -:   36:**********************************************************************************************/
        -:   37:
        -:   38:#ifndef RAYMATH_H
        -:   39:#define RAYMATH_H
        -:   40:
        -:   41:#if defined(RAYMATH_IMPLEMENTATION) && defined(RAYMATH_STATIC_INLINE)
        -:   42:    #error "Specifying both RAYMATH_IMPLEMENTATION and RAYMATH_STATIC_INLINE is contradictory"
        -:   43:#endif
        -:   44:
        -:   45:#if defined(RAYMATH_IMPLEMENTATION)
        -:   46:    #if defined(_WIN32) && defined(BUILD_LIBTYPE_SHARED)
        -:   47:        #define RMDEF __declspec(dllexport) extern inline   // We are building raylib as a Win32 shared library (.dll).
        -:   48:    #elif defined(_WIN32) && defined(USE_LIBTYPE_SHARED)
        -:   49:        #define RMDEF __declspec(dllimport)                 // We are using raylib as a Win32 shared library (.dll)
        -:   50:    #else
        -:   51:        #define RMDEF extern inline // Provide external definition
        -:   52:    #endif
        -:   53:#elif defined(RAYMATH_STATIC_INLINE)
        -:   54:    #define RMDEF static inline     // Functions may be inlined, no external out-of-line definition
        -:   55:#else
        -:   56:    #if defined(__TINYC__)
        -:   57:        #define RMDEF static inline // WARNING: Plain inline not supported by tinycc (See issue #435)
        -:   58:    #else
        -:   59:        #define RMDEF inline        // Functions may be inlined or external definition used
        -:   60:    #endif
        -:   61:#endif
        -:   62:
        -:   63://----------------------------------------------------------------------------------
        -:   64:// Defines and Macros
        -:   65://----------------------------------------------------------------------------------
        -:   66:#ifndef PI
        -:   67:    #define PI 3.14159265358979323846f
        -:   68:#endif
        -:   69:
        -:   70:#ifndef DEG2RAD
        -:   71:    #define DEG2RAD (PI/180.0f)
        -:   72:#endif
        -:   73:
        -:   74:#ifndef RAD2DEG
        -:   75:    #define RAD2DEG (180.0f/PI)
        -:   76:#endif
        -:   77:
        -:   78:// Get float vector for Matrix
        -:   79:#ifndef MatrixToFloat
        -:   80:    #define MatrixToFloat(mat) (MatrixToFloatV(mat).v)
        -:   81:#endif
        -:   82:
        -:   83:// Get float vector for Vector3
        -:   84:#ifndef Vector3ToFloat
        -:   85:    #define Vector3ToFloat(vec) (Vector3ToFloatV(vec).v)
        -:   86:#endif
        -:   87:
        -:   88://----------------------------------------------------------------------------------
        -:   89:// Types and Structures Definition
        -:   90://----------------------------------------------------------------------------------
        -:   91:
        -:   92:#if !defined(RL_VECTOR2_TYPE)
        -:   93:// Vector2 type
        -:   94:typedef struct Vector2 {
        -:   95:    float x;
        -:   96:    float y;
        -:   97:} Vector2;
        -:   98:#define RL_VECTOR2_TYPE
        -:   99:#endif
        -:  100:
        -:  101:#if !defined(RL_VECTOR3_TYPE)
        -:  102:// Vector3 type
        -:  103:typedef struct Vector3 {
        -:  104:    float x;
        -:  105:    float y;
        -:  106:    float z;
        -:  107:} Vector3;
        -:  108:#define RL_VECTOR3_TYPE
        -:  109:#endif
        -:  110:
        -:  111:#if !defined(RL_VECTOR4_TYPE)
        -:  112:// Vector4 type
        -:  113:typedef struct Vector4 {
        -:  114:    float x;
        -:  115:    float y;
        -:  116:    float z;
        -:  117:    float w;
        -:  118:} Vector4;
        -:  119:#define RL_VECTOR4_TYPE
        -:  120:#endif
        -:  121:
        -:  122:#if !defined(RL_QUATERNION_TYPE)
        -:  123:// Quaternion type
        -:  124:typedef Vector4 Quaternion;
        -:  125:#define RL_QUATERNION_TYPE
        -:  126:#endif
        -:  127:
        -:  128:#if !defined(RL_MATRIX_TYPE)
        -:  129:// Matrix type (OpenGL style 4x4 - right handed, column major)
        -:  130:typedef struct Matrix {
        -:  131:    float m0, m4, m8, m12;      // Matrix first row (4 components)
        -:  132:    float m1, m5, m9, m13;      // Matrix second row (4 components)
        -:  133:    float m2, m6, m10, m14;     // Matrix third row (4 components)
        -:  134:    float m3, m7, m11, m15;     // Matrix fourth row (4 components)
        -:  135:} Matrix;
        -:  136:#define RL_MATRIX_TYPE
        -:  137:#endif
        -:  138:
        -:  139:// NOTE: Helper types to be used instead of array return types for *ToFloat functions
        -:  140:typedef struct float3 {
        -:  141:    float v[3];
        -:  142:} float3;
        -:  143:
        -:  144:typedef struct float16 {
        -:  145:    float v[16];
        -:  146:} float16;
        -:  147:
        -:  148:#include <math.h>       // Required for: sinf(), cosf(), tan(), atan2f(), sqrtf(), fminf(), fmaxf(), fabs()
        -:  149:
        -:  150://----------------------------------------------------------------------------------
        -:  151:// Module Functions Definition - Utils math
        -:  152://----------------------------------------------------------------------------------
        -:  153:
        -:  154:// Clamp float value
function Clamp called 0 returned 0% blocks executed 0%
    #####:  155:RMDEF float Clamp(float value, float min, float max)
        -:  156:{
    #####:  157:    const float res = value < min ? min : value;
    %%%%%:  157-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  157-block  1
    %%%%%:  157-block  2
    #####:  158:    return res > max ? max : res;
    %%%%%:  158-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  158-block  1
    %%%%%:  158-block  2
    %%%%%:  158-block  3
        -:  159:}
        -:  160:
        -:  161:// Calculate linear interpolation between two floats
function Lerp called 0 returned 0% blocks executed 0%
    #####:  162:RMDEF float Lerp(float start, float end, float amount)
        -:  163:{
    #####:  164:    return start + amount*(end - start);
    %%%%%:  164-block  0
        -:  165:}
        -:  166:
        -:  167:// Normalize input value within input range
function Normalize called 0 returned 0% blocks executed 0%
    #####:  168:RMDEF float Normalize(float value, float start, float end)
        -:  169:{
    #####:  170:    return (value - start)/(end - start);
    %%%%%:  170-block  0
        -:  171:}
        -:  172:
        -:  173:// Remap input value within input range to output range
function Remap called 0 returned 0% blocks executed 0%
    #####:  174:RMDEF float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
        -:  175:{
    #####:  176:    return (value - inputStart)/(inputEnd - inputStart)*(outputEnd - outputStart) + outputStart;
    %%%%%:  176-block  0
        -:  177:}
        -:  178:
        -:  179://----------------------------------------------------------------------------------
        -:  180:// Module Functions Definition - Vector2 math
        -:  181://----------------------------------------------------------------------------------
        -:  182:
        -:  183:// Vector with components value 0.0f
function Vector2Zero called 0 returned 0% blocks executed 0%
    #####:  184:RMDEF Vector2 Vector2Zero(void)
        -:  185:{
    #####:  186:    Vector2 result = { 0.0f, 0.0f };
    #####:  187:    return result;
    %%%%%:  187-block  0
        -:  188:}
        -:  189:
        -:  190:// Vector with components value 1.0f
function Vector2One called 0 returned 0% blocks executed 0%
    #####:  191:RMDEF Vector2 Vector2One(void)
        -:  192:{
    #####:  193:    Vector2 result = { 1.0f, 1.0f };
    #####:  194:    return result;
    %%%%%:  194-block  0
        -:  195:}
        -:  196:
        -:  197:// Add two vectors (v1 + v2)
function Vector2Add called 0 returned 0% blocks executed 0%
    #####:  198:RMDEF Vector2 Vector2Add(Vector2 v1, Vector2 v2)
        -:  199:{
    #####:  200:    Vector2 result = { v1.x + v2.x, v1.y + v2.y };
    #####:  201:    return result;
    %%%%%:  201-block  0
        -:  202:}
        -:  203:
        -:  204:// Add vector and float value
function Vector2AddValue called 0 returned 0% blocks executed 0%
    #####:  205:RMDEF Vector2 Vector2AddValue(Vector2 v, float add)
        -:  206:{
    #####:  207:    Vector2 result = { v.x + add, v.y + add };
    #####:  208:    return result;
    %%%%%:  208-block  0
        -:  209:}
        -:  210:
        -:  211:// Subtract two vectors (v1 - v2)
function Vector2Subtract called 0 returned 0% blocks executed 0%
    #####:  212:RMDEF Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
        -:  213:{
    #####:  214:    Vector2 result = { v1.x - v2.x, v1.y - v2.y };
    #####:  215:    return result;
    %%%%%:  215-block  0
        -:  216:}
        -:  217:
        -:  218:// Subtract vector by float value
function Vector2SubtractValue called 0 returned 0% blocks executed 0%
    #####:  219:RMDEF Vector2 Vector2SubtractValue(Vector2 v, float sub)
        -:  220:{
    #####:  221:    Vector2 result = { v.x - sub, v.y - sub };
    #####:  222:    return result;
    %%%%%:  222-block  0
        -:  223:}
        -:  224:
        -:  225:// Calculate vector length
function Vector2Length called 0 returned 0% blocks executed 0%
    #####:  226:RMDEF float Vector2Length(Vector2 v)
        -:  227:{
    #####:  228:    float result = sqrtf((v.x*v.x) + (v.y*v.y));
    #####:  229:    return result;
    %%%%%:  229-block  0
        -:  230:}
        -:  231:
        -:  232:// Calculate vector square length
function Vector2LengthSqr called 0 returned 0% blocks executed 0%
    #####:  233:RMDEF float Vector2LengthSqr(Vector2 v)
        -:  234:{
    #####:  235:    float result = (v.x*v.x) + (v.y*v.y);
    #####:  236:    return result;
    %%%%%:  236-block  0
        -:  237:}
        -:  238:
        -:  239:// Calculate two vectors dot product
function Vector2DotProduct called 0 returned 0% blocks executed 0%
    #####:  240:RMDEF float Vector2DotProduct(Vector2 v1, Vector2 v2)
        -:  241:{
    #####:  242:    float result = (v1.x*v2.x + v1.y*v2.y);
    #####:  243:    return result;
    %%%%%:  243-block  0
        -:  244:}
        -:  245:
        -:  246:// Calculate distance between two vectors
function Vector2Distance called 2 returned 100% blocks executed 100%
        2:  247:RMDEF float Vector2Distance(Vector2 v1, Vector2 v2)
        -:  248:{
        2:  249:    float result = sqrtf((v1.x - v2.x)*(v1.x - v2.x) + (v1.y - v2.y)*(v1.y - v2.y));
        2:  250:    return result;
        2:  250-block  0
        -:  251:}
        -:  252:
        -:  253:// Calculate angle from two vectors in X-axis
function Vector2Angle called 0 returned 0% blocks executed 0%
    #####:  254:RMDEF float Vector2Angle(Vector2 v1, Vector2 v2)
        -:  255:{
    #####:  256:    float result = atan2f(v2.y - v1.y, v2.x - v1.x)*(180.0f/PI);
    #####:  257:    if (result < 0) result += 360.0f;
    %%%%%:  257-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  257-block  1
    #####:  258:    return result;
    %%%%%:  258-block  0
        -:  259:}
        -:  260:
        -:  261:// Scale vector (multiply by value)
function Vector2Scale called 0 returned 0% blocks executed 0%
    #####:  262:RMDEF Vector2 Vector2Scale(Vector2 v, float scale)
        -:  263:{
    #####:  264:    Vector2 result = { v.x*scale, v.y*scale };
    #####:  265:    return result;
    %%%%%:  265-block  0
        -:  266:}
        -:  267:
        -:  268:// Multiply vector by vector
function Vector2Multiply called 0 returned 0% blocks executed 0%
    #####:  269:RMDEF Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
        -:  270:{
    #####:  271:    Vector2 result = { v1.x*v2.x, v1.y*v2.y };
    #####:  272:    return result;
    %%%%%:  272-block  0
        -:  273:}
        -:  274:
        -:  275:// Negate vector
function Vector2Negate called 0 returned 0% blocks executed 0%
    #####:  276:RMDEF Vector2 Vector2Negate(Vector2 v)
        -:  277:{
    #####:  278:    Vector2 result = { -v.x, -v.y };
    #####:  279:    return result;
    %%%%%:  279-block  0
        -:  280:}
        -:  281:
        -:  282:// Divide vector by vector
function Vector2Divide called 0 returned 0% blocks executed 0%
    #####:  283:RMDEF Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
        -:  284:{
    #####:  285:    Vector2 result = { v1.x/v2.x, v1.y/v2.y };
    #####:  286:    return result;
    %%%%%:  286-block  0
        -:  287:}
        -:  288:
        -:  289:// Normalize provided vector
function Vector2Normalize called 0 returned 0% blocks executed 0%
    #####:  290:RMDEF Vector2 Vector2Normalize(Vector2 v)
        -:  291:{
    #####:  292:    float length = Vector2Length(v);
    %%%%%:  292-block  0
call    0 never executed
    #####:  293:    if (length <= 0)
branch  0 never executed
branch  1 never executed
    #####:  294:        return v;
    %%%%%:  294-block  0
        -:  295:
    #####:  296:    Vector2 result = Vector2Scale(v, 1/length);
    %%%%%:  296-block  0
call    0 never executed
    #####:  297:    return result;
        -:  298:}
        -:  299:
        -:  300:// Calculate linear interpolation between two vectors
function Vector2Lerp called 0 returned 0% blocks executed 0%
    #####:  301:RMDEF Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
        -:  302:{
    #####:  303:    Vector2 result = { 0 };
        -:  304:
    #####:  305:    result.x = v1.x + amount*(v2.x - v1.x);
    #####:  306:    result.y = v1.y + amount*(v2.y - v1.y);
        -:  307:
    #####:  308:    return result;
    %%%%%:  308-block  0
        -:  309:}
        -:  310:
        -:  311:// Calculate reflected vector to normal
function Vector2Reflect called 0 returned 0% blocks executed 0%
    #####:  312:RMDEF Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
        -:  313:{
    #####:  314:    Vector2 result = { 0 };
        -:  315:
    #####:  316:    float dotProduct = Vector2DotProduct(v, normal);
    %%%%%:  316-block  0
call    0 never executed
        -:  317:
    #####:  318:    result.x = v.x - (2.0f*normal.x)*dotProduct;
    #####:  319:    result.y = v.y - (2.0f*normal.y)*dotProduct;
        -:  320:
    #####:  321:    return result;
        -:  322:}
        -:  323:
        -:  324:// Rotate Vector by float in Degrees.
function Vector2Rotate called 0 returned 0% blocks executed 0%
    #####:  325:RMDEF Vector2 Vector2Rotate(Vector2 v, float degs)
        -:  326:{
    #####:  327:    float rads = degs*DEG2RAD;
    #####:  328:    Vector2 result = {v.x*cosf(rads) - v.y*sinf(rads) , v.x*sinf(rads) + v.y*cosf(rads) };
    #####:  329:    return result;
    %%%%%:  329-block  0
        -:  330:}
        -:  331:
        -:  332:// Move Vector towards target
function Vector2MoveTowards called 0 returned 0% blocks executed 0%
    #####:  333:RMDEF Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
        -:  334:{
    #####:  335:    Vector2 result = { 0 };
    #####:  336:    float dx = target.x - v.x;
    #####:  337:    float dy = target.y - v.y;
    #####:  338:    float value = (dx*dx) + (dy*dy);
        -:  339:
    #####:  340:    if ((value == 0) || ((maxDistance >= 0) && (value <= maxDistance*maxDistance))) return target;
    %%%%%:  340-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  340-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  340-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  340-block  3
        -:  341:
    #####:  342:    float dist = sqrtf(value);
        -:  343:
    #####:  344:    result.x = v.x + dx/dist*maxDistance;
    #####:  345:    result.y = v.y + dy/dist*maxDistance;
        -:  346:
    #####:  347:    return result;
    %%%%%:  347-block  0
        -:  348:}
        -:  349:
        -:  350://----------------------------------------------------------------------------------
        -:  351:// Module Functions Definition - Vector3 math
        -:  352://----------------------------------------------------------------------------------
        -:  353:
        -:  354:// Vector with components value 0.0f
function Vector3Zero called 0 returned 0% blocks executed 0%
    #####:  355:RMDEF Vector3 Vector3Zero(void)
        -:  356:{
    #####:  357:    Vector3 result = { 0.0f, 0.0f, 0.0f };
    #####:  358:    return result;
    %%%%%:  358-block  0
        -:  359:}
        -:  360:
        -:  361:// Vector with components value 1.0f
function Vector3One called 0 returned 0% blocks executed 0%
    #####:  362:RMDEF Vector3 Vector3One(void)
        -:  363:{
    #####:  364:    Vector3 result = { 1.0f, 1.0f, 1.0f };
    #####:  365:    return result;
    %%%%%:  365-block  0
        -:  366:}
        -:  367:
        -:  368:// Add two vectors
function Vector3Add called 0 returned 0% blocks executed 0%
    #####:  369:RMDEF Vector3 Vector3Add(Vector3 v1, Vector3 v2)
        -:  370:{
    #####:  371:    Vector3 result = { v1.x + v2.x, v1.y + v2.y, v1.z + v2.z };
    #####:  372:    return result;
    %%%%%:  372-block  0
        -:  373:}
        -:  374:
        -:  375:// Add vector and float value
function Vector3AddValue called 0 returned 0% blocks executed 0%
    #####:  376:RMDEF Vector3 Vector3AddValue(Vector3 v, float add)
        -:  377:{
    #####:  378:    Vector3 result = { v.x + add, v.y + add, v.z + add };
    #####:  379:    return result;
    %%%%%:  379-block  0
        -:  380:}
        -:  381:
        -:  382:// Subtract two vectors
function Vector3Subtract called 0 returned 0% blocks executed 0%
    #####:  383:RMDEF Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
        -:  384:{
    #####:  385:    Vector3 result = { v1.x - v2.x, v1.y - v2.y, v1.z - v2.z };
    #####:  386:    return result;
    %%%%%:  386-block  0
        -:  387:}
        -:  388:
        -:  389:// Subtract vector by float value
function Vector3SubtractValue called 0 returned 0% blocks executed 0%
    #####:  390:RMDEF Vector3 Vector3SubtractValue(Vector3 v, float sub)
        -:  391:{
    #####:  392:    Vector3 result = { v.x - sub, v.y - sub, v.z - sub };
    #####:  393:    return result;
    %%%%%:  393-block  0
        -:  394:}
        -:  395:
        -:  396:// Multiply vector by scalar
function Vector3Scale called 0 returned 0% blocks executed 0%
    #####:  397:RMDEF Vector3 Vector3Scale(Vector3 v, float scalar)
        -:  398:{
    #####:  399:    Vector3 result = { v.x*scalar, v.y*scalar, v.z*scalar };
    #####:  400:    return result;
    %%%%%:  400-block  0
        -:  401:}
        -:  402:
        -:  403:// Multiply vector by vector
function Vector3Multiply called 0 returned 0% blocks executed 0%
    #####:  404:RMDEF Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
        -:  405:{
    #####:  406:    Vector3 result = { v1.x*v2.x, v1.y*v2.y, v1.z*v2.z };
    #####:  407:    return result;
    %%%%%:  407-block  0
        -:  408:}
        -:  409:
        -:  410:// Calculate two vectors cross product
function Vector3CrossProduct called 0 returned 0% blocks executed 0%
    #####:  411:RMDEF Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
        -:  412:{
    #####:  413:    Vector3 result = { v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x };
    #####:  414:    return result;
    %%%%%:  414-block  0
        -:  415:}
        -:  416:
        -:  417:// Calculate one vector perpendicular vector
function Vector3Perpendicular called 0 returned 0% blocks executed 0%
    #####:  418:RMDEF Vector3 Vector3Perpendicular(Vector3 v)
        -:  419:{
    #####:  420:    Vector3 result = { 0 };
        -:  421:
    #####:  422:    float min = (float) fabs(v.x);
    #####:  423:    Vector3 cardinalAxis = {1.0f, 0.0f, 0.0f};
        -:  424:
    #####:  425:    if (fabs(v.y) < min)
    %%%%%:  425-block  0
branch  0 never executed
branch  1 never executed
        -:  426:    {
    #####:  427:        min = (float) fabs(v.y);
    #####:  428:        Vector3 tmp = {0.0f, 1.0f, 0.0f};
    #####:  429:        cardinalAxis = tmp;
    %%%%%:  429-block  0
        -:  430:    }
        -:  431:
    #####:  432:    if (fabs(v.z) < min)
    %%%%%:  432-block  0
branch  0 never executed
branch  1 never executed
        -:  433:    {
    #####:  434:        Vector3 tmp = {0.0f, 0.0f, 1.0f};
    #####:  435:        cardinalAxis = tmp;
    %%%%%:  435-block  0
        -:  436:    }
        -:  437:
    #####:  438:    result = Vector3CrossProduct(v, cardinalAxis);
    %%%%%:  438-block  0
call    0 never executed
        -:  439:
    #####:  440:    return result;
        -:  441:}
        -:  442:
        -:  443:// Calculate vector length
function Vector3Length called 0 returned 0% blocks executed 0%
    #####:  444:RMDEF float Vector3Length(const Vector3 v)
        -:  445:{
    #####:  446:    float result = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);
    #####:  447:    return result;
    %%%%%:  447-block  0
        -:  448:}
        -:  449:
        -:  450:// Calculate vector square length
function Vector3LengthSqr called 0 returned 0% blocks executed 0%
    #####:  451:RMDEF float Vector3LengthSqr(const Vector3 v)
        -:  452:{
    #####:  453:    float result = v.x*v.x + v.y*v.y + v.z*v.z;
    #####:  454:    return result;
    %%%%%:  454-block  0
        -:  455:}
        -:  456:
        -:  457:// Calculate two vectors dot product
function Vector3DotProduct called 0 returned 0% blocks executed 0%
    #####:  458:RMDEF float Vector3DotProduct(Vector3 v1, Vector3 v2)
        -:  459:{
    #####:  460:    float result = (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z);
    #####:  461:    return result;
    %%%%%:  461-block  0
        -:  462:}
        -:  463:
        -:  464:// Calculate distance between two vectors
function Vector3Distance called 0 returned 0% blocks executed 0%
    #####:  465:RMDEF float Vector3Distance(Vector3 v1, Vector3 v2)
        -:  466:{
    #####:  467:    float dx = v2.x - v1.x;
    #####:  468:    float dy = v2.y - v1.y;
    #####:  469:    float dz = v2.z - v1.z;
    #####:  470:    float result = sqrtf(dx*dx + dy*dy + dz*dz);
    #####:  471:    return result;
    %%%%%:  471-block  0
        -:  472:}
        -:  473:
        -:  474:// Negate provided vector (invert direction)
function Vector3Negate called 0 returned 0% blocks executed 0%
    #####:  475:RMDEF Vector3 Vector3Negate(Vector3 v)
        -:  476:{
    #####:  477:    Vector3 result = { -v.x, -v.y, -v.z };
    #####:  478:    return result;
    %%%%%:  478-block  0
        -:  479:}
        -:  480:
        -:  481:// Divide vector by vector
function Vector3Divide called 0 returned 0% blocks executed 0%
    #####:  482:RMDEF Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
        -:  483:{
    #####:  484:    Vector3 result = { v1.x/v2.x, v1.y/v2.y, v1.z/v2.z };
    #####:  485:    return result;
    %%%%%:  485-block  0
        -:  486:}
        -:  487:
        -:  488:// Normalize provided vector
function Vector3Normalize called 0 returned 0% blocks executed 0%
    #####:  489:RMDEF Vector3 Vector3Normalize(Vector3 v)
        -:  490:{
    #####:  491:    Vector3 result = v;
        -:  492:
        -:  493:    float length, inverseLength;
    #####:  494:    length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);
    #####:  495:    if (length == 0.0f) length = 1.0f;
    %%%%%:  495-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  495-block  1
    #####:  496:    inverseLength = 1.0f/length;
        -:  497:
    #####:  498:    result.x *= inverseLength;
    #####:  499:    result.y *= inverseLength;
    #####:  500:    result.z *= inverseLength;
        -:  501:
    #####:  502:    return result;
    %%%%%:  502-block  0
        -:  503:}
        -:  504:
        -:  505:// Orthonormalize provided vectors
        -:  506:// Makes vectors normalized and orthogonal to each other
        -:  507:// Gram-Schmidt function implementation
function Vector3OrthoNormalize called 0 returned 0% blocks executed 0%
    #####:  508:RMDEF void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
        -:  509:{
    #####:  510:    *v1 = Vector3Normalize(*v1);
    %%%%%:  510-block  0
call    0 never executed
    #####:  511:    Vector3 vn = Vector3CrossProduct(*v1, *v2);
call    0 never executed
    #####:  512:    vn = Vector3Normalize(vn);
call    0 never executed
    #####:  513:    *v2 = Vector3CrossProduct(vn, *v1);
call    0 never executed
    #####:  514:}
        -:  515:
        -:  516:// Transforms a Vector3 by a given Matrix
function Vector3Transform called 0 returned 0% blocks executed 0%
    #####:  517:RMDEF Vector3 Vector3Transform(Vector3 v, Matrix mat)
        -:  518:{
    #####:  519:    Vector3 result = { 0 };
    #####:  520:    float x = v.x;
    #####:  521:    float y = v.y;
    #####:  522:    float z = v.z;
        -:  523:
    #####:  524:    result.x = mat.m0*x + mat.m4*y + mat.m8*z + mat.m12;
    #####:  525:    result.y = mat.m1*x + mat.m5*y + mat.m9*z + mat.m13;
    #####:  526:    result.z = mat.m2*x + mat.m6*y + mat.m10*z + mat.m14;
        -:  527:
    #####:  528:    return result;
    %%%%%:  528-block  0
        -:  529:}
        -:  530:
        -:  531:// Transform a vector by quaternion rotation
function Vector3RotateByQuaternion called 0 returned 0% blocks executed 0%
    #####:  532:RMDEF Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
        -:  533:{
    #####:  534:    Vector3 result = { 0 };
        -:  535:
    #####:  536:    result.x = v.x*(q.x*q.x + q.w*q.w - q.y*q.y - q.z*q.z) + v.y*(2*q.x*q.y - 2*q.w*q.z) + v.z*(2*q.x*q.z + 2*q.w*q.y);
    #####:  537:    result.y = v.x*(2*q.w*q.z + 2*q.x*q.y) + v.y*(q.w*q.w - q.x*q.x + q.y*q.y - q.z*q.z) + v.z*(-2*q.w*q.x + 2*q.y*q.z);
    #####:  538:    result.z = v.x*(-2*q.w*q.y + 2*q.x*q.z) + v.y*(2*q.w*q.x + 2*q.y*q.z)+ v.z*(q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z);
        -:  539:
    #####:  540:    return result;
    %%%%%:  540-block  0
        -:  541:}
        -:  542:
        -:  543:// Calculate linear interpolation between two vectors
function Vector3Lerp called 0 returned 0% blocks executed 0%
    #####:  544:RMDEF Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
        -:  545:{
    #####:  546:    Vector3 result = { 0 };
        -:  547:
    #####:  548:    result.x = v1.x + amount*(v2.x - v1.x);
    #####:  549:    result.y = v1.y + amount*(v2.y - v1.y);
    #####:  550:    result.z = v1.z + amount*(v2.z - v1.z);
        -:  551:
    #####:  552:    return result;
    %%%%%:  552-block  0
        -:  553:}
        -:  554:
        -:  555:// Calculate reflected vector to normal
function Vector3Reflect called 0 returned 0% blocks executed 0%
    #####:  556:RMDEF Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
        -:  557:{
        -:  558:    // I is the original vector
        -:  559:    // N is the normal of the incident plane
        -:  560:    // R = I - (2*N*( DotProduct[ I,N] ))
        -:  561:
    #####:  562:    Vector3 result = { 0 };
        -:  563:
    #####:  564:    float dotProduct = Vector3DotProduct(v, normal);
    %%%%%:  564-block  0
call    0 never executed
        -:  565:
    #####:  566:    result.x = v.x - (2.0f*normal.x)*dotProduct;
    #####:  567:    result.y = v.y - (2.0f*normal.y)*dotProduct;
    #####:  568:    result.z = v.z - (2.0f*normal.z)*dotProduct;
        -:  569:
    #####:  570:    return result;
        -:  571:}
        -:  572:
        -:  573:// Get min value for each pair of components
function Vector3Min called 0 returned 0% blocks executed 0%
    #####:  574:RMDEF Vector3 Vector3Min(Vector3 v1, Vector3 v2)
        -:  575:{
    #####:  576:    Vector3 result = { 0 };
        -:  577:
    #####:  578:    result.x = fminf(v1.x, v2.x);
    #####:  579:    result.y = fminf(v1.y, v2.y);
    #####:  580:    result.z = fminf(v1.z, v2.z);
        -:  581:
    #####:  582:    return result;
    %%%%%:  582-block  0
        -:  583:}
        -:  584:
        -:  585:// Get max value for each pair of components
function Vector3Max called 0 returned 0% blocks executed 0%
    #####:  586:RMDEF Vector3 Vector3Max(Vector3 v1, Vector3 v2)
        -:  587:{
    #####:  588:    Vector3 result = { 0 };
        -:  589:
    #####:  590:    result.x = fmaxf(v1.x, v2.x);
    #####:  591:    result.y = fmaxf(v1.y, v2.y);
    #####:  592:    result.z = fmaxf(v1.z, v2.z);
        -:  593:
    #####:  594:    return result;
    %%%%%:  594-block  0
        -:  595:}
        -:  596:
        -:  597:// Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
        -:  598:// NOTE: Assumes P is on the plane of the triangle
function Vector3Barycenter called 0 returned 0% blocks executed 0%
    #####:  599:RMDEF Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
        -:  600:{
        -:  601:    //Vector v0 = b - a, v1 = c - a, v2 = p - a;
        -:  602:
    #####:  603:    Vector3 v0 = Vector3Subtract(b, a);
    %%%%%:  603-block  0
call    0 never executed
    #####:  604:    Vector3 v1 = Vector3Subtract(c, a);
call    0 never executed
    #####:  605:    Vector3 v2 = Vector3Subtract(p, a);
call    0 never executed
    #####:  606:    float d00 = Vector3DotProduct(v0, v0);
call    0 never executed
    #####:  607:    float d01 = Vector3DotProduct(v0, v1);
call    0 never executed
    #####:  608:    float d11 = Vector3DotProduct(v1, v1);
call    0 never executed
    #####:  609:    float d20 = Vector3DotProduct(v2, v0);
call    0 never executed
    #####:  610:    float d21 = Vector3DotProduct(v2, v1);
call    0 never executed
        -:  611:
    #####:  612:    float denom = d00*d11 - d01*d01;
        -:  613:
    #####:  614:    Vector3 result = { 0 };
        -:  615:
    #####:  616:    result.y = (d11*d20 - d01*d21)/denom;
    #####:  617:    result.z = (d00*d21 - d01*d20)/denom;
    #####:  618:    result.x = 1.0f - (result.z + result.y);
        -:  619:
    #####:  620:    return result;
        -:  621:}
        -:  622:
        -:  623:// Get Vector3 as float array
function Vector3ToFloatV called 0 returned 0% blocks executed 0%
    #####:  624:RMDEF float3 Vector3ToFloatV(Vector3 v)
        -:  625:{
    #####:  626:    float3 buffer = { 0 };
        -:  627:
    #####:  628:    buffer.v[0] = v.x;
    #####:  629:    buffer.v[1] = v.y;
    #####:  630:    buffer.v[2] = v.z;
        -:  631:
    #####:  632:    return buffer;
    %%%%%:  632-block  0
        -:  633:}
        -:  634:
        -:  635://----------------------------------------------------------------------------------
        -:  636:// Module Functions Definition - Matrix math
        -:  637://----------------------------------------------------------------------------------
        -:  638:
        -:  639:// Compute matrix determinant
function MatrixDeterminant called 0 returned 0% blocks executed 0%
    #####:  640:RMDEF float MatrixDeterminant(Matrix mat)
        -:  641:{
        -:  642:    // Cache the matrix values (speed optimization)
    #####:  643:    float a00 = mat.m0, a01 = mat.m1, a02 = mat.m2, a03 = mat.m3;
    #####:  644:    float a10 = mat.m4, a11 = mat.m5, a12 = mat.m6, a13 = mat.m7;
    #####:  645:    float a20 = mat.m8, a21 = mat.m9, a22 = mat.m10, a23 = mat.m11;
    #####:  646:    float a30 = mat.m12, a31 = mat.m13, a32 = mat.m14, a33 = mat.m15;
        -:  647:
    #####:  648:    float result = a30*a21*a12*a03 - a20*a31*a12*a03 - a30*a11*a22*a03 + a10*a31*a22*a03 +
    #####:  649:                   a20*a11*a32*a03 - a10*a21*a32*a03 - a30*a21*a02*a13 + a20*a31*a02*a13 +
    #####:  650:                   a30*a01*a22*a13 - a00*a31*a22*a13 - a20*a01*a32*a13 + a00*a21*a32*a13 +
    #####:  651:                   a30*a11*a02*a23 - a10*a31*a02*a23 - a30*a01*a12*a23 + a00*a31*a12*a23 +
    #####:  652:                   a10*a01*a32*a23 - a00*a11*a32*a23 - a20*a11*a02*a33 + a10*a21*a02*a33 +
    #####:  653:                   a20*a01*a12*a33 - a00*a21*a12*a33 - a10*a01*a22*a33 + a00*a11*a22*a33;
        -:  654:
    #####:  655:    return result;
    %%%%%:  655-block  0
        -:  656:}
        -:  657:
        -:  658:// Get the trace of the matrix (sum of the values along the diagonal)
function MatrixTrace called 0 returned 0% blocks executed 0%
    #####:  659:RMDEF float MatrixTrace(Matrix mat)
        -:  660:{
    #####:  661:    float result = (mat.m0 + mat.m5 + mat.m10 + mat.m15);
    #####:  662:    return result;
    %%%%%:  662-block  0
        -:  663:}
        -:  664:
        -:  665:// Transposes provided matrix
function MatrixTranspose called 0 returned 0% blocks executed 0%
    #####:  666:RMDEF Matrix MatrixTranspose(Matrix mat)
        -:  667:{
    #####:  668:    Matrix result = { 0 };
        -:  669:
    #####:  670:    result.m0 = mat.m0;
    #####:  671:    result.m1 = mat.m4;
    #####:  672:    result.m2 = mat.m8;
    #####:  673:    result.m3 = mat.m12;
    #####:  674:    result.m4 = mat.m1;
    #####:  675:    result.m5 = mat.m5;
    #####:  676:    result.m6 = mat.m9;
    #####:  677:    result.m7 = mat.m13;
    #####:  678:    result.m8 = mat.m2;
    #####:  679:    result.m9 = mat.m6;
    #####:  680:    result.m10 = mat.m10;
    #####:  681:    result.m11 = mat.m14;
    #####:  682:    result.m12 = mat.m3;
    #####:  683:    result.m13 = mat.m7;
    #####:  684:    result.m14 = mat.m11;
    #####:  685:    result.m15 = mat.m15;
        -:  686:
    #####:  687:    return result;
    %%%%%:  687-block  0
        -:  688:}
        -:  689:
        -:  690:// Invert provided matrix
function MatrixInvert called 0 returned 0% blocks executed 0%
    #####:  691:RMDEF Matrix MatrixInvert(Matrix mat)
        -:  692:{
    #####:  693:    Matrix result = { 0 };
        -:  694:
        -:  695:    // Cache the matrix values (speed optimization)
    #####:  696:    float a00 = mat.m0, a01 = mat.m1, a02 = mat.m2, a03 = mat.m3;
    #####:  697:    float a10 = mat.m4, a11 = mat.m5, a12 = mat.m6, a13 = mat.m7;
    #####:  698:    float a20 = mat.m8, a21 = mat.m9, a22 = mat.m10, a23 = mat.m11;
    #####:  699:    float a30 = mat.m12, a31 = mat.m13, a32 = mat.m14, a33 = mat.m15;
        -:  700:
    #####:  701:    float b00 = a00*a11 - a01*a10;
    #####:  702:    float b01 = a00*a12 - a02*a10;
    #####:  703:    float b02 = a00*a13 - a03*a10;
    #####:  704:    float b03 = a01*a12 - a02*a11;
    #####:  705:    float b04 = a01*a13 - a03*a11;
    #####:  706:    float b05 = a02*a13 - a03*a12;
    #####:  707:    float b06 = a20*a31 - a21*a30;
    #####:  708:    float b07 = a20*a32 - a22*a30;
    #####:  709:    float b08 = a20*a33 - a23*a30;
    #####:  710:    float b09 = a21*a32 - a22*a31;
    #####:  711:    float b10 = a21*a33 - a23*a31;
    #####:  712:    float b11 = a22*a33 - a23*a32;
        -:  713:
        -:  714:    // Calculate the invert determinant (inlined to avoid double-caching)
    #####:  715:    float invDet = 1.0f/(b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06);
        -:  716:
    #####:  717:    result.m0 = (a11*b11 - a12*b10 + a13*b09)*invDet;
    #####:  718:    result.m1 = (-a01*b11 + a02*b10 - a03*b09)*invDet;
    #####:  719:    result.m2 = (a31*b05 - a32*b04 + a33*b03)*invDet;
    #####:  720:    result.m3 = (-a21*b05 + a22*b04 - a23*b03)*invDet;
    #####:  721:    result.m4 = (-a10*b11 + a12*b08 - a13*b07)*invDet;
    #####:  722:    result.m5 = (a00*b11 - a02*b08 + a03*b07)*invDet;
    #####:  723:    result.m6 = (-a30*b05 + a32*b02 - a33*b01)*invDet;
    #####:  724:    result.m7 = (a20*b05 - a22*b02 + a23*b01)*invDet;
    #####:  725:    result.m8 = (a10*b10 - a11*b08 + a13*b06)*invDet;
    #####:  726:    result.m9 = (-a00*b10 + a01*b08 - a03*b06)*invDet;
    #####:  727:    result.m10 = (a30*b04 - a31*b02 + a33*b00)*invDet;
    #####:  728:    result.m11 = (-a20*b04 + a21*b02 - a23*b00)*invDet;
    #####:  729:    result.m12 = (-a10*b09 + a11*b07 - a12*b06)*invDet;
    #####:  730:    result.m13 = (a00*b09 - a01*b07 + a02*b06)*invDet;
    #####:  731:    result.m14 = (-a30*b03 + a31*b01 - a32*b00)*invDet;
    #####:  732:    result.m15 = (a20*b03 - a21*b01 + a22*b00)*invDet;
        -:  733:
    #####:  734:    return result;
    %%%%%:  734-block  0
        -:  735:}
        -:  736:
        -:  737:// Normalize provided matrix
function MatrixNormalize called 0 returned 0% blocks executed 0%
    #####:  738:RMDEF Matrix MatrixNormalize(Matrix mat)
        -:  739:{
    #####:  740:    Matrix result = { 0 };
        -:  741:
    #####:  742:    float det = MatrixDeterminant(mat);
    %%%%%:  742-block  0
call    0 never executed
        -:  743:
    #####:  744:    result.m0 = mat.m0/det;
    #####:  745:    result.m1 = mat.m1/det;
    #####:  746:    result.m2 = mat.m2/det;
    #####:  747:    result.m3 = mat.m3/det;
    #####:  748:    result.m4 = mat.m4/det;
    #####:  749:    result.m5 = mat.m5/det;
    #####:  750:    result.m6 = mat.m6/det;
    #####:  751:    result.m7 = mat.m7/det;
    #####:  752:    result.m8 = mat.m8/det;
    #####:  753:    result.m9 = mat.m9/det;
    #####:  754:    result.m10 = mat.m10/det;
    #####:  755:    result.m11 = mat.m11/det;
    #####:  756:    result.m12 = mat.m12/det;
    #####:  757:    result.m13 = mat.m13/det;
    #####:  758:    result.m14 = mat.m14/det;
    #####:  759:    result.m15 = mat.m15/det;
        -:  760:
    #####:  761:    return result;
        -:  762:}
        -:  763:
        -:  764:// Get identity matrix
function MatrixIdentity called 1 returned 100% blocks executed 100%
        1:  765:RMDEF Matrix MatrixIdentity(void)
        -:  766:{
        1:  767:    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
        -:  768:                      0.0f, 1.0f, 0.0f, 0.0f,
        -:  769:                      0.0f, 0.0f, 1.0f, 0.0f,
        -:  770:                      0.0f, 0.0f, 0.0f, 1.0f };
        -:  771:
        1:  772:    return result;
        1:  772-block  0
        -:  773:}
        -:  774:
        -:  775:// Add two matrices
function MatrixAdd called 0 returned 0% blocks executed 0%
    #####:  776:RMDEF Matrix MatrixAdd(Matrix left, Matrix right)
        -:  777:{
    #####:  778:    Matrix result = MatrixIdentity();
    %%%%%:  778-block  0
call    0 never executed
        -:  779:
    #####:  780:    result.m0 = left.m0 + right.m0;
    #####:  781:    result.m1 = left.m1 + right.m1;
    #####:  782:    result.m2 = left.m2 + right.m2;
    #####:  783:    result.m3 = left.m3 + right.m3;
    #####:  784:    result.m4 = left.m4 + right.m4;
    #####:  785:    result.m5 = left.m5 + right.m5;
    #####:  786:    result.m6 = left.m6 + right.m6;
    #####:  787:    result.m7 = left.m7 + right.m7;
    #####:  788:    result.m8 = left.m8 + right.m8;
    #####:  789:    result.m9 = left.m9 + right.m9;
    #####:  790:    result.m10 = left.m10 + right.m10;
    #####:  791:    result.m11 = left.m11 + right.m11;
    #####:  792:    result.m12 = left.m12 + right.m12;
    #####:  793:    result.m13 = left.m13 + right.m13;
    #####:  794:    result.m14 = left.m14 + right.m14;
    #####:  795:    result.m15 = left.m15 + right.m15;
        -:  796:
    #####:  797:    return result;
        -:  798:}
        -:  799:
        -:  800:// Subtract two matrices (left - right)
function MatrixSubtract called 0 returned 0% blocks executed 0%
    #####:  801:RMDEF Matrix MatrixSubtract(Matrix left, Matrix right)
        -:  802:{
    #####:  803:    Matrix result = MatrixIdentity();
    %%%%%:  803-block  0
call    0 never executed
        -:  804:
    #####:  805:    result.m0 = left.m0 - right.m0;
    #####:  806:    result.m1 = left.m1 - right.m1;
    #####:  807:    result.m2 = left.m2 - right.m2;
    #####:  808:    result.m3 = left.m3 - right.m3;
    #####:  809:    result.m4 = left.m4 - right.m4;
    #####:  810:    result.m5 = left.m5 - right.m5;
    #####:  811:    result.m6 = left.m6 - right.m6;
    #####:  812:    result.m7 = left.m7 - right.m7;
    #####:  813:    result.m8 = left.m8 - right.m8;
    #####:  814:    result.m9 = left.m9 - right.m9;
    #####:  815:    result.m10 = left.m10 - right.m10;
    #####:  816:    result.m11 = left.m11 - right.m11;
    #####:  817:    result.m12 = left.m12 - right.m12;
    #####:  818:    result.m13 = left.m13 - right.m13;
    #####:  819:    result.m14 = left.m14 - right.m14;
    #####:  820:    result.m15 = left.m15 - right.m15;
        -:  821:
    #####:  822:    return result;
        -:  823:}
        -:  824:
        -:  825:// Get two matrix multiplication
        -:  826:// NOTE: When multiplying matrices... the order matters!
function MatrixMultiply called 0 returned 0% blocks executed 0%
    #####:  827:RMDEF Matrix MatrixMultiply(Matrix left, Matrix right)
        -:  828:{
    #####:  829:    Matrix result = { 0 };
        -:  830:
    #####:  831:    result.m0 = left.m0*right.m0 + left.m1*right.m4 + left.m2*right.m8 + left.m3*right.m12;
    #####:  832:    result.m1 = left.m0*right.m1 + left.m1*right.m5 + left.m2*right.m9 + left.m3*right.m13;
    #####:  833:    result.m2 = left.m0*right.m2 + left.m1*right.m6 + left.m2*right.m10 + left.m3*right.m14;
    #####:  834:    result.m3 = left.m0*right.m3 + left.m1*right.m7 + left.m2*right.m11 + left.m3*right.m15;
    #####:  835:    result.m4 = left.m4*right.m0 + left.m5*right.m4 + left.m6*right.m8 + left.m7*right.m12;
    #####:  836:    result.m5 = left.m4*right.m1 + left.m5*right.m5 + left.m6*right.m9 + left.m7*right.m13;
    #####:  837:    result.m6 = left.m4*right.m2 + left.m5*right.m6 + left.m6*right.m10 + left.m7*right.m14;
    #####:  838:    result.m7 = left.m4*right.m3 + left.m5*right.m7 + left.m6*right.m11 + left.m7*right.m15;
    #####:  839:    result.m8 = left.m8*right.m0 + left.m9*right.m4 + left.m10*right.m8 + left.m11*right.m12;
    #####:  840:    result.m9 = left.m8*right.m1 + left.m9*right.m5 + left.m10*right.m9 + left.m11*right.m13;
    #####:  841:    result.m10 = left.m8*right.m2 + left.m9*right.m6 + left.m10*right.m10 + left.m11*right.m14;
    #####:  842:    result.m11 = left.m8*right.m3 + left.m9*right.m7 + left.m10*right.m11 + left.m11*right.m15;
    #####:  843:    result.m12 = left.m12*right.m0 + left.m13*right.m4 + left.m14*right.m8 + left.m15*right.m12;
    #####:  844:    result.m13 = left.m12*right.m1 + left.m13*right.m5 + left.m14*right.m9 + left.m15*right.m13;
    #####:  845:    result.m14 = left.m12*right.m2 + left.m13*right.m6 + left.m14*right.m10 + left.m15*right.m14;
    #####:  846:    result.m15 = left.m12*right.m3 + left.m13*right.m7 + left.m14*right.m11 + left.m15*right.m15;
        -:  847:
    #####:  848:    return result;
    %%%%%:  848-block  0
        -:  849:}
        -:  850:
        -:  851:// Get translation matrix
function MatrixTranslate called 0 returned 0% blocks executed 0%
    #####:  852:RMDEF Matrix MatrixTranslate(float x, float y, float z)
        -:  853:{
    #####:  854:    Matrix result = { 1.0f, 0.0f, 0.0f, x,
        -:  855:                      0.0f, 1.0f, 0.0f, y,
        -:  856:                      0.0f, 0.0f, 1.0f, z,
        -:  857:                      0.0f, 0.0f, 0.0f, 1.0f };
        -:  858:
    #####:  859:    return result;
    %%%%%:  859-block  0
        -:  860:}
        -:  861:
        -:  862:// Create rotation matrix from axis and angle
        -:  863:// NOTE: Angle should be provided in radians
function MatrixRotate called 0 returned 0% blocks executed 0%
    #####:  864:RMDEF Matrix MatrixRotate(Vector3 axis, float angle)
        -:  865:{
    #####:  866:    Matrix result = { 0 };
        -:  867:
    #####:  868:    float x = axis.x, y = axis.y, z = axis.z;
        -:  869:
    #####:  870:    float lengthSquared = x*x + y*y + z*z;
        -:  871:
    #####:  872:    if ((lengthSquared != 1.0f) && (lengthSquared != 0.0f))
    %%%%%:  872-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  872-block  1
branch  2 never executed
branch  3 never executed
        -:  873:    {
    #####:  874:        float inverseLength = 1.0f/sqrtf(lengthSquared);
    #####:  875:        x *= inverseLength;
    #####:  876:        y *= inverseLength;
    #####:  877:        z *= inverseLength;
    %%%%%:  877-block  0
        -:  878:    }
        -:  879:
    #####:  880:    float sinres = sinf(angle);
    #####:  881:    float cosres = cosf(angle);
    #####:  882:    float t = 1.0f - cosres;
        -:  883:
    #####:  884:    result.m0 = x*x*t + cosres;
    #####:  885:    result.m1 = y*x*t + z*sinres;
    #####:  886:    result.m2 = z*x*t - y*sinres;
    #####:  887:    result.m3 = 0.0f;
        -:  888:
    #####:  889:    result.m4 = x*y*t - z*sinres;
    #####:  890:    result.m5 = y*y*t + cosres;
    #####:  891:    result.m6 = z*y*t + x*sinres;
    #####:  892:    result.m7 = 0.0f;
        -:  893:
    #####:  894:    result.m8 = x*z*t + y*sinres;
    #####:  895:    result.m9 = y*z*t - x*sinres;
    #####:  896:    result.m10 = z*z*t + cosres;
    #####:  897:    result.m11 = 0.0f;
        -:  898:
    #####:  899:    result.m12 = 0.0f;
    #####:  900:    result.m13 = 0.0f;
    #####:  901:    result.m14 = 0.0f;
    #####:  902:    result.m15 = 1.0f;
        -:  903:
    #####:  904:    return result;
    %%%%%:  904-block  0
        -:  905:}
        -:  906:
        -:  907:// Get x-rotation matrix (angle in radians)
function MatrixRotateX called 0 returned 0% blocks executed 0%
    #####:  908:RMDEF Matrix MatrixRotateX(float angle)
        -:  909:{
    #####:  910:    Matrix result = MatrixIdentity();
    %%%%%:  910-block  0
call    0 never executed
        -:  911:
    #####:  912:    float cosres = cosf(angle);
    #####:  913:    float sinres = sinf(angle);
        -:  914:
    #####:  915:    result.m5 = cosres;
    #####:  916:    result.m6 = -sinres;
    #####:  917:    result.m9 = sinres;
    #####:  918:    result.m10 = cosres;
        -:  919:
    #####:  920:    return result;
        -:  921:}
        -:  922:
        -:  923:// Get y-rotation matrix (angle in radians)
function MatrixRotateY called 0 returned 0% blocks executed 0%
    #####:  924:RMDEF Matrix MatrixRotateY(float angle)
        -:  925:{
    #####:  926:    Matrix result = MatrixIdentity();
    %%%%%:  926-block  0
call    0 never executed
        -:  927:
    #####:  928:    float cosres = cosf(angle);
    #####:  929:    float sinres = sinf(angle);
        -:  930:
    #####:  931:    result.m0 = cosres;
    #####:  932:    result.m2 = sinres;
    #####:  933:    result.m8 = -sinres;
    #####:  934:    result.m10 = cosres;
        -:  935:
    #####:  936:    return result;
        -:  937:}
        -:  938:
        -:  939:// Get z-rotation matrix (angle in radians)
function MatrixRotateZ called 0 returned 0% blocks executed 0%
    #####:  940:RMDEF Matrix MatrixRotateZ(float angle)
        -:  941:{
    #####:  942:    Matrix result = MatrixIdentity();
    %%%%%:  942-block  0
call    0 never executed
        -:  943:
    #####:  944:    float cosres = cosf(angle);
    #####:  945:    float sinres = sinf(angle);
        -:  946:
    #####:  947:    result.m0 = cosres;
    #####:  948:    result.m1 = -sinres;
    #####:  949:    result.m4 = sinres;
    #####:  950:    result.m5 = cosres;
        -:  951:
    #####:  952:    return result;
        -:  953:}
        -:  954:
        -:  955:
        -:  956:// Get xyz-rotation matrix (angles in radians)
function MatrixRotateXYZ called 0 returned 0% blocks executed 0%
    #####:  957:RMDEF Matrix MatrixRotateXYZ(Vector3 ang)
        -:  958:{
    #####:  959:    Matrix result = MatrixIdentity();
    %%%%%:  959-block  0
call    0 never executed
        -:  960:
    #####:  961:    float cosz = cosf(-ang.z);
    #####:  962:    float sinz = sinf(-ang.z);
    #####:  963:    float cosy = cosf(-ang.y);
    #####:  964:    float siny = sinf(-ang.y);
    #####:  965:    float cosx = cosf(-ang.x);
    #####:  966:    float sinx = sinf(-ang.x);
        -:  967:
    #####:  968:    result.m0 = cosz*cosy;
    #####:  969:    result.m4 = (cosz*siny*sinx) - (sinz*cosx);
    #####:  970:    result.m8 = (cosz*siny*cosx) + (sinz*sinx);
        -:  971:
    #####:  972:    result.m1 = sinz*cosy;
    #####:  973:    result.m5 = (sinz*siny*sinx) + (cosz*cosx);
    #####:  974:    result.m9 = (sinz*siny*cosx) - (cosz*sinx);
        -:  975:
    #####:  976:    result.m2 = -siny;
    #####:  977:    result.m6 = cosy*sinx;
    #####:  978:    result.m10= cosy*cosx;
        -:  979:
    #####:  980:    return result;
        -:  981:}
        -:  982:
        -:  983:// Get zyx-rotation matrix (angles in radians)
function MatrixRotateZYX called 0 returned 0% blocks executed 0%
    #####:  984:RMDEF Matrix MatrixRotateZYX(Vector3 ang)
        -:  985:{
    #####:  986:    Matrix result = { 0 };
        -:  987:
    #####:  988:    float cz = cosf(ang.z);
    #####:  989:    float sz = sinf(ang.z);
    #####:  990:    float cy = cosf(ang.y);
    #####:  991:    float sy = sinf(ang.y);
    #####:  992:    float cx = cosf(ang.x);
    #####:  993:    float sx = sinf(ang.x);
        -:  994:
    #####:  995:    result.m0 = cz*cy;
    #####:  996:    result.m1 = cz*sy*sx - cx*sz;
    #####:  997:    result.m2 = sz*sx + cz*cx*sy;
    #####:  998:    result.m3 = 0;
        -:  999:
    #####: 1000:    result.m4 = cy*sz;
    #####: 1001:    result.m5 = cz*cx + sz*sy*sx;
    #####: 1002:    result.m6 = cx*sz*sy - cz*sx;
    #####: 1003:    result.m7 = 0;
        -: 1004:
    #####: 1005:    result.m8 = -sy;
    #####: 1006:    result.m9 = cy*sx;
    #####: 1007:    result.m10 = cy*cx;
    #####: 1008:    result.m11 = 0;
        -: 1009:
    #####: 1010:    result.m12 = 0;
    #####: 1011:    result.m13 = 0;
    #####: 1012:    result.m14 = 0;
    #####: 1013:    result.m15 = 1;
        -: 1014:
    #####: 1015:    return result;
    %%%%%: 1015-block  0
        -: 1016:}
        -: 1017:
        -: 1018:// Get scaling matrix
function MatrixScale called 0 returned 0% blocks executed 0%
    #####: 1019:RMDEF Matrix MatrixScale(float x, float y, float z)
        -: 1020:{
    #####: 1021:    Matrix result = { x, 0.0f, 0.0f, 0.0f,
        -: 1022:                      0.0f, y, 0.0f, 0.0f,
        -: 1023:                      0.0f, 0.0f, z, 0.0f,
        -: 1024:                      0.0f, 0.0f, 0.0f, 1.0f };
        -: 1025:
    #####: 1026:    return result;
    %%%%%: 1026-block  0
        -: 1027:}
        -: 1028:
        -: 1029:// Get perspective projection matrix
function MatrixFrustum called 0 returned 0% blocks executed 0%
    #####: 1030:RMDEF Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
        -: 1031:{
    #####: 1032:    Matrix result = { 0 };
        -: 1033:
    #####: 1034:    float rl = (float)(right - left);
    #####: 1035:    float tb = (float)(top - bottom);
    #####: 1036:    float fn = (float)(far - near);
        -: 1037:
    #####: 1038:    result.m0 = ((float) near*2.0f)/rl;
    #####: 1039:    result.m1 = 0.0f;
    #####: 1040:    result.m2 = 0.0f;
    #####: 1041:    result.m3 = 0.0f;
        -: 1042:
    #####: 1043:    result.m4 = 0.0f;
    #####: 1044:    result.m5 = ((float) near*2.0f)/tb;
    #####: 1045:    result.m6 = 0.0f;
    #####: 1046:    result.m7 = 0.0f;
        -: 1047:
    #####: 1048:    result.m8 = ((float)right + (float)left)/rl;
    #####: 1049:    result.m9 = ((float)top + (float)bottom)/tb;
    #####: 1050:    result.m10 = -((float)far + (float)near)/fn;
    #####: 1051:    result.m11 = -1.0f;
        -: 1052:
    #####: 1053:    result.m12 = 0.0f;
    #####: 1054:    result.m13 = 0.0f;
    #####: 1055:    result.m14 = -((float)far*(float)near*2.0f)/fn;
    #####: 1056:    result.m15 = 0.0f;
        -: 1057:
    #####: 1058:    return result;
    %%%%%: 1058-block  0
        -: 1059:}
        -: 1060:
        -: 1061:// Get perspective projection matrix
        -: 1062:// NOTE: Angle should be provided in radians
function MatrixPerspective called 0 returned 0% blocks executed 0%
    #####: 1063:RMDEF Matrix MatrixPerspective(double fovy, double aspect, double near, double far)
        -: 1064:{
    #####: 1065:    double top = near*tan(fovy*0.5);
    #####: 1066:    double right = top*aspect;
    #####: 1067:    Matrix result = MatrixFrustum(-right, right, -top, top, near, far);
    %%%%%: 1067-block  0
call    0 never executed
        -: 1068:
    #####: 1069:    return result;
        -: 1070:}
        -: 1071:
        -: 1072:// Get orthographic projection matrix
function MatrixOrtho called 0 returned 0% blocks executed 0%
    #####: 1073:RMDEF Matrix MatrixOrtho(double left, double right, double bottom, double top, double near, double far)
        -: 1074:{
    #####: 1075:    Matrix result = { 0 };
        -: 1076:
    #####: 1077:    float rl = (float)(right - left);
    #####: 1078:    float tb = (float)(top - bottom);
    #####: 1079:    float fn = (float)(far - near);
        -: 1080:
    #####: 1081:    result.m0 = 2.0f/rl;
    #####: 1082:    result.m1 = 0.0f;
    #####: 1083:    result.m2 = 0.0f;
    #####: 1084:    result.m3 = 0.0f;
    #####: 1085:    result.m4 = 0.0f;
    #####: 1086:    result.m5 = 2.0f/tb;
    #####: 1087:    result.m6 = 0.0f;
    #####: 1088:    result.m7 = 0.0f;
    #####: 1089:    result.m8 = 0.0f;
    #####: 1090:    result.m9 = 0.0f;
    #####: 1091:    result.m10 = -2.0f/fn;
    #####: 1092:    result.m11 = 0.0f;
    #####: 1093:    result.m12 = -((float)left + (float)right)/rl;
    #####: 1094:    result.m13 = -((float)top + (float)bottom)/tb;
    #####: 1095:    result.m14 = -((float)far + (float)near)/fn;
    #####: 1096:    result.m15 = 1.0f;
        -: 1097:
    #####: 1098:    return result;
    %%%%%: 1098-block  0
        -: 1099:}
        -: 1100:
        -: 1101:// Get camera look-at matrix (view matrix)
function MatrixLookAt called 0 returned 0% blocks executed 0%
    #####: 1102:RMDEF Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
        -: 1103:{
    #####: 1104:    Matrix result = { 0 };
        -: 1105:
    #####: 1106:    Vector3 z = Vector3Subtract(eye, target);
    %%%%%: 1106-block  0
call    0 never executed
    #####: 1107:    z = Vector3Normalize(z);
call    0 never executed
    #####: 1108:    Vector3 x = Vector3CrossProduct(up, z);
call    0 never executed
    #####: 1109:    x = Vector3Normalize(x);
call    0 never executed
    #####: 1110:    Vector3 y = Vector3CrossProduct(z, x);
call    0 never executed
        -: 1111:
    #####: 1112:    result.m0 = x.x;
    #####: 1113:    result.m1 = y.x;
    #####: 1114:    result.m2 = z.x;
    #####: 1115:    result.m3 = 0.0f;
    #####: 1116:    result.m4 = x.y;
    #####: 1117:    result.m5 = y.y;
    #####: 1118:    result.m6 = z.y;
    #####: 1119:    result.m7 = 0.0f;
    #####: 1120:    result.m8 = x.z;
    #####: 1121:    result.m9 = y.z;
    #####: 1122:    result.m10 = z.z;
    #####: 1123:    result.m11 = 0.0f;
    #####: 1124:    result.m12 = -Vector3DotProduct(x, eye);
call    0 never executed
    #####: 1125:    result.m13 = -Vector3DotProduct(y, eye);
call    0 never executed
    #####: 1126:    result.m14 = -Vector3DotProduct(z, eye);
call    0 never executed
    #####: 1127:    result.m15 = 1.0f;
        -: 1128:
    #####: 1129:    return result;
        -: 1130:}
        -: 1131:
        -: 1132:// Get float array of matrix data
function MatrixToFloatV called 104 returned 100% blocks executed 100%
      104: 1133:RMDEF float16 MatrixToFloatV(Matrix mat)
        -: 1134:{
      104: 1135:    float16 buffer = { 0 };
        -: 1136:
      104: 1137:    buffer.v[0] = mat.m0;
      104: 1138:    buffer.v[1] = mat.m1;
      104: 1139:    buffer.v[2] = mat.m2;
      104: 1140:    buffer.v[3] = mat.m3;
      104: 1141:    buffer.v[4] = mat.m4;
      104: 1142:    buffer.v[5] = mat.m5;
      104: 1143:    buffer.v[6] = mat.m6;
      104: 1144:    buffer.v[7] = mat.m7;
      104: 1145:    buffer.v[8] = mat.m8;
      104: 1146:    buffer.v[9] = mat.m9;
      104: 1147:    buffer.v[10] = mat.m10;
      104: 1148:    buffer.v[11] = mat.m11;
      104: 1149:    buffer.v[12] = mat.m12;
      104: 1150:    buffer.v[13] = mat.m13;
      104: 1151:    buffer.v[14] = mat.m14;
      104: 1152:    buffer.v[15] = mat.m15;
        -: 1153:
      104: 1154:    return buffer;
      104: 1154-block  0
        -: 1155:}
        -: 1156:
        -: 1157://----------------------------------------------------------------------------------
        -: 1158:// Module Functions Definition - Quaternion math
        -: 1159://----------------------------------------------------------------------------------
        -: 1160:
        -: 1161:// Add two quaternions
function QuaternionAdd called 0 returned 0% blocks executed 0%
    #####: 1162:RMDEF Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
        -: 1163:{
    #####: 1164:    Quaternion result = {q1.x + q2.x, q1.y + q2.y, q1.z + q2.z, q1.w + q2.w};
    #####: 1165:    return result;
    %%%%%: 1165-block  0
        -: 1166:}
        -: 1167:
        -: 1168:// Add quaternion and float value
function QuaternionAddValue called 0 returned 0% blocks executed 0%
    #####: 1169:RMDEF Quaternion QuaternionAddValue(Quaternion q, float add)
        -: 1170:{
    #####: 1171:    Quaternion result = {q.x + add, q.y + add, q.z + add, q.w + add};
    #####: 1172:    return result;
    %%%%%: 1172-block  0
        -: 1173:}
        -: 1174:
        -: 1175:// Subtract two quaternions
function QuaternionSubtract called 0 returned 0% blocks executed 0%
    #####: 1176:RMDEF Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
        -: 1177:{
    #####: 1178:    Quaternion result = {q1.x - q2.x, q1.y - q2.y, q1.z - q2.z, q1.w - q2.w};
    #####: 1179:    return result;
    %%%%%: 1179-block  0
        -: 1180:}
        -: 1181:
        -: 1182:// Subtract quaternion and float value
function QuaternionSubtractValue called 0 returned 0% blocks executed 0%
    #####: 1183:RMDEF Quaternion QuaternionSubtractValue(Quaternion q, float sub)
        -: 1184:{
    #####: 1185:    Quaternion result = {q.x - sub, q.y - sub, q.z - sub, q.w - sub};
    #####: 1186:    return result;
    %%%%%: 1186-block  0
        -: 1187:}
        -: 1188:
        -: 1189:// Get identity quaternion
function QuaternionIdentity called 0 returned 0% blocks executed 0%
    #####: 1190:RMDEF Quaternion QuaternionIdentity(void)
        -: 1191:{
    #####: 1192:    Quaternion result = { 0.0f, 0.0f, 0.0f, 1.0f };
    #####: 1193:    return result;
    %%%%%: 1193-block  0
        -: 1194:}
        -: 1195:
        -: 1196:// Computes the length of a quaternion
function QuaternionLength called 0 returned 0% blocks executed 0%
    #####: 1197:RMDEF float QuaternionLength(Quaternion q)
        -: 1198:{
    #####: 1199:    float result = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
    #####: 1200:    return result;
    %%%%%: 1200-block  0
        -: 1201:}
        -: 1202:
        -: 1203:// Normalize provided quaternion
function QuaternionNormalize called 0 returned 0% blocks executed 0%
    #####: 1204:RMDEF Quaternion QuaternionNormalize(Quaternion q)
        -: 1205:{
    #####: 1206:    Quaternion result = { 0 };
        -: 1207:
        -: 1208:    float length, ilength;
    #####: 1209:    length = QuaternionLength(q);
    %%%%%: 1209-block  0
call    0 never executed
    #####: 1210:    if (length == 0.0f) length = 1.0f;
branch  0 never executed
branch  1 never executed
    %%%%%: 1210-block  0
    #####: 1211:    ilength = 1.0f/length;
        -: 1212:
    #####: 1213:    result.x = q.x*ilength;
    #####: 1214:    result.y = q.y*ilength;
    #####: 1215:    result.z = q.z*ilength;
    #####: 1216:    result.w = q.w*ilength;
        -: 1217:
    #####: 1218:    return result;
    %%%%%: 1218-block  0
        -: 1219:}
        -: 1220:
        -: 1221:// Invert provided quaternion
function QuaternionInvert called 0 returned 0% blocks executed 0%
    #####: 1222:RMDEF Quaternion QuaternionInvert(Quaternion q)
        -: 1223:{
    #####: 1224:    Quaternion result = q;
    #####: 1225:    float length = QuaternionLength(q);
    %%%%%: 1225-block  0
call    0 never executed
    #####: 1226:    float lengthSq = length*length;
        -: 1227:
    #####: 1228:    if (lengthSq != 0.0)
branch  0 never executed
branch  1 never executed
        -: 1229:    {
    #####: 1230:        float i = 1.0f/lengthSq;
        -: 1231:
    #####: 1232:        result.x *= -i;
    #####: 1233:        result.y *= -i;
    #####: 1234:        result.z *= -i;
    #####: 1235:        result.w *= i;
    %%%%%: 1235-block  0
        -: 1236:    }
        -: 1237:
    #####: 1238:    return result;
    %%%%%: 1238-block  0
        -: 1239:}
        -: 1240:
        -: 1241:// Calculate two quaternion multiplication
function QuaternionMultiply called 0 returned 0% blocks executed 0%
    #####: 1242:RMDEF Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
        -: 1243:{
    #####: 1244:    Quaternion result = { 0 };
        -: 1245:
    #####: 1246:    float qax = q1.x, qay = q1.y, qaz = q1.z, qaw = q1.w;
    #####: 1247:    float qbx = q2.x, qby = q2.y, qbz = q2.z, qbw = q2.w;
        -: 1248:
    #####: 1249:    result.x = qax*qbw + qaw*qbx + qay*qbz - qaz*qby;
    #####: 1250:    result.y = qay*qbw + qaw*qby + qaz*qbx - qax*qbz;
    #####: 1251:    result.z = qaz*qbw + qaw*qbz + qax*qby - qay*qbx;
    #####: 1252:    result.w = qaw*qbw - qax*qbx - qay*qby - qaz*qbz;
        -: 1253:
    #####: 1254:    return result;
    %%%%%: 1254-block  0
        -: 1255:}
        -: 1256:
        -: 1257:// Scale quaternion by float value
function QuaternionScale called 0 returned 0% blocks executed 0%
    #####: 1258:RMDEF Quaternion QuaternionScale(Quaternion q, float mul)
        -: 1259:{
    #####: 1260:    Quaternion result = { 0 };
        -: 1261:
    #####: 1262:    float qax = q.x, qay = q.y, qaz = q.z, qaw = q.w;
        -: 1263:
    #####: 1264:    result.x = qax*mul + qaw*mul + qay*mul - qaz*mul;
    #####: 1265:    result.y = qay*mul + qaw*mul + qaz*mul - qax*mul;
    #####: 1266:    result.z = qaz*mul + qaw*mul + qax*mul - qay*mul;
    #####: 1267:    result.w = qaw*mul - qax*mul - qay*mul - qaz*mul;
        -: 1268:
    #####: 1269:    return result;
    %%%%%: 1269-block  0
        -: 1270:}
        -: 1271:
        -: 1272:// Divide two quaternions
function QuaternionDivide called 0 returned 0% blocks executed 0%
    #####: 1273:RMDEF Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
        -: 1274:{
    #####: 1275:    Quaternion result = { q1.x/q2.x, q1.y/q2.y, q1.z/q2.z, q1.w/q2.w };
    #####: 1276:    return result;
    %%%%%: 1276-block  0
        -: 1277:}
        -: 1278:
        -: 1279:// Calculate linear interpolation between two quaternions
function QuaternionLerp called 0 returned 0% blocks executed 0%
    #####: 1280:RMDEF Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
        -: 1281:{
    #####: 1282:    Quaternion result = { 0 };
        -: 1283:
    #####: 1284:    result.x = q1.x + amount*(q2.x - q1.x);
    #####: 1285:    result.y = q1.y + amount*(q2.y - q1.y);
    #####: 1286:    result.z = q1.z + amount*(q2.z - q1.z);
    #####: 1287:    result.w = q1.w + amount*(q2.w - q1.w);
        -: 1288:
    #####: 1289:    return result;
    %%%%%: 1289-block  0
        -: 1290:}
        -: 1291:
        -: 1292:// Calculate slerp-optimized interpolation between two quaternions
function QuaternionNlerp called 0 returned 0% blocks executed 0%
    #####: 1293:RMDEF Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
        -: 1294:{
    #####: 1295:    Quaternion result = QuaternionLerp(q1, q2, amount);
    %%%%%: 1295-block  0
call    0 never executed
    #####: 1296:    result = QuaternionNormalize(result);
call    0 never executed
        -: 1297:
    #####: 1298:    return result;
        -: 1299:}
        -: 1300:
        -: 1301:// Calculates spherical linear interpolation between two quaternions
function QuaternionSlerp called 0 returned 0% blocks executed 0%
    #####: 1302:RMDEF Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
        -: 1303:{
    #####: 1304:    Quaternion result = { 0 };
        -: 1305:
    #####: 1306:    float cosHalfTheta = q1.x*q2.x + q1.y*q2.y + q1.z*q2.z + q1.w*q2.w;
        -: 1307:
    #####: 1308:    if (cosHalfTheta < 0)
    %%%%%: 1308-block  0
branch  0 never executed
branch  1 never executed
        -: 1309:    {
    #####: 1310:        q2.x = -q2.x; q2.y = -q2.y; q2.z = -q2.z; q2.w = -q2.w;
    #####: 1311:        cosHalfTheta = -cosHalfTheta;
    %%%%%: 1311-block  0
        -: 1312:    }
        -: 1313:
    #####: 1314:    if (fabs(cosHalfTheta) >= 1.0f) result = q1;
    %%%%%: 1314-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1314-block  1
    #####: 1315:    else if (cosHalfTheta > 0.95f) result = QuaternionNlerp(q1, q2, amount);
    %%%%%: 1315-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1315-block  1
call    2 never executed
        -: 1316:    else
        -: 1317:    {
    #####: 1318:        float halfTheta = acosf(cosHalfTheta);
    #####: 1319:        float sinHalfTheta = sqrtf(1.0f - cosHalfTheta*cosHalfTheta);
        -: 1320:
    #####: 1321:        if (fabs(sinHalfTheta) < 0.001f)
    %%%%%: 1321-block  0
branch  0 never executed
branch  1 never executed
        -: 1322:        {
    #####: 1323:            result.x = (q1.x*0.5f + q2.x*0.5f);
    #####: 1324:            result.y = (q1.y*0.5f + q2.y*0.5f);
    #####: 1325:            result.z = (q1.z*0.5f + q2.z*0.5f);
    #####: 1326:            result.w = (q1.w*0.5f + q2.w*0.5f);
    %%%%%: 1326-block  0
        -: 1327:        }
        -: 1328:        else
        -: 1329:        {
    #####: 1330:            float ratioA = sinf((1 - amount)*halfTheta)/sinHalfTheta;
    #####: 1331:            float ratioB = sinf(amount*halfTheta)/sinHalfTheta;
        -: 1332:
    #####: 1333:            result.x = (q1.x*ratioA + q2.x*ratioB);
    #####: 1334:            result.y = (q1.y*ratioA + q2.y*ratioB);
    #####: 1335:            result.z = (q1.z*ratioA + q2.z*ratioB);
    #####: 1336:            result.w = (q1.w*ratioA + q2.w*ratioB);
    %%%%%: 1336-block  0
        -: 1337:        }
        -: 1338:    }
        -: 1339:
    #####: 1340:    return result;
    %%%%%: 1340-block  0
        -: 1341:}
        -: 1342:
        -: 1343:// Calculate quaternion based on the rotation from one vector to another
function QuaternionFromVector3ToVector3 called 0 returned 0% blocks executed 0%
    #####: 1344:RMDEF Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
        -: 1345:{
    #####: 1346:    Quaternion result = { 0 };
        -: 1347:
    #####: 1348:    float cos2Theta = Vector3DotProduct(from, to);
    %%%%%: 1348-block  0
call    0 never executed
    #####: 1349:    Vector3 cross = Vector3CrossProduct(from, to);
call    0 never executed
        -: 1350:
    #####: 1351:    result.x = cross.x;
    #####: 1352:    result.y = cross.y;
    #####: 1353:    result.z = cross.z;
    #####: 1354:    result.w = 1.0f + cos2Theta;     // NOTE: Added QuaternioIdentity()
        -: 1355:
        -: 1356:    // Normalize to essentially nlerp the original and identity to 0.5
    #####: 1357:    result = QuaternionNormalize(result);
call    0 never executed
        -: 1358:
        -: 1359:    // Above lines are equivalent to:
        -: 1360:    //Quaternion result = QuaternionNlerp(q, QuaternionIdentity(), 0.5f);
        -: 1361:
    #####: 1362:    return result;
        -: 1363:}
        -: 1364:
        -: 1365:// Get a quaternion for a given rotation matrix
function QuaternionFromMatrix called 0 returned 0% blocks executed 0%
    #####: 1366:RMDEF Quaternion QuaternionFromMatrix(Matrix mat)
        -: 1367:{
    #####: 1368:    Quaternion result = { 0 };
        -: 1369:
    #####: 1370:    if ((mat.m0 > mat.m5) && (mat.m0 > mat.m10))
    %%%%%: 1370-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1370-block  1
branch  2 never executed
branch  3 never executed
    #####: 1371:    {
    #####: 1372:        float s = sqrtf(1.0f + mat.m0 - mat.m5 - mat.m10)*2;
        -: 1373:
    #####: 1374:        result.x = 0.25f*s;
    #####: 1375:        result.y = (mat.m4 + mat.m1)/s;
    #####: 1376:        result.z = (mat.m2 + mat.m8)/s;
    #####: 1377:        result.w = (mat.m9 - mat.m6)/s;
    %%%%%: 1377-block  0
        -: 1378:    }
    #####: 1379:    else if (mat.m5 > mat.m10)
    %%%%%: 1379-block  0
branch  0 never executed
branch  1 never executed
        -: 1380:    {
    #####: 1381:        float s = sqrtf(1.0f + mat.m5 - mat.m0 - mat.m10)*2;
    #####: 1382:        result.x = (mat.m4 + mat.m1)/s;
    #####: 1383:        result.y = 0.25f*s;
    #####: 1384:        result.z = (mat.m9 + mat.m6)/s;
    #####: 1385:        result.w = (mat.m2 - mat.m8)/s;
    %%%%%: 1385-block  0
        -: 1386:    }
        -: 1387:    else
        -: 1388:    {
    #####: 1389:        float s = sqrtf(1.0f + mat.m10 - mat.m0 - mat.m5)*2;
    #####: 1390:        result.x = (mat.m2 + mat.m8)/s;
    #####: 1391:        result.y = (mat.m9 + mat.m6)/s;
    #####: 1392:        result.z = 0.25f*s;
    #####: 1393:        result.w = (mat.m4 - mat.m1)/s;
    %%%%%: 1393-block  0
        -: 1394:    }
        -: 1395:
    #####: 1396:    return result;
    %%%%%: 1396-block  0
        -: 1397:}
        -: 1398:
        -: 1399:// Get a matrix for a given quaternion
function QuaternionToMatrix called 0 returned 0% blocks executed 0%
    #####: 1400:RMDEF Matrix QuaternionToMatrix(Quaternion q)
        -: 1401:{
    #####: 1402:    Matrix result = MatrixIdentity();
    %%%%%: 1402-block  0
call    0 never executed
        -: 1403:
    #####: 1404:    float a2 = q.x*q.x;
    #####: 1405:    float b2 = q.y*q.y;
    #####: 1406:    float c2 = q.z*q.z;
    #####: 1407:    float ac = q.x*q.z;
    #####: 1408:    float ab = q.x*q.y;
    #####: 1409:    float bc = q.y*q.z;
    #####: 1410:    float ad = q.w*q.x;
    #####: 1411:    float bd = q.w*q.y;
    #####: 1412:    float cd = q.w*q.z;
        -: 1413:
    #####: 1414:    result.m0 = 1 - 2*(b2 + c2);
    #####: 1415:    result.m1 = 2*(ab + cd);
    #####: 1416:    result.m2 = 2*(ac - bd);
        -: 1417:
    #####: 1418:    result.m4 = 2*(ab - cd);
    #####: 1419:    result.m5 = 1 - 2*(a2 + c2);
    #####: 1420:    result.m6 = 2*(bc + ad);
        -: 1421:
    #####: 1422:    result.m8 = 2*(ac + bd);
    #####: 1423:    result.m9 = 2*(bc - ad);
    #####: 1424:    result.m10 = 1 - 2*(a2 + b2);
        -: 1425:
    #####: 1426:    return result;
        -: 1427:}
        -: 1428:
        -: 1429:// Get rotation quaternion for an angle and axis
        -: 1430:// NOTE: angle must be provided in radians
function QuaternionFromAxisAngle called 0 returned 0% blocks executed 0%
    #####: 1431:RMDEF Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
        -: 1432:{
    #####: 1433:    Quaternion result = { 0.0f, 0.0f, 0.0f, 1.0f };
    #####: 1434:    float axisLength = sqrtf(axis.x*axis.x + axis.y*axis.y + axis.z*axis.z);
        -: 1435:
    #####: 1436:    if (axisLength != 0.0f)
    %%%%%: 1436-block  0
branch  0 never executed
branch  1 never executed
        -: 1437:    {
    #####: 1438:        angle *= 0.5f;
        -: 1439:
    #####: 1440:        axis = Vector3Normalize(axis);
    %%%%%: 1440-block  0
call    0 never executed
        -: 1441:
    #####: 1442:        float sinres = sinf(angle);
    #####: 1443:        float cosres = cosf(angle);
        -: 1444:
    #####: 1445:        result.x = axis.x*sinres;
    #####: 1446:        result.y = axis.y*sinres;
    #####: 1447:        result.z = axis.z*sinres;
    #####: 1448:        result.w = cosres;
        -: 1449:
    #####: 1450:        result = QuaternionNormalize(result);
call    0 never executed
        -: 1451:    }
        -: 1452:
    #####: 1453:    return result;
    %%%%%: 1453-block  0
        -: 1454:}
        -: 1455:
        -: 1456:// Get the rotation angle and axis for a given quaternion
function QuaternionToAxisAngle called 0 returned 0% blocks executed 0%
    #####: 1457:RMDEF void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
        -: 1458:{
    #####: 1459:    if (fabs(q.w) > 1.0f) q = QuaternionNormalize(q);
    %%%%%: 1459-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1459-block  1
call    2 never executed
        -: 1460:
    #####: 1461:    Vector3 resAxis = { 0.0f, 0.0f, 0.0f };
    #####: 1462:    float resAngle = 2.0f*acosf(q.w);
    #####: 1463:    float den = sqrtf(1.0f - q.w*q.w);
        -: 1464:
    #####: 1465:    if (den > 0.0001f)
    %%%%%: 1465-block  0
branch  0 never executed
branch  1 never executed
        -: 1466:    {
    #####: 1467:        resAxis.x = q.x/den;
    #####: 1468:        resAxis.y = q.y/den;
    #####: 1469:        resAxis.z = q.z/den;
    %%%%%: 1469-block  0
        -: 1470:    }
        -: 1471:    else
        -: 1472:    {
        -: 1473:        // This occurs when the angle is zero.
        -: 1474:        // Not a problem: just set an arbitrary normalized axis.
    #####: 1475:        resAxis.x = 1.0f;
    %%%%%: 1475-block  0
        -: 1476:    }
        -: 1477:
    #####: 1478:    *outAxis = resAxis;
    #####: 1479:    *outAngle = resAngle;
    #####: 1480:}
        -: 1481:
        -: 1482:// Get the quaternion equivalent to Euler angles
        -: 1483:// NOTE: Rotation order is ZYX
function QuaternionFromEuler called 0 returned 0% blocks executed 0%
    #####: 1484:RMDEF Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
        -: 1485:{
    #####: 1486:    Quaternion q = { 0 };
        -: 1487:
    #####: 1488:    float x0 = cosf(pitch*0.5f);
    #####: 1489:    float x1 = sinf(pitch*0.5f);
    #####: 1490:    float y0 = cosf(yaw*0.5f);
    #####: 1491:    float y1 = sinf(yaw*0.5f);
    #####: 1492:    float z0 = cosf(roll*0.5f);
    #####: 1493:    float z1 = sinf(roll*0.5f);
        -: 1494:
    #####: 1495:    q.x = x1*y0*z0 - x0*y1*z1;
    #####: 1496:    q.y = x0*y1*z0 + x1*y0*z1;
    #####: 1497:    q.z = x0*y0*z1 - x1*y1*z0;
    #####: 1498:    q.w = x0*y0*z0 + x1*y1*z1;
        -: 1499:
    #####: 1500:    return q;
    %%%%%: 1500-block  0
        -: 1501:}
        -: 1502:
        -: 1503:// Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
        -: 1504:// NOTE: Angles are returned in a Vector3 struct in degrees
function QuaternionToEuler called 0 returned 0% blocks executed 0%
    #####: 1505:RMDEF Vector3 QuaternionToEuler(Quaternion q)
        -: 1506:{
    #####: 1507:    Vector3 result = { 0 };
        -: 1508:
        -: 1509:    // roll (x-axis rotation)
    #####: 1510:    float x0 = 2.0f*(q.w*q.x + q.y*q.z);
    #####: 1511:    float x1 = 1.0f - 2.0f*(q.x*q.x + q.y*q.y);
    #####: 1512:    result.x = atan2f(x0, x1)*RAD2DEG;
        -: 1513:
        -: 1514:    // pitch (y-axis rotation)
    #####: 1515:    float y0 = 2.0f*(q.w*q.y - q.z*q.x);
    #####: 1516:    y0 = y0 > 1.0f ? 1.0f : y0;
    %%%%%: 1516-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1516-block  1
    %%%%%: 1516-block  2
    #####: 1517:    y0 = y0 < -1.0f ? -1.0f : y0;
    %%%%%: 1517-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1517-block  1
    %%%%%: 1517-block  2
    #####: 1518:    result.y = asinf(y0)*RAD2DEG;
        -: 1519:
        -: 1520:    // yaw (z-axis rotation)
    #####: 1521:    float z0 = 2.0f*(q.w*q.z + q.x*q.y);
    #####: 1522:    float z1 = 1.0f - 2.0f*(q.y*q.y + q.z*q.z);
    #####: 1523:    result.z = atan2f(z0, z1)*RAD2DEG;
        -: 1524:
    #####: 1525:    return result;
    %%%%%: 1525-block  0
        -: 1526:}
        -: 1527:
        -: 1528:// Transform a quaternion given a transformation matrix
function QuaternionTransform called 0 returned 0% blocks executed 0%
    #####: 1529:RMDEF Quaternion QuaternionTransform(Quaternion q, Matrix mat)
        -: 1530:{
    #####: 1531:    Quaternion result = { 0 };
        -: 1532:
    #####: 1533:    result.x = mat.m0*q.x + mat.m4*q.y + mat.m8*q.z + mat.m12*q.w;
    #####: 1534:    result.y = mat.m1*q.x + mat.m5*q.y + mat.m9*q.z + mat.m13*q.w;
    #####: 1535:    result.z = mat.m2*q.x + mat.m6*q.y + mat.m10*q.z + mat.m14*q.w;
    #####: 1536:    result.w = mat.m3*q.x + mat.m7*q.y + mat.m11*q.z + mat.m15*q.w;
        -: 1537:
    #####: 1538:    return result;
    %%%%%: 1538-block  0
        -: 1539:}
        -: 1540:
        -: 1541:// Projects a Vector3 from screen space into object space
function Vector3Unproject called 0 returned 0% blocks executed 0%
    #####: 1542:RMDEF Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
        -: 1543:{
    #####: 1544:    Vector3 result = { 0.0f, 0.0f, 0.0f };
        -: 1545:
        -: 1546:    // Calculate unproject matrix (multiply view patrix by projection matrix) and invert it
    #####: 1547:    Matrix matViewProj = MatrixMultiply(view, projection);
    %%%%%: 1547-block  0
call    0 never executed
    #####: 1548:    matViewProj = MatrixInvert(matViewProj);
call    0 never executed
        -: 1549:
        -: 1550:    // Create quaternion from source point
    #####: 1551:    Quaternion quat = { source.x, source.y, source.z, 1.0f };
        -: 1552:
        -: 1553:    // Multiply quat point by unproject matrix
    #####: 1554:    quat = QuaternionTransform(quat, matViewProj);
call    0 never executed
        -: 1555:
        -: 1556:    // Normalized world points in vectors
    #####: 1557:    result.x = quat.x/quat.w;
    #####: 1558:    result.y = quat.y/quat.w;
    #####: 1559:    result.z = quat.z/quat.w;
        -: 1560:
    #####: 1561:    return result;
        -: 1562:}
        -: 1563:
        -: 1564:#endif  // RAYMATH_H
