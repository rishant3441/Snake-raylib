        -:    0:Source:C:/Dev/CLionProjects/Snake-raylib/cmake-build-debug-coverage/_deps/raylib-src/src/external/glfw/src/win32_monitor.c
        -:    0:Graph:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\external\glfw\src\CMakeFiles\glfw.dir\win32_monitor.c.gcno
        -:    0:Data:C:\Dev\CLionProjects\Snake-raylib\cmake-build-debug-coverage\_deps\raylib-build\raylib\external\glfw\src\CMakeFiles\glfw.dir\win32_monitor.c.gcda
        -:    0:Runs:1
        -:    1://========================================================================
        -:    2:// GLFW 3.4 Win32 - www.glfw.org
        -:    3://------------------------------------------------------------------------
        -:    4:// Copyright (c) 2002-2006 Marcus Geelnard
        -:    5:// Copyright (c) 2006-2019 Camilla LÃ¶wy <elmindreda@glfw.org>
        -:    6://
        -:    7:// This software is provided 'as-is', without any express or implied
        -:    8:// warranty. In no event will the authors be held liable for any damages
        -:    9:// arising from the use of this software.
        -:   10://
        -:   11:// Permission is granted to anyone to use this software for any purpose,
        -:   12:// including commercial applications, and to alter it and redistribute it
        -:   13:// freely, subject to the following restrictions:
        -:   14://
        -:   15:// 1. The origin of this software must not be misrepresented; you must not
        -:   16://    claim that you wrote the original software. If you use this software
        -:   17://    in a product, an acknowledgment in the product documentation would
        -:   18://    be appreciated but is not required.
        -:   19://
        -:   20:// 2. Altered source versions must be plainly marked as such, and must not
        -:   21://    be misrepresented as being the original software.
        -:   22://
        -:   23:// 3. This notice may not be removed or altered from any source
        -:   24://    distribution.
        -:   25://
        -:   26://========================================================================
        -:   27:// Please use C89 style variable declarations in this file because VS 2010
        -:   28://========================================================================
        -:   29:
        -:   30:#include "internal.h"
        -:   31:
        -:   32:#include <stdlib.h>
        -:   33:#include <string.h>
        -:   34:#include <limits.h>
        -:   35:#include <malloc.h>
        -:   36:#include <wchar.h>
        -:   37:
        -:   38:
        -:   39:// Callback for EnumDisplayMonitors in createMonitor
        -:   40://
function monitorCallback called 2 returned 100% blocks executed 100%
        2:   41:static BOOL CALLBACK monitorCallback(HMONITOR handle,
        -:   42:                                     HDC dc,
        -:   43:                                     RECT* rect,
        -:   44:                                     LPARAM data)
        -:   45:{
        -:   46:    MONITORINFOEXW mi;
        2:   47:    ZeroMemory(&mi, sizeof(mi));
        2:   48:    mi.cbSize = sizeof(mi);
        -:   49:
        2:   50:    if (GetMonitorInfoW(handle, (MONITORINFO*) &mi))
        2:   50-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -:   51:    {
        2:   52:        _GLFWmonitor* monitor = (_GLFWmonitor*) data;
        2:   53:        if (wcscmp(mi.szDevice, monitor->win32.adapterName) == 0)
        2:   53-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2:   54:            monitor->win32.handle = handle;
        2:   54-block  0
        -:   55:    }
        -:   56:
        2:   57:    return TRUE;
        2:   57-block  0
        -:   58:}
        -:   59:
        -:   60:// Create monitor from an adapter and (optionally) a display
        -:   61://
function createMonitor called 2 returned 100% blocks executed 78%
        2:   62:static _GLFWmonitor* createMonitor(DISPLAY_DEVICEW* adapter,
        -:   63:                                   DISPLAY_DEVICEW* display)
        -:   64:{
        -:   65:    _GLFWmonitor* monitor;
        -:   66:    int widthMM, heightMM;
        -:   67:    char* name;
        -:   68:    HDC dc;
        -:   69:    DEVMODEW dm;
        -:   70:    RECT rect;
        -:   71:
        2:   72:    if (display)
        2:   72-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:   73:        name = _glfwCreateUTF8FromWideStringWin32(display->DeviceString);
        2:   73-block  0
call    0 returned 2
        -:   74:    else
    #####:   75:        name = _glfwCreateUTF8FromWideStringWin32(adapter->DeviceString);
    %%%%%:   75-block  0
call    0 never executed
        2:   76:    if (!name)
        2:   76-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:   77:        return NULL;
    %%%%%:   77-block  0
        -:   78:
        2:   79:    ZeroMemory(&dm, sizeof(dm));
        2:   80:    dm.dmSize = sizeof(dm);
        2:   81:    EnumDisplaySettingsW(adapter->DeviceName, ENUM_CURRENT_SETTINGS, &dm);
        2:   81-block  0
call    0 returned 2
        -:   82:
        2:   83:    dc = CreateDCW(L"DISPLAY", adapter->DeviceName, NULL, NULL);
call    0 returned 2
        -:   84:
        2:   85:    if (IsWindows8Point1OrGreater())
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -:   86:    {
        2:   87:        widthMM  = GetDeviceCaps(dc, HORZSIZE);
        2:   87-block  0
call    0 returned 2
        2:   88:        heightMM = GetDeviceCaps(dc, VERTSIZE);
call    0 returned 2
        -:   89:    }
        -:   90:    else
        -:   91:    {
    #####:   92:        widthMM  = (int) (dm.dmPelsWidth * 25.4f / GetDeviceCaps(dc, LOGPIXELSX));
    %%%%%:   92-block  0
call    0 never executed
    #####:   93:        heightMM = (int) (dm.dmPelsHeight * 25.4f / GetDeviceCaps(dc, LOGPIXELSY));
call    0 never executed
        -:   94:    }
        -:   95:
        2:   96:    DeleteDC(dc);
        2:   96-block  0
call    0 returned 2
        -:   97:
        2:   98:    monitor = _glfwAllocMonitor(name, widthMM, heightMM);
call    0 returned 2
        2:   99:    free(name);
        -:  100:
        2:  101:    if (adapter->StateFlags & DISPLAY_DEVICE_MODESPRUNED)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  102:        monitor->win32.modesPruned = GLFW_TRUE;
    %%%%%:  102-block  0
        -:  103:
        2:  104:    wcscpy(monitor->win32.adapterName, adapter->DeviceName);
        2:  104-block  0
call    0 returned 2
        2:  105:    WideCharToMultiByte(CP_UTF8, 0,
        2:  106:                        adapter->DeviceName, -1,
        2:  107:                        monitor->win32.publicAdapterName,
call    0 returned 2
        -:  108:                        sizeof(monitor->win32.publicAdapterName),
        -:  109:                        NULL, NULL);
        -:  110:
        2:  111:    if (display)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -:  112:    {
        2:  113:        wcscpy(monitor->win32.displayName, display->DeviceName);
        2:  113-block  0
call    0 returned 2
        2:  114:        WideCharToMultiByte(CP_UTF8, 0,
        2:  115:                            display->DeviceName, -1,
        2:  116:                            monitor->win32.publicDisplayName,
call    0 returned 2
        -:  117:                            sizeof(monitor->win32.publicDisplayName),
        -:  118:                            NULL, NULL);
        -:  119:    }
        -:  120:
        2:  121:    rect.left   = dm.dmPosition.x;
        2:  122:    rect.top    = dm.dmPosition.y;
        2:  123:    rect.right  = dm.dmPosition.x + dm.dmPelsWidth;
        2:  124:    rect.bottom = dm.dmPosition.y + dm.dmPelsHeight;
        -:  125:
        2:  126:    EnumDisplayMonitors(NULL, &rect, monitorCallback, (LPARAM) monitor);
        2:  126-block  0
call    0 returned 2
        2:  127:    return monitor;
        -:  128:}
        -:  129:
        -:  130:
        -:  131://////////////////////////////////////////////////////////////////////////
        -:  132://////                       GLFW internal API                      //////
        -:  133://////////////////////////////////////////////////////////////////////////
        -:  134:
        -:  135:// Poll for changes in the set of connected monitors
        -:  136://
function _glfwPollMonitorsWin32 called 1 returned 100% blocks executed 51%
        1:  137:void _glfwPollMonitorsWin32(void)
        -:  138:{
        -:  139:    int i, disconnectedCount;
        1:  140:    _GLFWmonitor** disconnected = NULL;
        -:  141:    DWORD adapterIndex, displayIndex;
        -:  142:    DISPLAY_DEVICEW adapter, display;
        -:  143:    _GLFWmonitor* monitor;
        -:  144:
        1:  145:    disconnectedCount = _glfw.monitorCount;
        1:  146:    if (disconnectedCount)
        1:  146-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  147:    {
    #####:  148:        disconnected = calloc(_glfw.monitorCount, sizeof(_GLFWmonitor*));
    #####:  149:        memcpy(disconnected,
    #####:  150:               _glfw.monitors,
    #####:  151:               _glfw.monitorCount * sizeof(_GLFWmonitor*));
    %%%%%:  151-block  0
        -:  152:    }
        -:  153:
        1:  154:    for (adapterIndex = 0;  ;  adapterIndex++)
        1:  154-block  0
       20:  155:    {
       20:  155-block  0
       21:  156:        int type = _GLFW_INSERT_LAST;
        -:  157:
       21:  158:        ZeroMemory(&adapter, sizeof(adapter));
       21:  159:        adapter.cb = sizeof(adapter);
        -:  160:
       21:  161:        if (!EnumDisplayDevicesW(NULL, adapterIndex, &adapter, 0))
       21:  161-block  0
call    0 returned 21
branch  1 taken 1 (fallthrough)
branch  2 taken 20
        1:  162:            break;
        1:  162-block  0
        -:  163:
       20:  164:        if (!(adapter.StateFlags & DISPLAY_DEVICE_ACTIVE))
       20:  164-block  0
branch  0 taken 18 (fallthrough)
branch  1 taken 2
       18:  165:            continue;
       18:  165-block  0
        -:  166:
        2:  167:        if (adapter.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
        2:  167-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  168:            type = _GLFW_INSERT_FIRST;
        1:  168-block  0
        -:  169:
        4:  170:        for (displayIndex = 0;  ;  displayIndex++)
        2:  170-block  0
        2:  170-block  1
        -:  171:        {
        4:  172:            ZeroMemory(&display, sizeof(display));
        4:  173:            display.cb = sizeof(display);
        -:  174:
        4:  175:            if (!EnumDisplayDevicesW(adapter.DeviceName, displayIndex, &display, 0))
        4:  175-block  0
call    0 returned 4
branch  1 taken 2 (fallthrough)
branch  2 taken 2
        2:  176:                break;
        2:  176-block  0
        -:  177:
        2:  178:            if (!(display.StateFlags & DISPLAY_DEVICE_ACTIVE))
        2:  178-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  179:                continue;
    %%%%%:  179-block  0
        -:  180:
       2*:  181:            for (i = 0;  i < disconnectedCount;  i++)
        2:  181-block  0
    %%%%%:  181-block  1
        2:  181-block  2
branch  0 taken 0
branch  1 taken 2 (fallthrough)
        -:  182:            {
    #####:  183:                if (disconnected[i] &&
    %%%%%:  183-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  184:                    wcscmp(disconnected[i]->win32.displayName,
    %%%%%:  184-block  0
call    0 never executed
        -:  185:                           display.DeviceName) == 0)
        -:  186:                {
    #####:  187:                    disconnected[i] = NULL;
        -:  188:                    // handle may have changed, update
    #####:  189:                    EnumDisplayMonitors(NULL, NULL, monitorCallback, (LPARAM) _glfw.monitors[i]);
    %%%%%:  189-block  0
call    0 never executed
    #####:  190:                    break;
        -:  191:                }
        -:  192:            }
        -:  193:
        2:  194:            if (i < disconnectedCount)
        2:  194-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  195:                continue;
    %%%%%:  195-block  0
        -:  196:
        2:  197:            monitor = createMonitor(&adapter, &display);
        2:  197-block  0
call    0 returned 2
        2:  198:            if (!monitor)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  199:            {
    #####:  200:                free(disconnected);
    #####:  201:                return;
    %%%%%:  201-block  0
    %%%%%:  201-block  1
        -:  202:            }
        -:  203:
        2:  204:            _glfwInputMonitor(monitor, GLFW_CONNECTED, type);
        2:  204-block  0
call    0 returned 2
        -:  205:
        2:  206:            type = _GLFW_INSERT_LAST;
        -:  207:        }
        -:  208:
        -:  209:        // HACK: If an active adapter does not have any display devices
        -:  210:        //       (as sometimes happens), add it directly as a monitor
        2:  211:        if (displayIndex == 0)
        2:  211-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  212:        {
    #####:  213:            for (i = 0;  i < disconnectedCount;  i++)
    %%%%%:  213-block  0
    %%%%%:  213-block  1
    %%%%%:  213-block  2
branch  0 never executed
branch  1 never executed
        -:  214:            {
    #####:  215:                if (disconnected[i] &&
    %%%%%:  215-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  216:                    wcscmp(disconnected[i]->win32.adapterName,
    %%%%%:  216-block  0
call    0 never executed
        -:  217:                           adapter.DeviceName) == 0)
        -:  218:                {
    #####:  219:                    disconnected[i] = NULL;
    #####:  220:                    break;
    %%%%%:  220-block  0
        -:  221:                }
        -:  222:            }
        -:  223:
    #####:  224:            if (i < disconnectedCount)
    %%%%%:  224-block  0
branch  0 never executed
branch  1 never executed
    #####:  225:                continue;
    %%%%%:  225-block  0
        -:  226:
    #####:  227:            monitor = createMonitor(&adapter, NULL);
    %%%%%:  227-block  0
call    0 never executed
    #####:  228:            if (!monitor)
branch  0 never executed
branch  1 never executed
        -:  229:            {
    #####:  230:                free(disconnected);
    #####:  231:                return;
    %%%%%:  231-block  0
        -:  232:            }
        -:  233:
    #####:  234:            _glfwInputMonitor(monitor, GLFW_CONNECTED, type);
    %%%%%:  234-block  0
call    0 never executed
        -:  235:        }
        -:  236:    }
        -:  237:
       1*:  238:    for (i = 0;  i < disconnectedCount;  i++)
        1:  238-block  0
    %%%%%:  238-block  1
        1:  238-block  2
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:  239:    {
    #####:  240:        if (disconnected[i])
    %%%%%:  240-block  0
branch  0 never executed
branch  1 never executed
    #####:  241:            _glfwInputMonitor(disconnected[i], GLFW_DISCONNECTED, 0);
    %%%%%:  241-block  0
call    0 never executed
        -:  242:    }
        -:  243:
        1:  244:    free(disconnected);
        1:  244-block  0
        -:  245:}
        -:  246:
        -:  247:// Change the current video mode
        -:  248://
function _glfwSetVideoModeWin32 called 0 returned 0% blocks executed 0%
    #####:  249:void _glfwSetVideoModeWin32(_GLFWmonitor* monitor, const GLFWvidmode* desired)
        -:  250:{
        -:  251:    GLFWvidmode current;
        -:  252:    const GLFWvidmode* best;
        -:  253:    DEVMODEW dm;
        -:  254:    LONG result;
        -:  255:
    #####:  256:    best = _glfwChooseVideoMode(monitor, desired);
    %%%%%:  256-block  0
call    0 never executed
    #####:  257:    _glfwPlatformGetVideoMode(monitor, &current);
call    0 never executed
    #####:  258:    if (_glfwCompareVideoModes(&current, best) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  259:        return;
    %%%%%:  259-block  0
        -:  260:
    #####:  261:    ZeroMemory(&dm, sizeof(dm));
    #####:  262:    dm.dmSize = sizeof(dm);
    #####:  263:    dm.dmFields           = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL |
        -:  264:                            DM_DISPLAYFREQUENCY;
    #####:  265:    dm.dmPelsWidth        = best->width;
    #####:  266:    dm.dmPelsHeight       = best->height;
    #####:  267:    dm.dmBitsPerPel       = best->redBits + best->greenBits + best->blueBits;
    #####:  268:    dm.dmDisplayFrequency = best->refreshRate;
        -:  269:
    #####:  270:    if (dm.dmBitsPerPel < 15 || dm.dmBitsPerPel >= 24)
    %%%%%:  270-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  270-block  1
branch  2 never executed
branch  3 never executed
    #####:  271:        dm.dmBitsPerPel = 32;
    %%%%%:  271-block  0
        -:  272:
    #####:  273:    result = ChangeDisplaySettingsExW(monitor->win32.adapterName,
    %%%%%:  273-block  0
call    0 never executed
        -:  274:                                      &dm,
        -:  275:                                      NULL,
        -:  276:                                      CDS_FULLSCREEN,
        -:  277:                                      NULL);
    #####:  278:    if (result == DISP_CHANGE_SUCCESSFUL)
branch  0 never executed
branch  1 never executed
    #####:  279:        monitor->win32.modeChanged = GLFW_TRUE;
    %%%%%:  279-block  0
        -:  280:    else
        -:  281:    {
    #####:  282:        const char* description = "Unknown error";
        -:  283:
    #####:  284:        if (result == DISP_CHANGE_BADDUALVIEW)
    %%%%%:  284-block  0
branch  0 never executed
branch  1 never executed
    #####:  285:            description = "The system uses DualView";
    %%%%%:  285-block  0
    #####:  286:        else if (result == DISP_CHANGE_BADFLAGS)
    %%%%%:  286-block  0
branch  0 never executed
branch  1 never executed
    #####:  287:            description = "Invalid flags";
    %%%%%:  287-block  0
    #####:  288:        else if (result == DISP_CHANGE_BADMODE)
    %%%%%:  288-block  0
branch  0 never executed
branch  1 never executed
    #####:  289:            description = "Graphics mode not supported";
    %%%%%:  289-block  0
    #####:  290:        else if (result == DISP_CHANGE_BADPARAM)
    %%%%%:  290-block  0
branch  0 never executed
branch  1 never executed
    #####:  291:            description = "Invalid parameter";
    %%%%%:  291-block  0
    #####:  292:        else if (result == DISP_CHANGE_FAILED)
    %%%%%:  292-block  0
branch  0 never executed
branch  1 never executed
    #####:  293:            description = "Graphics mode failed";
    %%%%%:  293-block  0
    #####:  294:        else if (result == DISP_CHANGE_NOTUPDATED)
    %%%%%:  294-block  0
branch  0 never executed
branch  1 never executed
    #####:  295:            description = "Failed to write to registry";
    %%%%%:  295-block  0
    #####:  296:        else if (result == DISP_CHANGE_RESTART)
    %%%%%:  296-block  0
branch  0 never executed
branch  1 never executed
    #####:  297:            description = "Computer restart required";
    %%%%%:  297-block  0
        -:  298:
    #####:  299:        _glfwInputError(GLFW_PLATFORM_ERROR,
    %%%%%:  299-block  0
call    0 never executed
        -:  300:                        "Win32: Failed to set video mode: %s",
        -:  301:                        description);
        -:  302:    }
        -:  303:}
        -:  304:
        -:  305:// Restore the previously saved (original) video mode
        -:  306://
function _glfwRestoreVideoModeWin32 called 0 returned 0% blocks executed 0%
    #####:  307:void _glfwRestoreVideoModeWin32(_GLFWmonitor* monitor)
        -:  308:{
    #####:  309:    if (monitor->win32.modeChanged)
    %%%%%:  309-block  0
branch  0 never executed
branch  1 never executed
        -:  310:    {
    #####:  311:        ChangeDisplaySettingsExW(monitor->win32.adapterName,
    %%%%%:  311-block  0
call    0 never executed
        -:  312:                                 NULL, NULL, CDS_FULLSCREEN, NULL);
    #####:  313:        monitor->win32.modeChanged = GLFW_FALSE;
        -:  314:    }
    #####:  315:}
        -:  316:
function _glfwGetMonitorContentScaleWin32 called 0 returned 0% blocks executed 0%
    #####:  317:void _glfwGetMonitorContentScaleWin32(HMONITOR handle, float* xscale, float* yscale)
        -:  318:{
        -:  319:    UINT xdpi, ydpi;
        -:  320:
    #####:  321:    if (IsWindows8Point1OrGreater())
    %%%%%:  321-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  322:        GetDpiForMonitor(handle, MDT_EFFECTIVE_DPI, &xdpi, &ydpi);
    %%%%%:  322-block  0
call    0 never executed
        -:  323:    else
        -:  324:    {
    #####:  325:        const HDC dc = GetDC(NULL);
    %%%%%:  325-block  0
call    0 never executed
    #####:  326:        xdpi = GetDeviceCaps(dc, LOGPIXELSX);
call    0 never executed
    #####:  327:        ydpi = GetDeviceCaps(dc, LOGPIXELSY);
call    0 never executed
    #####:  328:        ReleaseDC(NULL, dc);
call    0 never executed
        -:  329:    }
        -:  330:
    #####:  331:    if (xscale)
    %%%%%:  331-block  0
branch  0 never executed
branch  1 never executed
    #####:  332:        *xscale = xdpi / (float) USER_DEFAULT_SCREEN_DPI;
    %%%%%:  332-block  0
    #####:  333:    if (yscale)
    %%%%%:  333-block  0
branch  0 never executed
branch  1 never executed
    #####:  334:        *yscale = ydpi / (float) USER_DEFAULT_SCREEN_DPI;
    %%%%%:  334-block  0
    #####:  335:}
        -:  336:
        -:  337:
        -:  338://////////////////////////////////////////////////////////////////////////
        -:  339://////                       GLFW platform API                      //////
        -:  340://////////////////////////////////////////////////////////////////////////
        -:  341:
function _glfwPlatformFreeMonitor called 2 returned 100% blocks executed 100%
        2:  342:void _glfwPlatformFreeMonitor(_GLFWmonitor* monitor)
        -:  343:{
        2:  344:}
        -:  345:
function _glfwPlatformGetMonitorPos called 0 returned 0% blocks executed 0%
    #####:  346:void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
        -:  347:{
        -:  348:    DEVMODEW dm;
    #####:  349:    ZeroMemory(&dm, sizeof(dm));
    #####:  350:    dm.dmSize = sizeof(dm);
        -:  351:
    #####:  352:    EnumDisplaySettingsExW(monitor->win32.adapterName,
    %%%%%:  352-block  0
call    0 never executed
        -:  353:                           ENUM_CURRENT_SETTINGS,
        -:  354:                           &dm,
        -:  355:                           EDS_ROTATEDMODE);
        -:  356:
    #####:  357:    if (xpos)
branch  0 never executed
branch  1 never executed
    #####:  358:        *xpos = dm.dmPosition.x;
    %%%%%:  358-block  0
    #####:  359:    if (ypos)
    %%%%%:  359-block  0
branch  0 never executed
branch  1 never executed
    #####:  360:        *ypos = dm.dmPosition.y;
    %%%%%:  360-block  0
    #####:  361:}
        -:  362:
function _glfwPlatformGetMonitorContentScale called 0 returned 0% blocks executed 0%
    #####:  363:void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
        -:  364:                                         float* xscale, float* yscale)
        -:  365:{
    #####:  366:    _glfwGetMonitorContentScaleWin32(monitor->win32.handle, xscale, yscale);
    %%%%%:  366-block  0
call    0 never executed
    #####:  367:}
        -:  368:
function _glfwPlatformGetMonitorWorkarea called 0 returned 0% blocks executed 0%
    #####:  369:void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
        -:  370:                                     int* xpos, int* ypos,
        -:  371:                                     int* width, int* height)
        -:  372:{
    #####:  373:    MONITORINFO mi = { sizeof(mi) };
    #####:  374:    GetMonitorInfo(monitor->win32.handle, &mi);
    %%%%%:  374-block  0
call    0 never executed
        -:  375:
    #####:  376:    if (xpos)
branch  0 never executed
branch  1 never executed
    #####:  377:        *xpos = mi.rcWork.left;
    %%%%%:  377-block  0
    #####:  378:    if (ypos)
    %%%%%:  378-block  0
branch  0 never executed
branch  1 never executed
    #####:  379:        *ypos = mi.rcWork.top;
    %%%%%:  379-block  0
    #####:  380:    if (width)
    %%%%%:  380-block  0
branch  0 never executed
branch  1 never executed
    #####:  381:        *width = mi.rcWork.right - mi.rcWork.left;
    %%%%%:  381-block  0
    #####:  382:    if (height)
    %%%%%:  382-block  0
branch  0 never executed
branch  1 never executed
    #####:  383:        *height = mi.rcWork.bottom - mi.rcWork.top;
    %%%%%:  383-block  0
    #####:  384:}
        -:  385:
function _glfwPlatformGetVideoModes called 0 returned 0% blocks executed 0%
    #####:  386:GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count)
        -:  387:{
    #####:  388:    int modeIndex = 0, size = 0;
    #####:  389:    GLFWvidmode* result = NULL;
        -:  390:
    #####:  391:    *count = 0;
    %%%%%:  391-block  0
        -:  392:
        -:  393:    for (;;)
    #####:  394:    {
    %%%%%:  394-block  0
        -:  395:        int i;
        -:  396:        GLFWvidmode mode;
        -:  397:        DEVMODEW dm;
        -:  398:
    #####:  399:        ZeroMemory(&dm, sizeof(dm));
    #####:  400:        dm.dmSize = sizeof(dm);
        -:  401:
    #####:  402:        if (!EnumDisplaySettingsW(monitor->win32.adapterName, modeIndex, &dm))
    %%%%%:  402-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  403:            break;
        -:  404:
    #####:  405:        modeIndex++;
        -:  406:
        -:  407:        // Skip modes with less than 15 BPP
    #####:  408:        if (dm.dmBitsPerPel < 15)
    %%%%%:  408-block  0
branch  0 never executed
branch  1 never executed
    #####:  409:            continue;
    %%%%%:  409-block  0
    %%%%%:  409-block  1
        -:  410:
    #####:  411:        mode.width  = dm.dmPelsWidth;
    #####:  412:        mode.height = dm.dmPelsHeight;
    #####:  413:        mode.refreshRate = dm.dmDisplayFrequency;
    #####:  414:        _glfwSplitBPP(dm.dmBitsPerPel,
    %%%%%:  414-block  0
call    0 never executed
        -:  415:                      &mode.redBits,
        -:  416:                      &mode.greenBits,
        -:  417:                      &mode.blueBits);
        -:  418:
    #####:  419:        for (i = 0;  i < *count;  i++)
    %%%%%:  419-block  0
    %%%%%:  419-block  1
branch  0 never executed
branch  1 never executed
        -:  420:        {
    #####:  421:            if (_glfwCompareVideoModes(result + i, &mode) == 0)
    %%%%%:  421-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  422:                break;
    %%%%%:  422-block  0
        -:  423:        }
        -:  424:
        -:  425:        // Skip duplicate modes
    #####:  426:        if (i < *count)
    %%%%%:  426-block  0
branch  0 never executed
branch  1 never executed
    #####:  427:            continue;
    %%%%%:  427-block  0
        -:  428:
    #####:  429:        if (monitor->win32.modesPruned)
    %%%%%:  429-block  0
branch  0 never executed
branch  1 never executed
        -:  430:        {
        -:  431:            // Skip modes not supported by the connected displays
    #####:  432:            if (ChangeDisplaySettingsExW(monitor->win32.adapterName,
    %%%%%:  432-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  433:                                         &dm,
        -:  434:                                         NULL,
        -:  435:                                         CDS_TEST,
        -:  436:                                         NULL) != DISP_CHANGE_SUCCESSFUL)
        -:  437:            {
    #####:  438:                continue;
    %%%%%:  438-block  0
        -:  439:            }
        -:  440:        }
        -:  441:
    #####:  442:        if (*count == size)
    %%%%%:  442-block  0
branch  0 never executed
branch  1 never executed
        -:  443:        {
    #####:  444:            size += 128;
    #####:  445:            result = (GLFWvidmode*) realloc(result, size * sizeof(GLFWvidmode));
    %%%%%:  445-block  0
        -:  446:        }
        -:  447:
    #####:  448:        (*count)++;
    #####:  449:        result[*count - 1] = mode;
    %%%%%:  449-block  0
        -:  450:    }
        -:  451:
    #####:  452:    if (!*count)
    %%%%%:  452-block  0
branch  0 never executed
branch  1 never executed
        -:  453:    {
        -:  454:        // HACK: Report the current mode if no valid modes were found
    #####:  455:        result = calloc(1, sizeof(GLFWvidmode));
    #####:  456:        _glfwPlatformGetVideoMode(monitor, result);
    %%%%%:  456-block  0
call    0 never executed
    #####:  457:        *count = 1;
        -:  458:    }
        -:  459:
    #####:  460:    return result;
    %%%%%:  460-block  0
        -:  461:}
        -:  462:
function _glfwPlatformGetVideoMode called 1 returned 100% blocks executed 100%
        1:  463:void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
        -:  464:{
        -:  465:    DEVMODEW dm;
        1:  466:    ZeroMemory(&dm, sizeof(dm));
        1:  467:    dm.dmSize = sizeof(dm);
        -:  468:
        1:  469:    EnumDisplaySettingsW(monitor->win32.adapterName, ENUM_CURRENT_SETTINGS, &dm);
        1:  469-block  0
call    0 returned 1
        -:  470:
        1:  471:    mode->width  = dm.dmPelsWidth;
        1:  472:    mode->height = dm.dmPelsHeight;
        1:  473:    mode->refreshRate = dm.dmDisplayFrequency;
        1:  474:    _glfwSplitBPP(dm.dmBitsPerPel,
call    0 returned 1
        -:  475:                  &mode->redBits,
        -:  476:                  &mode->greenBits,
        -:  477:                  &mode->blueBits);
        1:  478:}
        -:  479:
function _glfwPlatformGetGammaRamp called 0 returned 0% blocks executed 0%
    #####:  480:GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
        -:  481:{
        -:  482:    HDC dc;
        -:  483:    WORD values[3][256];
        -:  484:
    #####:  485:    dc = CreateDCW(L"DISPLAY", monitor->win32.adapterName, NULL, NULL);
    %%%%%:  485-block  0
call    0 never executed
    #####:  486:    GetDeviceGammaRamp(dc, values);
call    0 never executed
    #####:  487:    DeleteDC(dc);
call    0 never executed
        -:  488:
    #####:  489:    _glfwAllocGammaArrays(ramp, 256);
call    0 never executed
        -:  490:
    #####:  491:    memcpy(ramp->red,   values[0], sizeof(values[0]));
    #####:  492:    memcpy(ramp->green, values[1], sizeof(values[1]));
    #####:  493:    memcpy(ramp->blue,  values[2], sizeof(values[2]));
        -:  494:
    #####:  495:    return GLFW_TRUE;
        -:  496:}
        -:  497:
function _glfwPlatformSetGammaRamp called 0 returned 0% blocks executed 0%
    #####:  498:void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
        -:  499:{
        -:  500:    HDC dc;
        -:  501:    WORD values[3][256];
        -:  502:
    #####:  503:    if (ramp->size != 256)
    %%%%%:  503-block  0
branch  0 never executed
branch  1 never executed
        -:  504:    {
    #####:  505:        _glfwInputError(GLFW_PLATFORM_ERROR,
    %%%%%:  505-block  0
call    0 never executed
        -:  506:                        "Win32: Gamma ramp size must be 256");
    #####:  507:        return;
        -:  508:    }
        -:  509:
    #####:  510:    memcpy(values[0], ramp->red,   sizeof(values[0]));
    #####:  511:    memcpy(values[1], ramp->green, sizeof(values[1]));
    #####:  512:    memcpy(values[2], ramp->blue,  sizeof(values[2]));
        -:  513:
    #####:  514:    dc = CreateDCW(L"DISPLAY", monitor->win32.adapterName, NULL, NULL);
    %%%%%:  514-block  0
call    0 never executed
    #####:  515:    SetDeviceGammaRamp(dc, values);
call    0 never executed
    #####:  516:    DeleteDC(dc);
call    0 never executed
        -:  517:}
        -:  518:
        -:  519:
        -:  520://////////////////////////////////////////////////////////////////////////
        -:  521://////                        GLFW native API                       //////
        -:  522://////////////////////////////////////////////////////////////////////////
        -:  523:
function glfwGetWin32Adapter called 0 returned 0% blocks executed 0%
    #####:  524:GLFWAPI const char* glfwGetWin32Adapter(GLFWmonitor* handle)
        -:  525:{
    #####:  526:    _GLFWmonitor* monitor = (_GLFWmonitor*) handle;
    #####:  527:    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
    %%%%%:  527-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  527-block  1
call    2 never executed
    #####:  528:    return monitor->win32.publicAdapterName;
    %%%%%:  528-block  0
        -:  529:}
        -:  530:
function glfwGetWin32Monitor called 0 returned 0% blocks executed 0%
    #####:  531:GLFWAPI const char* glfwGetWin32Monitor(GLFWmonitor* handle)
        -:  532:{
    #####:  533:    _GLFWmonitor* monitor = (_GLFWmonitor*) handle;
    #####:  534:    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
    %%%%%:  534-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  534-block  1
call    2 never executed
    #####:  535:    return monitor->win32.publicDisplayName;
    %%%%%:  535-block  0
        -:  536:}
        -:  537:
